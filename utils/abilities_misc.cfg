#textdomain wesnoth-help

#used for crossover

#define FILTER_GSE_MAGICABSORBER
    [not]
        [filter_adjacent]
            ability=eoma_magicabsorb
        [/filter_adjacent]
    [/not]
#enddef

#-------------------------------------------------------
#These are exact copies from default altered to work with the Magic Absorber ability in crossover:

#define ABILITY_GSE_HEALS
    [heals]
        value=4
        id=eoma_healing
        affect_allies=yes
        name= _ "heals +4"
        female_name= _ "female^heals +4"
        description=  _ "Allows the unit to heal adjacent allied units at the beginning of our turn.

A unit cared for by this healer may heal up to 4 HP per turn, or stop poison from taking effect for that turn.
A poisoned unit cannot be cured of its poison by a healer, and must seek the care of a village or a unit that can cure."
        affect_self=no
        poison=slowed
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
            [filter]
                {FILTER_GSE_MAGICABSORBER}
            [/filter]
        [/affect_adjacent]
    [/heals]
#enddef

#define ABILITY_GSE_EXTRA_HEAL
    [heals]
        value=8
        id=eoma_healing_extra
        affect_allies=yes
        name= _ "heals +8"
        female_name= _ "female^heals +8"
        description= _ "This unit combines herbal remedies with magic to heal units more quickly than is normally possible on the battlefield.

A unit cared for by this healer may heal up to 8 HP per turn, or stop poison from taking effect for that turn.
A poisoned unit cannot be cured of its poison by a healer, and must seek the care of a village or a unit that can cure."
        affect_self=no
        poison=slowed
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
            [filter]
                {FILTER_GSE_MAGICABSORBER}
            [/filter]
        [/affect_adjacent]
    [/heals]
#enddef

#define ABILITY_GSE_UNPOISON
    [heals]
        affect_allies=yes
        id=eoma_curing
        name= _ "cures"
        female_name= _ "female^cures"
        description= _ "A curer can cure a unit of poison, although that unit will receive no additional healing on the turn it is cured of the poison."
        affect_self=no
        poison=cured
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
            [filter]
                {FILTER_GSE_MAGICABSORBER}
            [/filter]
        [/affect_adjacent]
    [/heals]
#enddef

#define ABILITY_GSE_CURES
    {ABILITY_GSE_UNPOISON}
    {ABILITY_GSE_EXTRA_HEAL}
#enddef

#define ABILITY_GSE_REGENERATES
    [regenerate]
        value=8
        id=regenerates
        name= _ "regenerates"
        female_name= _ "female^regenerates"
        description= _ "The unit will heal itself 8 HP per turn. If it is poisoned, it will remove the poison instead of healing."
        affect_self=yes
        poison=cured
        [filter_self]
            {FILTER_GSE_MAGICABSORBER}
        [/filter_self]
    [/regenerate]
#enddef
#-------------------------------------------------------
#textdomain wesnoth-gse

#TODO: put some actual units here
#define STEPPE_NONLIVINGEXCEPTION
Todo#enddef

#defines units unaffected by fear-based abilities. put this in a filter
#define STEPPE_FEAREXEMPT
        ability=steppe_fearless#TODO
        [or]
        [filter_wml]
            [status]
                not_living="yes"
            [/status]
        [/filter_wml]
        [not]
        type={STEPPE_NONLIVINGEXCEPTION}
        [/not]
        [/or]
        [or]
            trait=fearless
#            [filter_wml]
#                [modifications]
#                    [trait]
#                        id=fearless
#                    [/trait]
#                [/modifications]
#            [/filter_wml]
        [/or]#enddef

#define WEAPON_SPECIAL_STEPPE_STUN
# wmlindent: start ignoring
# wmlxgettext: [attack]
# wmlxgettext: [specials]

# wmlindent: stop ignoring
    [dummy]
        id=steppe_stun
        name=_"stun"
        description=_"This attack hits so hard that the opponent is dazed and can no longer enforce a zone of control. The effect wears off on the opponent’s next turn. Only works on offense, and doesn't work on units who already don't have a ZoC."
    [/dummy]
    #events in STEPPE_EVENTS_STUN macro below, for eventloader (so the ability can be added via effect)
#enddef

#define STEPPE_EVENTS_STUN
[event]
    name=attacker_hits
    id=steppe_stun_event1
    first_time_only=no

    [filter_attack]
        special_id=steppe_stun
    [/filter_attack]

    [filter_second]
        [not]
            level=0
            [or]
                [filter_wml]
                    [status]
                        stunned=yes
                    [/status]
                [/filter_wml]
            [/or]
            [or]
                ability=steppe_stunned
            [/or]
        [/not]
    [/filter_second]

    {VARIABLE second_unit.status.stunned yes}
    [if]
        [variable]
            name=second_unit.gender
            equals=female
        [/variable]

        [then]
            [set_variable]
                name=tmp_stunned_text
#ifdef OGRE_RUSSIAN
                value= _ "оглушена"
#else
                value= _ "female^stunned"
#endif
            [/set_variable]
        [/then]

        [else]
            [set_variable]
                name=tmp_stunned_text
#ifdef OGRE_RUSSIAN
                value= _ "оглушен"
#else
                value= _ "stunned"
#endif
            [/set_variable]
        [/else]
    [/if]

    [unstore_unit]
        variable=second_unit
        find_vacant=no
        text=$tmp_stunned_text
        red,green,blue=196,196,128
    [/unstore_unit]

    [object]
        silent=yes
        duration=turn

        [filter]
            id=$second_unit.id
        [/filter]

        [effect]
            apply_to=image_mod
            add="CS(40,40,0)"
        [/effect]

        [effect]
            apply_to=zoc
            value=no
        [/effect]

        [effect]
            apply_to=new_ability
            [abilities]
              [dummy]
                 id=steppe_stunned
              [/dummy]
            [/abilities]
        [/effect]

    [/object]

    [clear_variable]
        name=tmp_stunned_text
    [/clear_variable]
[/event]

[event]
    name=defender_hits
    id=steppe_stun_event2
    first_time_only=no

    [filter_second_attack]
        special_id=steppe_stun
    [/filter_second_attack]

    [filter]
        [not]
            level=0
            [or]
                [filter_wml]
                    [status]
                        stunned=yes
                    [/status]
                [/filter_wml]
            [/or]
            [or]
                ability=steppe_stunned
            [/or]
        [/not]
    [/filter]

    {VARIABLE unit.status.stunned yes}
    [if]
        [variable]
            name=unit.gender
            equals=female
        [/variable]

        [then]
            [set_variable]
                name=tmp_stunned_text
                value= _ "female^stunned"
            [/set_variable]
        [/then]

        [else]
            [set_variable]
                name=tmp_stunned_text
                value= _ "stunned"
            [/set_variable]
        [/else]
    [/if]

    [unstore_unit]
        variable=unit
        find_vacant=no
        text=$tmp_stunned_text
        red,green,blue=196,196,128
    [/unstore_unit]

    [object]
        silent=yes
        duration=turn

        [filter]
            id=$unit.id
        [/filter]

        [effect]
            apply_to=image_mod
            add="CS(40,40,0)"
        [/effect]

        [effect]
            apply_to=zoc
            value=no
        [/effect]

        [effect]
            apply_to=new_ability
            [abilities]
              [dummy]
                 id=steppe_stunned
              [/dummy]
            [/abilities]
        [/effect]
    [/object]

    [clear_variable]
        name=tmp_stunned_text
    [/clear_variable]
[/event]

#NOTE: the image mod effect doesn't seem to erase when applied on the first turn of a match, unlike the paralyze ability, for some reason

[event]
    name=turn refresh
    id=steppe_stun_event3
    first_time_only=no

    [store_unit]
        [filter]
            side=$side_number
            [filter_wml]
                [status]
                    stunned=yes
                [/status]
            [/filter_wml]
        [/filter]
        variable=steppe_stunned
    [/store_unit]

    [foreach]
        array=steppe_stunned
        index_var=i
        [do]

        {CLEAR_VARIABLE this_item.status.stunned}

        [unstore_unit]
            variable=this_item
        [/unstore_unit]
        [object]
            silent=yes
            duration=turn
            sort=potion-like

            [filter]
                id=$this_item.id
            [/filter]

#            [effect]
#                apply_to=image_mod
#                add="CS(-40,-40,0)"
#            [/effect]
        [/object]
        [/do]
    [/foreach]

    {CLEAR_VARIABLE steppe_stunned}
[/event]
#enddef

#Incinerates
#define WEAPON_SPECIAL_INCINERATE
    [dummy]
        id=steppe_incinerate
        name=_"incinerate"
        description=_"This attack incinerates its targets. Burning units lose 12 HP every turn until they are cured. It can be cured either by either standing next to a healer, on a village, or in water. Flames can kill a unit, the attacker that incinerated the unit gets the experience. Note: this special doesn't have any effect on drakes, and units standing in water"
    [/dummy]
#enddef

#define EVENTS_INCINERATE
    [event]
        name=attacker_hits
        first_time_only=no
        [filter_attack]
            special_id=steppe_incinerate
        [/filter_attack]
        [filter_second]
          [not]
               [filter_location]
                   terrain=W*,W**,St,Sm
               [/filter_location]
               [or]
                 type=Fire Dragon
               [/or]
          [/not]
        [/filter_second]
        {VARIABLE second_unit.status.incinerated yes}
        {VARIABLE second_unit.variables.incinerator $unit.id}
        [unstore_unit]
            variable=second_unit
            find_vacant=no
        [/unstore_unit]
        [object]
            silent=yes
            sort=potion-like
            [filter]
                find_in=second_unit
            [/filter]
            [effect]
                apply_to=image_mod
                replace="CS(100,50,0)"
            [/effect]
        [/object]
    [/event]
    [event]
        name=defender_hits
        first_time_only=no
        [filter]
          [not]
            [filter_location]
                terrain=W*,W**,St,Sm
            [/filter_location]
            [or]
              type=Fire Dragon
            [/or]
          [/not]
        [/filter]
        [filter_second_attack]
            special_id=steppe_incinerate
        [/filter_second_attack]
        {VARIABLE unit.status.incinerated yes}
        {VARIABLE unit.variables.incinerator $second_unit.id}
        [unstore_unit]
            variable=unit
            find_vacant=no
        [/unstore_unit]

        [object]
            silent=yes
            sort=potion-like
            [filter]
                find_in=unit
            [/filter]
            [effect]
                apply_to=image_mod
                replace="CS(100,50,0)"
            [/effect]
        [/object]
    [/event]
    [event]
        name=turn refresh
        first_time_only=no

        [store_unit]
            [filter]
                [filter_wml]
                    [status]
                        incinerated=yes
                    [/status]
                [/filter_wml]
                [and]
                    [filter_side]
                        side=$side_number
                    [/filter_side]
                [/and]
                [and]
                    [filter_adjacent]
                        ability=healing
                    [/filter_adjacent]
                [/and]
                [or]
                    [filter_wml]
                        [status]
                            incinerated=yes
                        [/status]
                    [/filter_wml]
                    [and]
                        [filter_side]
                            side=$side_number
                        [/filter_side]
                    [/and]
                    [and]
                        [filter_location]
                            terrain=*^V*,W*
                        [/filter_location]
                    [/and]
                [/or]
             [or]
                    [filter_wml]
                        [status]
                            incinerated=yes
                        [/status]
                    [/filter_wml]
                    [and]
                        [filter_side]
                            side=$side_number
                        [/filter_side]
                    [/and]
                    [and]
                        [filter_location]
                            terrain=W*,W**,St,Sm
                        [/filter_location]
                    [/and]
             [/or]
            [/filter]
            variable=unburn_store
            kill=yes
        [/store_unit]

    [foreach]
        array=unburn_store
        index_var=i
        [do]
            {CLEAR_VARIABLE this_item.status.incinerated}
            {CLEAR_VARIABLE this_item.variables.incinerator}
            [unstore_unit]
                variable=this_item
                find_vacant=no
            [/unstore_unit]
            [object]
                silent=yes
                sort=potion-like
                [filter]
                    find_in=this_item
                [/filter]
                [effect]
                    apply_to=image_mod
                    replace="CS(0,0,0)"
                [/effect]
            [/object]
        [/do]
    [/foreach]

        {CLEAR_VARIABLE unburn_store}

        [store_unit]
            [filter]
                [filter_wml]
                    [status]
                        incinerated=yes
                    [/status]
                [/filter_wml]
                [and]
                    [filter_side]
                        side=$side_number
                    [/filter_side]
                [/and]
            [/filter]
            variable=burn_store
            kill=no
        [/store_unit]

        [foreach]
            array=burn_store
            index_var=i
            [do]
            [harm_unit]
                [filter]
                    id=$this_item.id
                [/filter]
                amount=12
                damage_type=fire
                fire_event=yes
                kill=no
                animate=yes
            [/harm_unit]
            [/do]
        [/foreach]

        {CLEAR_VARIABLE burn_store}
        [store_unit]
            [filter]
                [filter_wml]
                    [status]
                        incinerated=yes
                    [/status]
                [/filter_wml]
                [and]
                    [filter_side]
                        side=$side_number
                    [/filter_side]
                [/and]
                [and]
                    [filter_wml]
                        hitpoints=1
                    [/filter_wml]
                [/and]
            [/filter]
            variable=burn_store
            kill=no
        [/store_unit]

        [foreach]
            array=burn_store
            index_var=ti
            [do]
            [kill]
                id=$this_item.id
                animate=yes
                fire_event=yes
                experience=yes
        [filter_second]
            id=$this_item.variables.incinerator
        [/filter_second]
            [/kill]
            [/do]
        [/foreach]

        {CLEAR_VARIABLE burn_store}
    [/event]
    [event]
        name=victory
        [store_unit]
            [filter]
                [filter_wml]
                    [status]
                        incinerated=yes
                    [/status]
                [/filter_wml]
            [/filter]
            variable=unburn_store
            kill=yes
        [/store_unit]

        [foreach]
            array=unburn_store
            index_var=i
            [do]
            {CLEAR_VARIABLE this_item.status.incinerated}
            {CLEAR_VARIABLE this_item.variables.incinerator}
            [unstore_unit]
                variable=this_item
                find_vacant=no
            [/unstore_unit]
            [object]
                silent=yes
                sort=potion-like
                [filter]
                    find_in=this_item
                [/filter]
                [effect]
                    apply_to=image_mod
                    replace="CS(0,0,0)"
                [/effect]
            [/object]
            [/do]
        [/foreach]

        {CLEAR_VARIABLE unburn_store}
    [/event]
#enddef

#define ABILITY_WORK NUMBER 
    [dummy]
        id=work{NUMBER}
        name="work "+{NUMBER}
        description=_"This unit earns "+{NUMBER}+_" gold each turn if standing on an owned village."
    [/dummy]
    [dummy]
        id=workai
    [/dummy]
     # wmlxgettext: [abilities]
[/abilities]
    [event]
    name=side turn
    first_time_only=no
    [store_unit]
        [filter]
            side=$side_number
            ability=work{NUMBER}
        [filter_location]
            terrain=*^V*
            [and]
            owner_side=$side_number
            [or]
            owner_side=0
            [/or]
            [/and]
        [/filter_location]
        [not]
        [filter_wml]
        [status]
            petrified=yes
        [/status]
        [/filter_wml]
        [/not]
        [/filter]
        variable=worker
        kill=no
    [/store_unit]

    [foreach]
        array=worker
        index_var=i
        [do]
    [scroll_to]
        x,y=$this_item.x,$this_item.y
        side=$side_number
    [/scroll_to]
    [gold]
        side=$side_number
        amount={NUMBER}
    [/gold]
    [sound]
      name=gold.ogg
    [/sound]
        [unstore_unit]
            variable=this_item
            text=_"{NUMBER}g"
            red=255
            green=255
            blue=0
            find_vacant=no
        [/unstore_unit]
    [delay]
       time=100
    [/delay]
        [/do]
    [/foreach]

    [/event]

[+abilities] # wmlxgettext: [/abilities]
#enddef

#define ABILITY_STEPPE_SCAVENGER
    # Canned definition of the Feeding ability to be included in an
    # [abilities] clause.  Note: this is deliberately unbalanced WML,
    # in order to close the abilities clause then insert the event
    # then reopen the abilities clause.
    [dummy]
        id=steppe_scavenger
        name=_"scavenger"
        description=_"Whenever this unit kills a living enemy, it heals itself by 25% of the enemy's max health."
    [/dummy]
    # wmlxgettext: [abilities]
[/abilities]
[event]
    id=ability_steppe_scavenger_die
    name=die
    first_time_only=no

    [filter]
        [not]
            [filter_wml]
                [status]
                    undrainable="yes"
                [/status]
            [/filter_wml]
        [/not]
    [/filter]

    [filter_second]
        ability=steppe_scavenger
    [/filter_second]

    {VARIABLE bcvalue $unit.max_hitpoints}
    {VARIABLE_OP bcvalue divide 5}
    {VARIABLE_OP bcvalue round floor}
    
    [heal_unit]
      [filter]
        x,y=$x2,$y2
      [/filter]
      amount=$bcvalue
      animate=yes
      restore_statuses=no
    [/heal_unit]
    {CLEAR_VARIABLE bcvalue}
[/event]
[+abilities]
    # wmlxgettext: [/abilities]
#enddef
# wmllint: unbalanced-off

#define EVENTLOADER_EVENTS
    {EVENTS_INCINERATE}
    {STEPPE_EVENTS_STUN}
    [event]
    # is used to show icon in status bar
         name=preload
         first_time_only=no
         id=steppe_show_statuses
         [lua]
             code=<<
                 local _ = wesnoth.textdomain "wesnoth-gse"
                 local old_unit_status = wesnoth.interface.game_display.unit_status
                 function wesnoth.interface.game_display.unit_status()
                     local u = wesnoth.interface.get_displayed_unit()
                     if not u then return {} end
                     local s = old_unit_status()
                     if u.status.stunned then
                         table.insert(s, { "element", {
                             image = "misc/stunned.png",
                             tooltip = _"Stunned: This unit is stunned. It does not have a ZoC until the end of this turn."
                         } })
                     end
                     return s
                 end
             >>
         [/lua]
         [lua]
             code=<<
                 local _ = wesnoth.textdomain "wesnoth-gse"
                 local old_unit_status = wesnoth.interface.game_display.unit_status
                 function wesnoth.interface.game_display.unit_status()
                     local u = wesnoth.interface.get_displayed_unit()
                     if not u then return {} end
                     local s = old_unit_status()
                     if u.status.incinerated then
                         table.insert(s, { "element", {
                             image = "misc/incinerated.png",
                             tooltip = _"Incinerated: This unit is on fire. It takes 12 fire damage (can kill) each turn. This can be removed by standing in a village or in water."
                         } })
                     end
                     return s
                 end
             >>
         [/lua]
         [lua]
             code=<<
                 local _ = wesnoth.textdomain "wesnoth-gse"
                 local old_unit_status = wesnoth.interface.game_display.unit_status
                 function wesnoth.interface.game_display.unit_status()
                     local u = wesnoth.interface.get_displayed_unit()
                     if not u then return {} end
                     local s = old_unit_status()
                     if u.status.paralyzed then
                         table.insert(s, { "element", {
                             image = "misc/paralyzed.png",
                             tooltip = _"Paralyzed: This unit is paralyzed. Its attacks all have 1 strike each, and its defense on all terrain is reduced by 10%."
                         } })
                     end
                     return s
                 end
             >>
         [/lua]
    [/event]
#    [event]
#    name=start
#    [chat]
#    message=_"eventloader events loaded"
#    [/chat]
#    [/event]

    {EVENTLOADER_MULTIATTACK_EVENTS}
    {EVENTLOADER_HIT_AND_RUN_EVENTS}
#enddef

#define ABILITY_UNSLOWABLE
    [dummy]
        id=unslowable
        name=_"unslowable"
        description= "If this unit is slowed, the effect wears off at the end of the attack."
    [/dummy]
[/abilities]
  [event]
      name=attack end
      first_time_only=no

     [filter_second]
         ability=unslowable
     [/filter_second]
     {CLEAR_VARIABLE second_unit.status.slowed}
     [unstore_unit]
        variable=second_unit
        find_vacant=no
     [/unstore_unit]
  [/event]
  [event]
      name=attack end
      first_time_only=no
     [filter]
         ability=unslowable
     [/filter]
     {CLEAR_VARIABLE unit.status.slowed}
     [unstore_unit]
        variable=unit
        find_vacant=no
     [/unstore_unit]
  [/event]
[+abilities]
#enddef

#define ABILITY_PROTECTED NUMBER
    [resistance]
        id=protected{NUMBER}
        add={NUMBER}
        max_value=60
        # applies to any type if we leave it out
#        apply_to=blade,pierce,impact,fire,cold
        [filter_base_value]
#            greater_than=-20
            less_than=60
        [/filter_base_value]
        name="protected "+{NUMBER}
        description= _ "This unit’s resistances (blade,pierce,impact,fire and cold, but not arcane) are increased by "+{NUMBER}+_"% (up to 60%). However, this effect wears off after a turn."
        affect_self=yes
    [/resistance]
#enddef

#define ABILITY_STEPPE_HEALS VALUE
    [heals]
        value={VALUE}
#        id=healingsteppe{VALUE}
        id=healing
        affect_allies=yes
        name=_"heals"+" +{VALUE}"
        description=_"This unit heals adjacent units by "+{VALUE}+_" HP per turn, or stops poison from taking effect for that turn."
        affect_self=no
        poison=slowed
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
            [filter]
                {FILTER_GSE_MAGICABSORBER}
            [/filter]
        [/affect_adjacent]
    [/heals]
#enddef

#define ABILITY_STEPPE_CURES VALUE
    # Canned definition of the cure ability (which entails heal+8) to be
    # included in an [abilities] clause..
    {ABILITY_UNPOISON}
    {ABILITY_STEPPE_HEALS {VALUE}}
#enddef

#define ABILITY_STEPPE_REGENERATES VALUE
    # Canned definition of the Regenerate ability to be included in an [abilities]
    # clause.
    [regenerate]
        value={VALUE}
        id=regeneratessteppe{VALUE}
        name=_"regenerates"+" +{VALUE}"
        description=_"The unit will heal itself by "+{VALUE}+_" HP per turn. If it is poisoned, it will remove the poison instead of healing."
        affect_self=yes
        poison=cured
        [filter_self]
            {FILTER_GSE_MAGICABSORBER}
        [/filter_self]
    [/regenerate]
#enddef

#define ABILITY_STEPPE_REGENERATES_LESSER VALUE
    # Canned definition of the Regenerate ability to be included in an [abilities]
    # clause.
    [regenerate]
        value={VALUE}
        id=regeneratessteppe{VALUE}
        name=_"lesser regenerates"+" +{VALUE}"
        description=_"The unit will heal itself by "+{VALUE}+_" HP per turn.  This ability will not cure an affected unit of poison, however, only delay its effect."
        affect_self=yes
        poison=slowed
        [filter_self]
            {FILTER_GSE_MAGICABSORBER}
        [/filter_self]
    [/regenerate]
#enddef

#define WEAPON_SPECIAL_BLOCK VALUE MULT
    [damage]
        id=steppe_block{VALUE}
        name=_"block"
        description= _ "This attack reduces the opponent attack's damage by {VALUE}%"
        multiply={MULT}
        apply_to=attacker
        active_on=defense
    [/damage]
    [damage]
        id=steppe_block_attack{VALUE}
        multiply={MULT}
        apply_to=defender
        active_on=offense
    [/damage]
#enddef

#define WEAPON_SPECIAL_RELIABLE
    [chance_to_hit]
        id=reliable
        name=_"reliable"
        description=_"When used offensively, this attack's chance to hit is increased by 10%."
        add=10
        cumulative=yes
        active_on=offense
    [/chance_to_hit]
#enddef

#define WEAPON_SPECIAL_UNRELIABLE
    [chance_to_hit]
        id=unreliable
        name=_"unreliable"
        description=_"This attack's chance to hit is reduced by 10%."
        sub=10
        cumulative=yes
    [/chance_to_hit]
#enddef

#define ABILITY_LESSER_LEADERSHIP
    #basically like regular leadership, except only 15% per level
    [leadership]
        id=lesser_leadership
        value="(15 * (level - other.level))"
        cumulative=no
        name=_"lesser leadership"
        description=_"Works like normal leadership, except the damage bonus is only 15% per level."
        affect_self=no
        [affect_adjacent]
            [filter]
                formula="level < other.level"
            [/filter]
        [/affect_adjacent]
    [/leadership]
#enddef

##define WEAPON_SPECIAL_DESPERATE
#    #TODO: make the formula actually work
#    # Canned definition of the Desperate ability to be included in a
#    # [specials] clause.
#    [damage]
#        id=desperate
#        name= _ "desperate"
#        description= _ "This attack more damage the less hp the unit has, up to double damage."
#        multiply="(1.0 + (0.0 + hitpoints / max_hitpoints))"
#    [/damage]
##enddef

#define WEAPON_SPECIAL_STEPPE_ATTACK_ONLY
    [disable]
        id=steppe_attack_only
        name=_"attack-only"
        description=_"This attack can only be used offensively."
        active_on=defense
    [/disable]
#enddef

#define WEAPON_SPECIAL_STEPPE_DEFENSE_ONLY
    [disable]
        id=steppe_defense_only
        name=_"defense-only"
        description=_"This attack can only be used defensively."
        active_on=offense
    [/disable]
#enddef

#define WEAPON_SPECIAL_STEPPE_DEFENSE_ONLY2
#used for the captured status
    [disable]
        id=steppe_defense_only2
        name=_"defense-only"
        description=_"This attack can only be used defensively."
        active_on=offense
    [/disable]
#enddef

#macro for calculating a unit's exp worth (on kill, that is), to be used with some abilities
#define EXP_VALUE_CALC ID EXP_VARIABLE
        [store_unit]
            [filter]
                id={ID}
            [/filter]
            variable=steppe_exp_calc
            kill=no
        [/store_unit]
        {VARIABLE {EXP_VARIABLE} $steppe_exp_calc.level}
        {VARIABLE_OP {EXP_VARIABLE} multiply 8}
        {IF_VAR {EXP_VARIABLE} equals 0 (
            [then]
                {VARIABLE {EXP_VARIABLE} 4}
            [/then]
        )}
        {CLEAR_VARIABLE steppe_exp_calc}
#enddef

#define WEAPON_SPECIAL_STEPPE_FOCUSED
    # Canned definition of the Magical (targeting) ability to be included in a
    # [specials] clause.
    [chance_to_hit]
        id=steppe_focused
        name=_"focused"
        description=_"This attack always has a 80% chance to hit regardless of the defensive ability of the unit being attacked."
        value=80
        cumulative=no
    [/chance_to_hit]
#enddef

#define WEAPON_SPECIAL_BLOCK PERCENTAGE MULT
    [damage]
        id=steppe_block{PERCENTAGE}
        name=_"block {PERCENTAGE}%"
        description= _ "This attack reduces the opponent attack's damage by {PERCENTAGE}%"
        multiply={MULT}
#        apply_to=attacker
#        active_on=defense
    [/damage]
#    [damage]
#        id=steppe_block_attack{PERCENTAGE}
#        multiply={MULT}
#        apply_to=defender
#        active_on=offense
#    [/damage]
#enddef

#define WEAPON_SPECIAL_OVERWHELM
    [disable]
        id=overwhelm
        name=_"overwhelm"
        description=_"When used offensively, this attack makes the opponent unable to retaliate."
        active_on=offense
        apply_to=opponent
    [/disable]
#enddef

#define WEAPON_SPECIAL_STEPPE_TRAMPLE
    [dummy]
        id=steppe_trample
        name=_"trample"
        description=_"On offense, this unit moves to the tile behind the opponent after the attack. This does not work if that tile is either occupied or impassable."
    [/dummy]
    [/specials]
[/attack]

     [event]
       name=attack end
       first_time_only=no
   
       [filter_attack]
           special_id=steppe_trample
       [/filter_attack]
   
#       [filter_second]
#           [not]
#               [filter_location]
#                   terrain=*^V*
#               [/filter_location]
#           [/not]
#       [/filter_second]
   
               [store_locations]
                   [not]
                       [filter]
                       [/filter]
                       [or]
                       terrain=M*,Q*,X*,Wo*^* #mountains, unwalkable, impassable, and deep water
                       [/or]
                   [/not]
   
                   [filter_adjacent_location]
                       x,y=$x2,$y2
                       adjacent=-$unit.facing
                   [/filter_adjacent_location]
   
                   variable=knockback_target_hex
               [/store_locations]
   
               [if]
                   [variable]
                       name=knockback_target_hex.length
                       greater_than=0
                   [/variable]
   
                   [then]

                               {IF_VAR second_unit.hitpoints less_than_equal_to 0 (
                               [then]
#this code seems to be no longer necessary
##the events are fired manually, as trample kinda breaks them
##TODO: fix last breath events not working properly
#                               [fire_event]
#                                      name=last breath
#                                      [primary_unit]
#                                           x,y=$x2,$y2
#                                      [/primary_unit]
#                                      [secondary_unit]
#                                           x,y=$x1,$y1
#                                      [/secondary_unit]
#                                      [secondary_attack]
#                                           name=trample
#                                      [/secondary_attack]
#                               [/fire_event]
#                               {IF_VAR second_unit.hitpoints less_than_equal_to 0 (
#                               [then]
#second IF_VAR macro, in case the unit gets healed in the last breath event (such as with the disloyal ability)
#                               [fire_event]
#                                      name=die
#                                      [primary_unit]
#                                           x,y=$x2,$y2
#                                      [/primary_unit]
#                                      [secondary_unit]
#                                           x,y=$x1,$y1
#                                      [/secondary_unit]
#                               [/fire_event]
#                               [/then]
#                               )}

                               {EXP_VALUE_CALC $second_unit.id tmp_trample_exp}

                               [modify_unit]
                                    [filter]
                                        id=$unit.id
                                    [/filter]
                                    experience="$($unit.experience + $tmp_trample_exp)"
                               [/modify_unit]

                               {CLEAR_VARIABLE tmp_trample_exp}

                               [/then]
                               #if enemy is still alive, give the trampler exp equal to enemy level (no need to give exp to target, as target doesn't move)
                               [else]
                               [modify_unit]
                                    [filter]
                                        id=$unit.id
                                    [/filter]
                                    experience="$($unit.experience + $second_unit.level)"
                               [/modify_unit]
                               [/else]
                               )}

                        [teleport]
                            [filter]
                                x,y=$x1,$y1
                            [/filter]
                            animate=no#yes
                            
                            x,y=$knockback_target_hex.x,$knockback_target_hex.y
                           check_passability=yes
                           clear_shroud=yes
                        [/teleport]
                        [redraw]
                        [/redraw]
                       [if]
                           [have_unit]
                               x,y=$knockback_target_hex.x,$knockback_target_hex.y
                               id=$unit.id
                           [/have_unit]
   
                           [then]
                               
#                               [store_unit]
#                                   [filter]
#                                       x,y=$knockback_target_hex.x,$knockback_target_hex.y
#                                   [/filter]   
#                                   kill=no
#                                   variable=knockbacked
#                               [/store_unit]
   
#                               [unstore_unit]
#                                   variable=knockbacked
#                                   text= _ "Trample!"
#                                   {COLOR_HARM}
#                               [/unstore_unit]


                               [fire_event]
                                      name=moveto
                                      [primary_unit]
                                           x,y=$knockback_target_hex.x,$knockback_target_hex.y
                                      [/primary_unit]
                               [/fire_event]

#                               {CLEAR_VARIABLE knockbacked}
                           [/then]
                       [/if]
                   [/then]
               [/if]
   
               {CLEAR_VARIABLE knockback_direction,knockback_target_hex}
   [/event]
    [+attack]
    [+specials]
#enddef

#define STEPPE_ARMOBREAK_ANTISTACK VAR


#!!! WORK IN PROGRESS !!!


[if]
[have_unit]
    find_in={VAR}
    ability=armorbroken10
[/have_unit]
[and]
[have_unit]
    find_in={VAR}
    ability=armorbroken20
[/have_unit]
[/and]
[then]
        [object]
            silent=yes
            duration=turn
            [filter]
                find_in={VAR}
            [/filter]
       [effect]
          apply_to=remove_ability
          [abilities]
              {ABILITY_ARMOR_BROKEN 10}
          [/abilities]
       [/effect]
        [/object]
[/then]
[/if]
[if]
[have_unit]
    find_in={VAR}
    ability=armorbroken15
[/have_unit]
[and]
[have_unit]
    find_in={VAR}
    ability=armorbroken20
[/have_unit]
[/and]
[then]
        [object]
            silent=yes
            duration=turn
            [filter]
                find_in={VAR}
            [/filter]
       [effect]
          apply_to=remove_ability
          [abilities]
              {ABILITY_ARMOR_BROKEN 15}
          [/abilities]
       [/effect]
        [/object]
[/then]
[/if]
#enddef

#macro for calculating multiple units' total levels
#in the {FILTER}, do not add a [filter][/filter] tag
#set the {FOREACH_VALUE} to "a", if running from a {FOREACH i} 
#define TOTAL_LEVEL_CALC FILTER LEVELTOTAL_VARIABLE FOREACH_VALUE
    [if]
    [have_unit]
    {FILTER}
    [/have_unit]
    [then]
    [store_unit]
        [filter]
        {FILTER}
        [/filter]
        variable=steppe_level_calc
        kill=no
    [/store_unit]
    [foreach]
        array=steppe_level_calc
        index_var={FOREACH_VALUE}
        [do]
            {VARIABLE_OP {LEVELTOTAL_VARIABLE} add $this_item.level}
        [/do]
    [/foreach]

    {CLEAR_VARIABLE steppe_level_calc}
    [/then]
    [/if]
#enddef


#macro for calculating the number of total units
#in the {FILTER}, do not add a [filter][/filter] tag
#set the {FOREACH_VALUE} to "a", if running from a {FOREACH i} 
#define TOTAL_UNIT_CALC FILTER UNIT_TOTAL_VARIABLE FOREACH_VALUE
    [if]
    [have_unit]
    {FILTER}
    [/have_unit]
    [then]
    [store_unit]
        [filter]
        {FILTER}
        [/filter]
        variable=steppe_unit_calc
        kill=no
    [/store_unit]

    [foreach]
        array=steppe_unit_calc
        index_var={FOREACH_VALUE}
        [do]
            {VARIABLE_OP {UNIT_TOTAL_VARIABLE} add 1}
        [/do]
    [/foreach]

    {CLEAR_VARIABLE steppe_unit_calc}
    [/then]
    [/if]
#enddef

#define ABILITY_STEPPE_ANTISOCIAL VALUE
    #reduces damage of nearby allies
    [leadership]
        id=steppe_antisocial
        value=-{VALUE}
#        cumulative=yes
        cumulative=no#cumulative=yes is no longer needed in 1.16 for this to work
        name=_"antisocial"+" {VALUE}%"
        description=_"This unit is quite disliked by others, and will reduce adjacent ally units' damage by "+{VALUE}+_"%. This has no effect on non-living units, or other antisocial units."
        affect_self=no
        affect_allies=yes
        affect_enemies=no
        [affect_adjacent]
            [filter]
#                formula="level < other.level"
            [not]
            ability=steppe_antisocial
            [or]
                {STEPPE_FEAREXEMPT}
            [/or]
            [/not]
            [/filter]
        [/affect_adjacent]
    [/leadership]
#enddef

#hit-and-run comes in both ability and weapon special form

#define ABILITY_STEPPE_HITANDRUN VALUE
    [hitandrun]
        id=steppe_hitandrun
        name=_"hit and run "+{VALUE}
        description=_"This unit gains {VALUE} additional moves back after attacking, but cannot attack again."
        moves={VALUE}
    [/hitandrun] # wmlxgettext: [abilities]
#enddef

#define WEAPON_SPECIAL_HITANDRUN VALUE
    [hitandrun]
        id=steppe_hitandrun
        name=_"hit and run "+{VALUE}
        description=_"This unit gains {VALUE} additional moves back after attacking, but cannot attack again."
        moves={VALUE}
    [/hitandrun] # wmlxgettext: [abilities]
#enddef

#define EVENTLOADER_HIT_AND_RUN_EVENTS
[event]
    name=attack end
    id=attack_hitandrun_event
    first_time_only=no
    [filter_attack]
        special_id=steppe_hitandrun
    [/filter_attack]
    {VARIABLE_OP unit.moves add $weapon.specials.hitandrun.moves}
    [unstore_unit]
        variable=unit
        {COLOR_HEAL}
        text=_"+$weapon.specials.hitandrun.moves| movepoints"
        find_vacant=no
    [/unstore_unit]
[/event]
[event]
    name=attack end
    id=steppe_attack_hitandrun_ability_event
    first_time_only=no
    [filter]
        x,y=$x1,$y1
        ability=steppe_hitandrun
    [/filter]
    {VARIABLE_OP unit.moves add $unit.abilities.hitandrun.moves}
    [unstore_unit]
        variable=unit
        {COLOR_HEAL}
        text=_"+$unit.abilities.hitandrun.moves| movepoints"
        find_vacant=no
    [/unstore_unit]
[/event]
#enddef

#define ABILITY_STEPPE_AWE
    #reduces damage of nearby allies
    [leadership]
        id=steppe_awe
        value="(-15 * (level - other.level))"
        cumulative=yes
        name=_"awe"
        description=_"Enemies adjacent to this unit deal 15% less damage per level difference. Does not affect non-living or fearless units."
        affect_self=no
        affect_allies=no
        affect_enemies=yes
        [affect_adjacent]
            [filter]
                formula="level < other.level"
            [not]
                {STEPPE_FEAREXEMPT}
            [/not]
            [/filter]
        [/affect_adjacent]
    [/leadership]
#enddef

#define WEAPON_SPECIAL_STEPPE_HYPERFOCUSED
    # Canned definition of the Magical (targeting) ability to be included in a
    # [specials] clause.
    [chance_to_hit]
        id=steppe_hyperfocused
        name=_"hyperfocused"
        description=_"This attack always has a 90% chance to hit regardless of the defensive ability of the unit being attacked."
        value=90
        cumulative=no
    [/chance_to_hit]
#enddef

#define ABILITY_STEPPE_UPKEEPLESS
    [dummy]
        id=steppe_upkeepless
        name=_"upkeepless"
        description=_"This unit costs no upkeep."
    [/dummy]
    # wmlxgettext: [abilities]
[/abilities]
upkeep=0
[+abilities]
    # wmlxgettext: [/abilities]
#enddef

#define ABILITY_STEPPE_CUSTOM_UPKEEP VALUE
    [dummy]
        id=steppe_upkeep{VALUE}
        name="{VALUE} "+_"upkeep"
        description=_"This unit costs "+{VALUE}+_" upkeep instead of the amount equal to level."
    [/dummy]
    # wmlxgettext: [abilities]
[/abilities]
upkeep={VALUE}
[+abilities]
    # wmlxgettext: [/abilities]
#enddef

#define WEAPON_SPECIAL_STEPPE_QUAKE_EFFECT
#Dummy ability that applies a screenshake effect when the attack hits
    [dummy]
        id=steppe_quakeeffect
    [/dummy]
[/specials]
# wmlindent: start ignoring
[/attack]
# wmlindent: stop ignoring

[event]
    name=attacker_hits
    first_time_only=no

    [filter_attack]
        special_id=steppe_quakeeffect
    [/filter_attack]

    {QUAKE silence.ogg}
[/event]

[event]
    name=defender_hits
    first_time_only=no

    [filter_second_attack]
        special_id=steppe_quakeeffect
    [/filter_second_attack]
    {QUAKE silence.ogg}
[/event]
[+attack]
# wmlindent: start ignoring

[+specials]
# wmlxgettext: [/specials]
# wmlxgettext: [/attack]
# wmlindent: stop ignoring
#enddef

#----------------------------------------------------

#define STEPPE_EXPFREEZE_EVENT
 #copied and edited from EoMa
    [event]
        name=attack end
        first_time_only=no
        id=steppe_exp_freeze_event
        [filter_condition]
        {VARIABLE_CONDITIONAL tmp_steppe_antiloop not_equals yes}
        [/filter_condition]
        #this to prevent an infinite loop of attack end events
        {VARIABLE tmp_steppe_antiloop yes}

#        [chat]
#            message=_"expfreeze event triggered"
#        [/chat]

        [if]
        {VARIABLE_CONDITIONAL tmp_expfreeze_defense equals yes}
        [then]
        [store_unit]
            [filter]
                id=$second_unit.id
            [/filter]
            variable=unitexp
        [/store_unit]
        [/then]
        [else]
        [store_unit]
            [filter]
                id=$unit.id
            [/filter]
            variable=unitexp
        [/store_unit]
        [/else]
        [/if]

    [foreach]
        array=expfreeze
        index_var=x
        [do]

#        [chat]
#            message="expfreeze stats: id: $expfreeze[$x].id| level: $expfreeze[$x].level| hp: $expfreeze[$x].hitpoints|"
#        [/chat]

            [if]
                [have_unit]
                    id=$this_item.id
                [/have_unit]
                [then]
                #give units the exp as if they fought normally:
                    [store_unit]
                        [filter]
                            id=$this_item.id
                        [/filter]
                        variable=expfreeze_tmp
                    [/store_unit]
                    {VARIABLE_OP expfreeze_tmp.experience add $unit.level}
                    {VARIABLE_OP unitexp.experience add $this_item.level}
                    [unstore_unit]
                        variable=expfreeze_tmp
                        find_vacant=no
                    [/unstore_unit]
                    [fire_event]
                        name=attack end
                        [primary_unit]
                            id=$unit.id
                        [/primary_unit]
                        [secondary_unit]
                            id=$this_item.id
                        [/secondary_unit]
                    [/fire_event]
                    {CLEAR_VARIABLE this_item}
                    {CLEAR_VARIABLE expfreeze_tmp}
                [/then]
                [else]
                    {VARIABLE expkill $this_item.level}
                    {VARIABLE_OP expkill multiply 8}
                    {IF_VAR expkill equals 0 (
                        [then]
                            {VARIABLE expkill 4}
                        [/then]
                    )}
#                    [chat]
#                    message="expkill variable: $expkill|"
#                    [/chat]
                    {VARIABLE_OP unitexp.experience add $expkill}
                [/else]
            [/if]
        [/do]
    [/foreach]

    [if]
    {VARIABLE_CONDITIONAL unitexp.id not_equals $emptyvar}
    [then]
        [unstore_unit]
            variable=unitexp
            find_vacant=no
        [/unstore_unit]
    [/then]
    [/if]

        {CLEAR_VARIABLE expfreeze}
        {CLEAR_VARIABLE bystander}
        {CLEAR_VARIABLE expkill}
        {CLEAR_VARIABLE unitexp}
        {CLEAR_VARIABLE tmp_steppe_antiloop}
    [/event]
#enddef


#define WEAPON_SPECIAL_STEPPE_AREA_EFFECT_RANDOM CHANCETOHIT DAMAGEMULT
# wmlindent: start ignoring
# wmlxgettext: [attack]
# wmlxgettext: [specials]

# wmlindent: stop ignoring
    [damage]
        id=steppe_area_effect_random
        name=_"area of effect"+" {DAMAGEMULT}%/{CHANCETOHIT}%"
        description=_"When this attack is used, random enemies adjacent to the target take "+{DAMAGEMULT}+_"% of the basic damage, with a "+{CHANCETOHIT}+_"% chance. Does not work on defense."
    [/damage]
[/specials]
# wmlindent: start ignoring
[/attack]
# wmlindent: stop ignoring
[event]
    name=attacker_hits,attacker_misses
    id=steppe_areaeffect_event
    first_time_only=no
    [filter_attack]
        special_id=steppe_area_effect_random
    [/filter_attack]

    {VARIABLE tmp_aoedmg $weapon.damage}
    {VARIABLE_OP tmp_aoedmg multiply {DAMAGEMULT}}
    {VARIABLE_OP tmp_aoedmg divide 100}
    {VARIABLE_OP tmp_aoedmg round floor}

    [store_unit]
        [filter]
            [filter_adjacent]
                x,y=$x2,$y2
            [/filter_adjacent]
            [filter_side]
                [enemy_of]
                    side=$unit.side
                [/enemy_of]
            [/filter_side]
            [not]
                [filter_wml]
                    [status]
                        petrified=yes
                    [/status]
                [/filter_wml]
            [/not]
        [/filter]
        variable=steppe_bystander
    [/store_unit]

    [foreach]
        array=steppe_bystander
        index_var=i
        [do]
        {RANDOM 1..100}
        [if]
            {VARIABLE_CONDITIONAL random less_than_equal_to {CHANCETOHIT}}
            [then]
                [if]
                    [have_unit]
                        find_in=expfreeze
                        x,y=$this_item.x,$this_item.y
                    [/have_unit]
                    [else]
                    [fire_event]
                        name=attack
                        [primary_unit]
                            id=$unit.id
                        [/primary_unit]
                        [secondary_unit]
                            id=$this_item.id
                        [/secondary_unit]
                    [/fire_event]
                    [store_unit]
                        [filter]
                            x,y=$this_item.x,$this_item.y
                        [/filter]
                        variable=expfreeze
                        mode=append
                    [/store_unit]
                    [/else]
                [/if]
                [harm_unit]
                    [filter]
                        x,y=$this_item.x,$this_item.y
                        [filter_side]
                            [enemy_of]
                                side=$unit.side
                            [/enemy_of]
                        [/filter_side]
                        [not]
                            [filter_wml]
                                [status]
                                    petrified=yes
                                [/status]
                            [/filter_wml]
                        [/not]
                    [/filter]
                    [filter_second]
                        x,y=$x1,$y1
                    [/filter_second]
                    [primary_attack]
                        name=$weapon.name
                        type=$weapon.type
                        range=$weapon.range
                    [/primary_attack]
                    amount=$tmp_aoedmg
                    damage_type=$weapon.type
                    alignment=$unit.alignment
                    fire_event=yes
                    animate=defender
                    delay=0
                    experience=no
                [/harm_unit]
                {VARIABLE damage_inflicted $tmp_aoedmg}
                [fire_event]
                    name=attacker_hits
                    [primary_unit]
                        id=$unit.id
                    [/primary_unit]
                    [secondary_unit]
                        id=$this_item.id
                    [/secondary_unit]
                    [primary_weapon]
                        name=$weapon.name
                        type=$weapon.type
                        damage=$weapon.damage
                        range=$weapon.range
                    [/primary_weapon]
                [/fire_event]
            [/then]
        [/if]
        [/do]
    [/foreach]

    {CLEAR_VARIABLE tmp_aoedmg}
    {CLEAR_VARIABLE steppe_bystander}
[/event]

{STEPPE_EXPFREEZE_EVENT}
[+attack]
# wmlindent: start ignoring

[+specials]
# wmlxgettext: [/specials]
# wmlxgettext: [/attack]
# wmlindent: stop ignoring
#enddef

#define WEAPON_SPECIAL_STEPPE_CUSTOM_BACKSTAB PERCENTAGE MULT
    # Canned definition of the Backstab ability to be included in a
    # [specials] clause.
    [damage]
        id=steppe_custom_backstab{MULT}
        name=_"backstab {PERCENTAGE}%"
        name_inactive=_"backstab"+" {PERCENTAGE}%"
        description=_"Like backstab, but deals "+{PERCENTAGE}+_"% more damage instead of doubling."
        multiply={MULT}
        active_on=offense
        [filter_opponent]
            formula="
                enemy_of(self, flanker) and not flanker.petrified
            where
                flanker = unit_at(direction_from(loc, other.facing))
            "
        [/filter_opponent]
    [/damage]
#enddef

#define ABILITY_STEPPE_DARKENS
    [illuminates]
        id=steppe_darkens
        value=-25
        min_value=-25
        max_value=25
        cumulative=no
        affect_self=yes
        name=_"darkens"
        description=_"This unit darkens the surrounding area, making chaotic units fight better, and lawful units fight worse.

Any units adjacent to this unit will fight as if it were dusk when it is day, and as if it were night when it is dusk."
    [/illuminates]
#enddef

#define WEAPON_SPECIAL_STEPPE_ALWAYS_HITS
    [chance_to_hit]
        id=steppe_always_hits
        name=_"always hits"
        description=_"This attack always has a 100% chance to hit regardless of the defensive ability of the unit being attacked."
        value=100
        cumulative=no
    [/chance_to_hit]
#enddef

#define WEAPON_SPECIAL_STEPPE_OFFENSE_BERSERK
    # Canned definition of the Berserk ability to be included in a
    # [specials] clause.
    [berserk]
        id=steppe_offense_berserk
        name=_"offense berserk"
        description= _"Like berserk, but only works on offense."
        value=30
        active_on=offense
    [/berserk]
#enddef

#define ABILITY_STEPPE_LESSER_ILLUMINATES
    # Canned definition of the Illuminates ability to be included in an
    # [abilities] clause.
    [illuminates]
        id=lesser_illumination
        value=15
        max_value=25
        cumulative=no
        name=_"lesser illuminates"
        description=_"Works like illuminates, except it makes the time of day 15% brighter instead of 25%."
        affect_self=yes
    [/illuminates]
#enddef

#define WEAPON_SPECIAL_STEPPE_CUSTOM_DRAIN PERCENTAGE
    # Canned definition of the Backstab ability to be included in a
    # [specials] clause.
    [drains]
        id=steppe_custom_drain{PERCENTAGE}
        name=_"drain"+" {PERCENTAGE}%"
        description=_"Like drain, but heals by "+{PERCENTAGE}+_"% instead of 50%."
        value={PERCENTAGE}
    [/drains]
#enddef

#define WEAPON_SPECIAL_STEPPE_CUSTOM_BERSERK VALUE
    # Canned definition of the Berserk ability to be included in a
    # [specials] clause.
    [berserk]
        id=steppe_custom_berserk{VALUE}
        name=_"berserk"+" {VALUE}"
        description=_"Like berserk, but units fight "+{VALUE}+_" times instead of 30."
        value={VALUE}
    [/berserk]
#enddef

#define STEPPE_HPBASED_DAMAGE ID MULT MAXHP MINHP
[damage]
    id={ID}{MULT}
    multiply={MULT}
    apply_to=self
    [filter_self]
    formula=($this_unit.hitpoints < $this_unit.max_hitpoints * {MAXHP})
    [and]
        formula=($this_unit.hitpoints >= $this_unit.max_hitpoints * {MINHP})
    [/and]
    [/filter_self]
[/damage]
#enddef

#define WEAPON_SPECIAL_STEPPE_DESPERATE
[damage]
    id=steppe_desperate
    name=_"desperate"
    description=_"This attack deals 10% more damage for each 10% HP the unit is missing."
[/damage]
{STEPPE_HPBASED_DAMAGE steppe_desperate 1.1 0.9 0.8}
{STEPPE_HPBASED_DAMAGE steppe_desperate 1.2 0.8 0.7}
{STEPPE_HPBASED_DAMAGE steppe_desperate 1.3 0.7 0.6}
{STEPPE_HPBASED_DAMAGE steppe_desperate 1.4 0.6 0.5}
{STEPPE_HPBASED_DAMAGE steppe_desperate 1.5 0.5 0.4}
{STEPPE_HPBASED_DAMAGE steppe_desperate 1.6 0.4 0.3}
{STEPPE_HPBASED_DAMAGE steppe_desperate 1.7 0.3 0.2}
{STEPPE_HPBASED_DAMAGE steppe_desperate 1.8 0.2 0.1}
{STEPPE_HPBASED_DAMAGE steppe_desperate 1.9 0.1 0.05}
{STEPPE_HPBASED_DAMAGE steppe_desperate 2 0.05 -1}#so the bonus applies when below 0 hp, just in case
#enddef

#define ABILITY_STEPPE_RESOLUTE
    [dummy]
        id=steppe_resolute
        name=_"resolute"
        description=_"When below 60% hitpoints, this unit gains 10% to all resistances and regenerates 4 hp per turn. When below 30% hitpoints, this unit gains 20% to all resistances and regenerates 8 hp per turn."
    [/dummy]
    [resistance]
        id=steppe_resolute_resistance1
        add=10
        affect_self=yes
#        active_on=defense
        [filter]
        formula="(hitpoints < max_hitpoints * 0.6)"
        [and]
            formula="(hitpoints >= max_hitpoints * 0.3)"
        [/and]
        [/filter]
    [/resistance]
    [resistance]
        id=steppe_resolute_resistance2
        add=20
        affect_self=yes
#        active_on=defense
        [filter]
        formula="(hitpoints < max_hitpoints * 0.3)"
        [/filter]
    [/resistance]
#    [regenerate]
#        id=steppe_resolute_regen1
#        value=4
#        affect_self=yes
#        poison=slowed
#        [filter]
#        formula=($this_unit.hitpoints < $this_unit.max_hitpoints * 0.6)
#        [and]
#            formula=($this_unit.hitpoints >= $this_unit.max_hitpoints * 0.3)
#        [/and]
#        [/filter]
#    [/regenerate]
#    [regenerate]
#        id=steppe_resolute_regen2
#        value=8
#        affect_self=yes
#        poison=slowed
#        [filter]
#        formula=($this_unit.hitpoints < $this_unit.max_hitpoints * 0.3)
#        [/filter]
#    [/regenerate]
#enddef

#define ABILITY_STEPPE_WEAKENED VALUE
    #reduces damage of nearby allies
    [leadership]
        id=steppe_weakened
        value=-{VALUE}
#        cumulative=yes
        cumulative=no#cumulative=yes is no longer needed in 1.16 for this to work
        name=_"weakened {VALUE}%"
        description=_"This unit deals"+{VALUE}_"% less damage."
        affect_self=yes
        affect_allies=no
        affect_enemies=no
    [/leadership]
#enddef

#TODO: add defender hits event here
#TODO: maybe turn this code into a macro so that other similar abilities can easily be made

#define WEAPON_SPECIAL_STEPPE_WEAKEN NUMBER
# wmlindent: start ignoring
# wmlxgettext: [attack]
# wmlxgettext: [specials]

# wmlindent: stop ignoring
    [weaken]
        id=steppe_weaken
        name=_"weaken"+" {NUMBER}%"
        description=_"On hit, this attack reduces the enemy's damage by "+{NUMBER}+_"% for one turn. Applying a stronger version of this effect replaces the weaker one."
        weaken={NUMBER}
    [/weaken]
[/specials]
# wmlindent: start ignoring
[/attack]
# wmlindent: stop ignoring

[event]
    name=attacker_hits
    id=steppe_weaken_event1
    first_time_only=no

    [filter_attack]
        special_id=steppe_weaken
    [/filter_attack]

#    [filter_second]
#        [not]
#            [filter_wml]
#                [status]
#                    not_living="yes"
#                [/status]
#            [/filter_wml]
#            [or]
#                ability=steppe_depleting_hunn
#            [/or]
#        [/not]
#    [/filter_second]

    [if]
    [have_unit]
         id=$second_unit.id
         ability=steppe_weakened
    [/have_unit]
    [then]

    {IF_VAR second_unit.variables.weaken_percentage less_than $weapon.specials.weaken.weaken (
    [then]

#    [chat]
#        message=_"weaken removal triggered"
#    [/chat]

    {VARIABLE tmp_weaken_object yes}

    {VARIABLE tmp_can_weaken_enemy yes}
    [/then]
    [else]
    {VARIABLE tmp_can_weaken_enemy no}
    [/else])}

    [/then]
    [else]
    {VARIABLE tmp_can_weaken_enemy yes}

    [/else]
    [/if]

    {IF_VAR tmp_can_weaken_enemy equals yes (
    [then]

    {VARIABLE second_unit.variables.weaken_percentage $weapon.specials.weaken.weaken}

[floating_text]
   x,y=$x2,$y2
   text=_"<span color='#ff7e00'>weaken</span>"
[/floating_text]

    [unstore_unit]
        variable=second_unit
        find_vacant=no
#        text=$tmp_weakend_text
#        {COLOR_HARM}
    [/unstore_unit]

    {IF_VAR tmp_weaken_object equals yes (
    [then]

    [object]
        silent=yes
        duration=scenario

        [filter]
            find_in=second_unit
        [/filter]

        [effect]
            apply_to=remove_ability
            [abilities]
            {ABILITY_STEPPE_WEAKENED $second_unit.variables.weaken_percentage}
            [/abilities]
        [/effect]
    [/object]

    [/then]
    )}

    [object]
        silent=yes
        duration=scenario

        [filter]
            id=$second_unit.id
        [/filter]

        [effect]
            apply_to=new_ability
            [abilities]
            {ABILITY_STEPPE_WEAKENED $weapon.specials.weaken.weaken}
            [/abilities]
        [/effect]
    [/object]


    [clear_variable]
        name=tmp_weakend_text
    [/clear_variable]

    [/then])}
    {CLEAR_VARIABLE tmp_can_weaken_enemy}
    {CLEAR_VARIABLE tmp_weaken_object}
[/event]

[event]
    name=defender_hits
    id=steppe_weaken_event2
    first_time_only=no

    [filter_second_attack]
        special_id=steppe_weaken
    [/filter_second_attack]

#    [filter]
#        [not]
#            [filter_wml]
#                [status]
#                    not_living="yes"
#                [/status]
#            [/filter_wml]
#            [or]
#                ability=steppe_depleting_hunn
#            [/or]
#        [/not]
#    [/filter]

    [if]
    [have_unit]
         id=$unit.id
         ability=steppe_weakened
    [/have_unit]
    [then]

    {IF_VAR unit.variables.weaken_percentage less_than $second_weapon.specials.weaken.weaken (
    [then]

#    [chat]
#        message=_"weaken removal triggered"
#    [/chat]

    {VARIABLE tmp_weaken_object yes}

    {VARIABLE tmp_can_weaken_enemy yes}
    [/then]
    [else]
    {VARIABLE tmp_can_weaken_enemy no}
    [/else])}

    [/then]
    [else]
    {VARIABLE tmp_can_weaken_enemy yes}

    [/else]
    [/if]

    {IF_VAR tmp_can_weaken_enemy equals yes (
    [then]

    {VARIABLE unit.variables.weaken_percentage $second_weapon.specials.weaken.weaken}

[floating_text]
   x,y=$x1,$y1
   text=_"<span color='#ff7e00'>weaken</span>"
[/floating_text]

    [unstore_unit]
        variable=unit
        find_vacant=no
#        text=$tmp_weakend_text
#        {COLOR_HARM}
    [/unstore_unit]

    {IF_VAR tmp_weaken_object equals yes (
    [then]

    [object]
        silent=yes
        duration=scenario

        [filter]
            find_in=unit
        [/filter]

        [effect]
            apply_to=remove_ability
            [abilities]
            {ABILITY_STEPPE_WEAKENED $unit.variables.weaken_percentage}
            [/abilities]
        [/effect]
    [/object]

    [/then]
    )}

    [object]
        silent=yes
        duration=scenario

        [filter]
            id=$unit.id
        [/filter]

        [effect]
            apply_to=new_ability
            [abilities]
            {ABILITY_STEPPE_WEAKENED $second_weapon.specials.weaken.weaken}
            [/abilities]
        [/effect]
    [/object]


    [clear_variable]
        name=tmp_weakend_text
    [/clear_variable]

    [/then])}
    {CLEAR_VARIABLE tmp_can_weaken_enemy}
    {CLEAR_VARIABLE tmp_weaken_object}
[/event]

[event]
    name=side turn end
    id=steppe_weakened_side_turn_event
    first_time_only=no

    [store_unit]
        [filter]
            side=$side_number
            ability=steppe_weakened
        [/filter]
        variable=steppe_weakened
    [/store_unit]

    [foreach]
        array=steppe_weakened
        index_var=i
        [do]
    {CLEAR_VARIABLE this_item.variables.weaken_percentage}

    [object]
        silent=yes
        duration=scenario

        [filter]
            id=$this_item.id
        [/filter]

        [effect]
            apply_to=remove_ability
            [abilities]
              [dummy]
                 id=steppe_weakened
              [/dummy]
            [/abilities]
        [/effect]
    [/object]    
        [/do]
    [/foreach]

    {CLEAR_VARIABLE steppe_weakened}
[/event]

[+attack]
# wmlindent: start ignoring

[+specials]
# wmlxgettext: [/specials]
# wmlxgettext: [/attack]
# wmlindent: stop ignoring
#enddef


#define ABILITY_STEPPE_ARMORBROKEN NUMBER
    # Canned definition of the Steadfast ability to be included in an [abilities]
    # clause.
    [resistance]
        id=steppe_armorbroken
        sub={NUMBER}
        max_value=100
        # applies to any type if we leave it out
        apply_to=blade,pierce,impact
        [filter_base_value]
#            greater_than=-20
            less_than=100
        [/filter_base_value]
        name=_"broken armor "+{NUMBER}
        description=_"This unit’s physical resistances are reduced by "+{NUMBER}+_"%. This effect disappears after a turn."
        affect_self=yes
    [/resistance]
#enddef

#macro to be used in AMLAs, without events
#define STEPPE_ARMORBREAK NUMBER
    [armorbreak]
        id=steppe_armorbreak
        name=_"armorbreak"+" {NUMBER}%"
        description=_"On hit, this attack reduces the enemy's physical resistances by "+{NUMBER}+_"% for one turn. Applying a stronger version of this effect replaces the weaker one."
        armorbreak={NUMBER}
    [/armorbreak]
#enddef

#define WEAPON_SPECIAL_STEPPE_ARMORBREAK NUMBER
# wmlindent: start ignoring
# wmlxgettext: [attack]
# wmlxgettext: [specials]

# wmlindent: stop ignoring
    {STEPPE_ARMORBREAK {NUMBER}}
[/specials]
# wmlindent: start ignoring
[/attack]
# wmlindent: stop ignoring

[event]
    name=attacker_hits
    id=steppe_armorbreak_event1
    first_time_only=no

    [filter_attack]
        special_id=steppe_armorbreak
    [/filter_attack]

#    [filter_second]
#        [not]
#            [filter_wml]
#                [status]
#                    not_living="yes"
#                [/status]
#            [/filter_wml]
#            [or]
#                ability=steppe_depleting_hunn
#            [/or]
#        [/not]
#    [/filter_second]

#ifdef OGRE_RUSSIAN
    {VARIABLE steppe_hunntext_russian_enabled yes}
#else
    {VARIABLE steppe_hunntext_russian_enabled no}
#endif

    [if]
    [have_unit]
         id=$second_unit.id
         ability=steppe_armorbroken
    [/have_unit]
    [then]

    {IF_VAR second_unit.variables.armorbreak_percentage less_than $weapon.specials.armorbreak.armorbreak (
    [then]

#    [chat]
#        message=_"armorbreak removal triggered"
#    [/chat]

    {VARIABLE tmp_armorbreak_object yes}

    {VARIABLE tmp_can_armorbreak_enemy yes}
    [/then]
    [else]
    {VARIABLE tmp_can_armorbreak_enemy no}
    [/else])}

    [/then]
    [else]
    {VARIABLE tmp_can_armorbreak_enemy yes}

    [/else]
    [/if]

    {IF_VAR tmp_can_armorbreak_enemy equals yes (
    [then]

    {VARIABLE second_unit.variables.armorbreak_percentage $weapon.specials.armorbreak.armorbreak}

{IF_VAR steppe_hunntext_russian_enabled equals yes (
[then]
[floating_text]
   x,y=$x2,$y2
   text="<span color='#ff7e00'>поломанная броня</span>"
[/floating_text]
[/then]
[else]
[floating_text]
   x,y=$x2,$y2
   text="<span color='#ff7e00'>armor broken</span>"
[/floating_text]
[/else])}

    [unstore_unit]
        variable=second_unit
        find_vacant=no
#        text=$tmp_armorbreakd_text
#        {COLOR_HARM}
    [/unstore_unit]

    {IF_VAR tmp_armorbreak_object equals yes (
    [then]

    [object]
        silent=yes
        duration=scenario

        [filter]
            find_in=second_unit
        [/filter]

        [effect]
            apply_to=remove_ability
            [abilities]
            {ABILITY_STEPPE_ARMORBROKEN $second_unit.variables.armorbreak_percentage}
            [/abilities]
        [/effect]
        [effect]
            apply_to=overlay
            remove="misc/overlay-armorbroken.png"
        [/effect]
    [/object]

    [/then]
    )}

    [object]
        silent=yes
        duration=scenario

        [filter]
            id=$second_unit.id
        [/filter]

        [effect]
            apply_to=new_ability
            [abilities]
            {ABILITY_STEPPE_ARMORBROKEN $weapon.specials.armorbreak.armorbreak}
            [/abilities]
        [/effect]
        [effect]
            apply_to=overlay
            add="misc/overlay-armorbroken.png"
        [/effect]
    [/object]


    [clear_variable]
        name=tmp_armorbreakd_text
    [/clear_variable]

    [/then])}
    {CLEAR_VARIABLE tmp_can_armorbreak_enemy}
    {CLEAR_VARIABLE tmp_armorbreak_object}
[/event]

[event]
    name=defender_hits
    id=steppe_armorbreak_event2
    first_time_only=no

    [filter_second_attack]
        special_id=steppe_armorbreak
    [/filter_second_attack]

#    [filter]
#        [not]
#            [filter_wml]
#                [status]
#                    not_living="yes"
#                [/status]
#            [/filter_wml]
#            [or]
#                ability=steppe_depleting_hunn
#            [/or]
#        [/not]
#    [/filter]

#ifdef OGRE_RUSSIAN
    {VARIABLE steppe_hunntext_russian_enabled yes}
#else
    {VARIABLE steppe_hunntext_russian_enabled no}
#endif

    [if]
    [have_unit]
         id=$unit.id
         ability=steppe_armorbroken
    [/have_unit]
    [then]

    {IF_VAR unit.variables.armorbreak_percentage less_than $second_weapon.specials.armorbreak.armorbreak (
    [then]

#    [chat]
#        message=_"armorbreak removal triggered"
#    [/chat]

    {VARIABLE tmp_armorbreak_object yes}

    {VARIABLE tmp_can_armorbreak_enemy yes}
    [/then]
    [else]
    {VARIABLE tmp_can_armorbreak_enemy no}
    [/else])}

    [/then]
    [else]
    {VARIABLE tmp_can_armorbreak_enemy yes}

    [/else]
    [/if]

    {IF_VAR tmp_can_armorbreak_enemy equals yes (
    [then]

    {VARIABLE unit.variables.armorbreak_percentage $second_weapon.specials.armorbreak.armorbreak}

[floating_text]
   x,y=$x1,$y1
   text=_"<span color='#ff7e00'>armor broken</span>"
[/floating_text]

    [unstore_unit]
        variable=unit
        find_vacant=no
#        text=$tmp_armorbreakd_text
#        {COLOR_HARM}
    [/unstore_unit]

    {IF_VAR tmp_armorbreak_object equals yes (
    [then]

    [object]
        silent=yes
        duration=scenario

        [filter]
            find_in=unit
        [/filter]

        [effect]
            apply_to=remove_ability
            [abilities]
            {ABILITY_STEPPE_ARMORBROKEN $unit.variables.armorbreak_percentage}
            [/abilities]
        [/effect]
        [effect]
            apply_to=overlay
            remove="misc/overlay-armorbroken.png"
        [/effect]
    [/object]

    [/then]
    )}

    [object]
        silent=yes
        duration=scenario

        [filter]
            id=$unit.id
        [/filter]

        [effect]
            apply_to=new_ability
            [abilities]
            {ABILITY_STEPPE_ARMORBROKEN $second_weapon.specials.armorbreak.armorbreak}
            [/abilities]
        [/effect]
        [effect]
            apply_to=overlay
            add="misc/overlay-armorbroken.png"
        [/effect]
    [/object]


    [clear_variable]
        name=tmp_armorbreakd_text
    [/clear_variable]

    [/then])}
    {CLEAR_VARIABLE tmp_can_armorbreak_enemy}
    {CLEAR_VARIABLE tmp_armorbreak_object}
[/event]

[event]
    name=side turn end
    id=steppe_armorbreaked_side_turn_event
    first_time_only=no

    [store_unit]
        [filter]
            side=$side_number
            ability=steppe_armorbroken
        [/filter]
        variable=steppe_armorbreaked
    [/store_unit]

    [foreach]
        array=steppe_armorbreaked
        index_var=i
        [do]
    {CLEAR_VARIABLE this_item.variables.armorbreak_percentage}

    [object]
        silent=yes
        duration=scenario

        [filter]
            id=$this_item.id
        [/filter]

        [effect]
            apply_to=remove_ability
            [abilities]
              [dummy]
                 id=steppe_armorbroken
              [/dummy]
            [/abilities]
        [/effect]
        [effect]
            apply_to=overlay
            remove="misc/overlay-armorbroken.png"
        [/effect]
    [/object]    
        [/do]
    [/foreach]

    {CLEAR_VARIABLE steppe_armorbreaked}
[/event]

[+attack]
# wmlindent: start ignoring

[+specials]
# wmlxgettext: [/specials]
# wmlxgettext: [/attack]
# wmlindent: stop ignoring
#enddef

#define ABILITY_STEPPE_REFLECT_DAMAGE VALUE
    [reflect_damage]
        id=steppe_reflect_damage
        name=_"reflect damage "+{VALUE}+"%"
        description=_"When this unit is hit, part of the damage received is also dealt to the enemy. This ignores enemy resistances and can kill."
        value={VALUE}
    [/reflect_damage] # wmlxgettext: [abilities]
[/abilities]

[event]
    name=attacker hits
    id=steppe_relfect_onhit1
    first_time_only=no
   
    [filter_second]
        ability=steppe_reflect_damage
    [/filter_second]

    {VARIABLE tmp_reflect_damage $damage_inflicted}
    {VARIABLE_OP tmp_reflect_damage multiply $second_unit.abilities.reflect_damage.value}
    {VARIABLE_OP tmp_reflect_damage divide 100}

    [if]
    {VARIABLE_CONDITIONAL tmp_reflect_damage greater_than_equal_to $unit.hitpoints }
    [then]
#        [chat]
#            message=$depleting[$i].variables.decay_cursed_by
#        [/chat]
        [harm_unit]
            [filter]
                id=$unit.id
            [/filter]
            [filter_second]
                id=$second_unit.id
            [/filter_second]
            amount=$tmp_reflect_damage
            experience=yes
            fire_event=yes
            animate=defender
            kill=yes
        [/harm_unit]
    [/then]
    [else]
        [harm_unit]
            [filter]
                id=$unit.id
            [/filter]
            [filter_second]
                id=$second_unit.id
            [/filter_second]
            amount=$tmp_reflect_damage
            experience=no
            fire_event=yes
            animate=defender
            kill=no
        [/harm_unit]
    [/else]
    [/if]

    {CLEAR_VARIABLE tmp_reflect_damage}
[/event]

[event]
    name=defender hits
    id=steppe_relfect_onhit2
    first_time_only=no
   
    [filter]
        ability=steppe_reflect_damage
    [/filter]

    {VARIABLE tmp_reflect_damage $damage_inflicted}
    {VARIABLE_OP tmp_reflect_damage multiply $unit.abilities.reflect_damage.value}
    {VARIABLE_OP tmp_reflect_damage divide 100}

    [if]
    {VARIABLE_CONDITIONAL tmp_reflect_damage greater_than_equal_to $second_unit.hitpoints }
    [then]
#        [chat]
#            message=$depleting[$i].variables.decay_cursed_by
#        [/chat]
        [harm_unit]
            [filter]
                id=$second_unit.id
            [/filter]
            [filter_second]
                id=$unit.id
            [/filter_second]
            amount=$tmp_reflect_damage
            experience=yes
            fire_event=yes
            animate=defender
            kill=yes
        [/harm_unit]
    [/then]
    [else]
        [harm_unit]
            [filter]
                id=$second_unit.id
            [/filter]
            [filter_second]
                id=$unit.id
            [/filter_second]
            amount=$tmp_reflect_damage
            experience=no
            fire_event=yes
            animate=defender
            kill=no
        [/harm_unit]
    [/else]
    [/if]

    {CLEAR_VARIABLE tmp_reflect_damage}
[/event]
[+abilities] # wmlxgettext: [/abilities]
#enddef

#define ABILITY_STEPPE_INSPIRE
    [leadership]
        id=steppe_inspire
        value="(15 * (level - other.level + 1))"
        cumulative=no
        name=_"inspire"
        description=_"Adjacent allies deal more damage - 15% if the same level, 30% if one level lower, 45% if two levels lower, etc."
        affect_self=no
        [affect_adjacent]
            [filter]
                formula="level < other.level + 1"
            [/filter]
        [/affect_adjacent]
    [/leadership]
#enddef

#define ABILITY_STEPPE_MENTOR VALUE
    [mentor]
        id=steppe_mentor
        name=_"mentor "+{VALUE}
        description=_"Each turn, this unit gives adjacent allies +{VALUE} experience."
        value={VALUE}
    [/mentor] # wmlxgettext: [abilities]
[/abilities]
    [event]
        name=side turn
        id=steppe_mentor_event
        first_time_only=no
    [store_unit]
        [filter]
            ability=steppe_mentor
            side=$side_number
        [not]
        [filter_wml]
        [status]
            petrified=yes
        [/status]
        [/filter_wml]
        [/not]
        [/filter]
        variable=steppe_mentor
        kill=no
    [/store_unit]
    [store_side]
        side=$side_number
        variable=steppe_mentorside
    [/store_side]
    [foreach]
        array=steppe_mentor
        index_var=i
        [do]
    [scroll_to]
        x,y=$this_item.x,$this_item.y
    [/scroll_to]

    [store_unit]
        [filter]
            [filter_side]
            [allied_with]
                side=$side_number
            [/allied_with]
            [/filter_side]
            [filter_adjacent]
                x,y=$this_item.x,$this_item.y
            [/filter_adjacent]
        [not]
        [filter_wml]
        [status]
            petrified=yes
        [/status]
        [/filter_wml]
        [/not]
        [/filter]
        variable=steppe_mentor_units
        kill=no
    [/store_unit]
    {VARIABLE tmp_mentor_exp $this_item.abilities.mentor.value}

    [foreach]
        array=steppe_mentor_units
        index_var=e
        [do]
    {VARIABLE_OP this_item.experience add $tmp_mentor_exp}

    [unstore_unit]
        variable=this_item
#ifdef OGRE_RUSSIAN
        text="+$tmp_mentor_exp| опыта"
#else
        text="+$tmp_mentor_exp| exp"
#endif
#        red=0
#        green=0
#        blue=255
        find_vacant=no
    [/unstore_unit]

    [/do]
    [/foreach]

    [/do]
    [/foreach]
    {CLEAR_VARIABLE steppe_mentor}
    {CLEAR_VARIABLE steppe_mentorside}
    {CLEAR_VARIABLE steppe_mentor_units}
    {CLEAR_VARIABLE tmp_mentor_exp}
    [/event]
[+abilities] # wmlxgettext: [/abilities]
#enddef

#define ABILITY_SELF_UNPOISON
    # Canned definition of the Regenerate ability to be included in an [abilities]
    # clause.
    [regenerate]
        value=0
        id=self_unpoison
        name=_"self-unpoison"
        description=_"If poisoned, this unit will remove their own poison at the start of each turn instead of healing."
        affect_self=yes
        poison=cured
    [/regenerate]
#enddef

#define ABILITY_STEPPE_HIDE_ALLIES
    [hides]
        id=steppe_hide_allies
        name=_"hide allies"
        name_inactive=_"hide allies"
        description= _"This unit makes adjacent allies invisible. If the allies move away from this unit, they become visible again. Does not affect buildings."
        affect_self=no
        affect_allies=yes
        [filter]
        [/filter]
        [affect_adjacent]
            [filter]
                [not]
                    ability=steppe_building
                [/not]
            [/filter]
        [/affect_adjacent]
    [/hides]
#enddef

#define ABILITY_STEPPE_HILLSTALK
    [hides]
        id=steppe_hillstalk
        name=_"hillstalk"
        description=_"This unit is invisible on hill/mountain terrain."
        affect_self=yes
        [filter]
            [filter_location]
                terrain=H*^*,M*^*
            [/filter_location]
        [/filter]
    [/hides]
#enddef

#define STEPPE_TOD_AREA_EVENT ID TAG_NAME TOD
#note: {ID} must match ability id
    [event]
    name=unit placed,die,moveto,post advance
    id=steppe_{ID}_event
    first_time_only=no
    [filter]
        ability={ID}
    [/filter]
    [filter_condition]
    {VARIABLE_CONDITIONAL tmp_steppe_antiloop not_equals yes}
    [/filter_condition]
    {VARIABLE tmp_steppe_antiloop yes}
[remove_time_area]
    id={ID}
[/remove_time_area]
[store_unit]
    [filter]
        ability={ID}
    [/filter]
    variable={ID}
    kill=no
[/store_unit]
[foreach]
    array={ID}
    index_var=i
    [do]
#    [chat]
#        message=$this_item.abilities.light_area.r
#    [/chat]
    [if]
    [have_unit]
        id=$this_item.id
    [/have_unit]
    [and]
    {VARIABLE_CONDITIONAL this_item.hitpoints greater_than 0}
    [/and]
    [then]
[time_area]
    id={ID}
    [filter]
        id=$this_item.id
    [/filter]
    radius=$this_item.abilities.{TAG_NAME}.radius
#    remove=yes
    {TOD}
[/time_area]
[redraw][/redraw]
    [/then]
    [/if]
    [/do]
[/foreach]
{CLEAR_VARIABLE {ID}}
{CLEAR_VARIABLE tmp_steppe_antiloop}
    [/event]
#enddef

#define ABILITY_STEPPE_LIGHT_AREA RADIUS
    [light_area]
        id=steppe_light_area
        name=_"light area"+" {RADIUS}"
        description= _"This unit illuminates tiles in a {RADIUS}-tile radius. Unlike normal illuminates, this ability sets ToD light to 25% even during night."
        radius={RADIUS}
    [/light_area]
[/abilities]
    {STEPPE_TOD_AREA_EVENT steppe_light_area light_area {STEPPE_TOD_ILLUMINATED}}
[+abilities]
#enddef

#define ABILITY_STEPPE_DARK_AREA RADIUS
    [dark_area]
        id=steppe_dark_area
        name=_"dark area"+" {RADIUS}"
        description= _"This unit darkens tiles in a {RADIUS}-tile radius. Unlike normal darkens, this ability sets ToD light to -25% even during day."
        radius={RADIUS}
    [/dark_area]
[/abilities]
    {STEPPE_TOD_AREA_EVENT steppe_dark_area dark_area {STEPPE_TOD_DARKENED}}
[+abilities]
#enddef

#define WEAPON_SPECIAL_STEPPE_REDUCE_DEFENSE VALUE
# wmlindent: start ignoring
# wmlxgettext: [attack]
# wmlxgettext: [specials]

# wmlindent: stop ignoring
    [reduce_defense]
        id=steppe_reduce_defense
        name=_"reduce defense"+" {VALUE}%"
        description=_"On hit, this reduces the enemy's defense on all terrain by "+{VALUE}+_"% for 1 turn. This stacks."
        value={VALUE}
    [/reduce_defense]
[/specials]
# wmlindent: start ignoring
[/attack]
# wmlindent: stop ignoring

[event]
    name=attacker_hits
    id=steppe_reduce_defense_event1
    first_time_only=no

    [filter_attack]
        special_id=steppe_reduce_defense
    [/filter_attack]

    [unstore_unit]
        variable=second_unit
        find_vacant=no
        text=_"-$weapon.specials.reduce_defense.value| defense"
        red,green,blue=255,125,0
    [/unstore_unit]

    [object]
        silent=yes
        duration=turn end

        [filter]
            id=$second_unit.id
        [/filter]

        [effect]
            apply_to=defense
            replace=no
            [defense]
                deep_water=$weapon.specials.reduce_defense.value
                shallow_water=$weapon.specials.reduce_defense.value
                swamp_water=$weapon.specials.reduce_defense.value
                reef=$weapon.specials.reduce_defense.value
                flat=$weapon.specials.reduce_defense.value
                sand=$weapon.specials.reduce_defense.value
                forest=$weapon.specials.reduce_defense.value
                hills=$weapon.specials.reduce_defense.value
                mountains=$weapon.specials.reduce_defense.value
                village=$weapon.specials.reduce_defense.value
                castle=$weapon.specials.reduce_defense.value
                cave=$weapon.specials.reduce_defense.value
                frozen=$weapon.specials.reduce_defense.value
                unwalkable=$weapon.specials.reduce_defense.value
                impassable=$weapon.specials.reduce_defense.value
                fungus=$weapon.specials.reduce_defense.value
            [/defense]
        [/effect]
    [/object]
[/event]

[event]
    name=defender_hits
    id=steppe_reduce_defense_event2
    first_time_only=no

    [filter_second_attack]
        special_id=steppe_reduce_defense
    [/filter_second_attack]

    [unstore_unit]
        variable=unit
        find_vacant=no
        text=_"-$second_weapon.specials.reduce_defense.value| defense"
        red,green,blue=255,125,0
    [/unstore_unit]

    [object]
        silent=yes
        duration=turn end

        [filter]
            id=$unit.id
        [/filter]

        [effect]
            apply_to=defense
            replace=no
            [defense]
                deep_water=$second_weapon.specials.reduce_defense.value
                shallow_water=$second_weapon.specials.reduce_defense.value
                swamp_water=$second_weapon.specials.reduce_defense.value
                reef=$second_weapon.specials.reduce_defense.value
                flat=$second_weapon.specials.reduce_defense.value
                sand=$second_weapon.specials.reduce_defense.value
                forest=$second_weapon.specials.reduce_defense.value
                hills=$second_weapon.specials.reduce_defense.value
                mountains=$second_weapon.specials.reduce_defense.value
                village=$second_weapon.specials.reduce_defense.value
                castle=$second_weapon.specials.reduce_defense.value
                cave=$second_weapon.specials.reduce_defense.value
                frozen=$second_weapon.specials.reduce_defense.value
                unwalkable=$second_weapon.specials.reduce_defense.value
                impassable=$second_weapon.specials.reduce_defense.value
                fungus=$second_weapon.specials.reduce_defense.value
            [/defense]
        [/effect]
    [/object]
[/event]

[+attack]
# wmlindent: start ignoring

[+specials]
# wmlxgettext: [/specials]
# wmlxgettext: [/attack]
# wmlindent: stop ignoring
#enddef

#define WEAPON_SPECIAL_STEPPE_GIANTSLAYER
[damage]
    id=steppe_giantslayer
    name=_"giantslayer"
    description= _ "This attack deals 25% more damage for each level the enemy is above this unit."
    multiply="(1.0 + ((defender.level - attacker.level) * 0.25))"
    apply_to=self
    active_on=offense
    [filter_opponent]
        formula="level > other.level"#only applies to units above the unit's level
    [/filter_opponent]
[/damage]
[damage]
    id=steppe_giantslayer2
    multiply="(1.0 + ((attacker.level - attacker.level) * 0.25))"
    apply_to=self
    active_on=defense
    [filter_opponent]
        formula="level > other.level"#only applies to units above the unit's level
    [/filter_opponent]
[/damage]
#enddef

#ability version:

#define ABILITY_STEPPE_GIANTSLAYER
[damage]
    id=steppe_giantslayer
    name=_"giantslayer"
    description= _ "This attack deals 25% more damage for each level the enemy is above this unit."
    multiply="(1.0 + ((defender.level - attacker.level) * 0.25))"
    apply_to=self
    active_on=offense
    [filter_opponent]
        formula="level > other.level"#only applies to units above the unit's level
    [/filter_opponent]
    affect_self=yes
[/damage]
[damage]
    id=steppe_giantslayer2
    multiply="(1.0 + ((attacker.level - attacker.level) * 0.25))"
    apply_to=self
    active_on=defense
    [filter_opponent]
        formula="level > other.level"#only applies to units above the unit's level
    [/filter_opponent]
    affect_self=yes
[/damage]
#enddef

#define MULTIATTACK_SECOND_ATTACK UNITVAR ID ATTACKLIMIT
    [set_variable]
        name={UNITVAR}.attacks_left
        add=1
    [/set_variable]

    [unstore_unit]
#        text= _ "attacks left: $({ATTACKLIMIT} - ${UNITVAR}.variables.multiattack_attacks_done|)"
        text= _ "can attack again!"
        {COLOR_HEAL}
#        red=255
#        green=255
#        blue=255
        variable={UNITVAR}
    [/unstore_unit]

#    [set_variable]
#        name={UNITVAR}.moves
#        add=$(${UNITVAR}.max_moves * 0.25)
#    [/set_variable]

    [set_variables]
        name={UNITVAR}.variables
        mode=merge
        [value]
            multiattack_turn=$turn_number
        [/value]
    [/set_variables]

    [set_variable]
        name={UNITVAR}.variables.multiattack_attacks_done
        add=1
    [/set_variable]

    [unstore_unit]
        variable={UNITVAR}
    [/unstore_unit]

    [object]
        silent=yes
        duration=turn#turn end
     
        [filter]
            find_in={UNITVAR}
        [/filter]
        [effect]
            apply_to=attack
            [not]
            special_id={ID}
            [/not]
            [set_specials]
                mode=append
                {WEAPON_SPECIAL_MULTIATTACK_DISABLEATTACK}
            [/set_specials]
        [/effect]
    [/object]
#enddef

#define WEAPON_SPECIAL_MULTIATTACK_DISABLEATTACK
#invisible weapon special for the carousel to disable other attacks
    [disable]
        id=steppe_multiattack_disableattack
#commented out, as it's just for debugging
#        name="carousel disable" "хоровод выключает"}
        active_on=offense
    [/disable]
#enddef

#define STEPPE_MULTIATTACK_EVENTS ID ATTACKLIMIT
[event]
    name=side turn
    id=steppe_multiattack_event_{ID}
    first_time_only=no

    [store_unit]
        [filter]
            [has_attack]
                special_id={ID}
            [/has_attack]
        [/filter]
        variable={ID}_unit_store
    [/store_unit]

    [foreach]
        array={ID}_unit_store
        index_var=i
        [do]
            {VARIABLE this_item.variables.multiattack_attacks_done 0}

            [unstore_unit]
                variable=this_item
                find_vacant=no
            [/unstore_unit]
        [/do]
    [/foreach]

    {CLEAR_VARIABLE {ID}_unit_store}
[/event]

[event]
    name=attack_end
    id=steppe_multiattack_event_{ID}2
    first_time_only=no
    [filter_attack]
        special_id={ID}
    [/filter_attack]

    [store_unit]
        [filter]
            id=$unit.id
        [/filter]
        variable=tmp_multiattack_unit_store
    [/store_unit]

    [if]
        {VARIABLE_CONDITIONAL tmp_multiattack_unit_store.variables.multiattack_attacks_done less_than {ATTACKLIMIT} }
        [then]
            {MULTIATTACK_SECOND_ATTACK unit {ID} {ATTACKLIMIT} }
        [/then]
        [else]
            [if]
                {VARIABLE_CONDITIONAL tmp_multiattack_unit_store.variables.multiattack_turn not_equals $turn_number}
                [then]
                    {VARIABLE unit.variables.multiattack_attacks_done 0}
                    {MULTIATTACK_SECOND_ATTACK unit {ID} {ATTACKLIMIT} }
                [/then]
            [/if]
        [/else]
    [/if]
[/event]

[event]
    name=victory,side turn
    id=steppe_carousel_event_{ID}3
    first_time_only=no

    {CLEAR_VARIABLE tmp_multiattack_unit_store}
    {CLEAR_VARIABLE carousel_unit_store}
[/event]
#enddef

#define WEAPON_SPECIAL_STEPPE_DOUBLE_ATTACK
    # wmlxgettext: [attack]
    # wmlxgettext: [specials]
    [dummy]
        id=steppe_double_attack
        name=_"double attack"
        description= _"After using this attack, this unit and can attack again, but only with the same attack (or another attack with the same weapon special)."
    [/dummy]
#enddef

#define WEAPON_SPECIAL_STEPPE_TRIPLE_ATTACK
    # wmlxgettext: [attack]
    # wmlxgettext: [specials]
    [dummy]
        id=steppe_triple_attack
        name=_"triple attack"
        description= _"After using this attack, this unit and can attack again two more times, but only with the same attack (or another attack with the same weapon special)."
    [/dummy]
#enddef

#using global events so that the abilities can be added to AMLAS
#define EVENTLOADER_MULTIATTACK_EVENTS
    {STEPPE_MULTIATTACK_EVENTS steppe_double_attack 1}#this is amount of bonus attacks, not total attack
    {STEPPE_MULTIATTACK_EVENTS steppe_triple_attack 2}#this is amount of bonus attacks, not total attack
#enddef

#define STEPPE_STACKING_DUMMY_SPECIAL NAME DAMAGE
    [damage]
        id=steppe_stacking{NAME}{DAMAGE}
        name={NAME}+" +{DAMAGE}"
        description=_"When this attack is used, its damage increases by"+" {DAMAGE} "+"after each successful hit. After the unit stops attacking, the damage resets to normal."
    [/damage]
#enddef

#events are seperate, in case I need to add the ability via amla
#define STEPPE_STACKING_EVENTS NAME DAMAGE
[event]
    name=attack
    id=steppe_stacking_event1{NAME}{DAMAGE}
    first_time_only=no
    [filter_attack]
        special_id=steppe_stacking{NAME}{DAMAGE}
    [/filter_attack]

    {VARIABLE tmp_stacking_dmgbonus 0}
[/event]

[event]
    name=attacker_hits
    first_time_only=no
    id=steppe_stacking_event2
    [filter_attack]
        special_id=steppe_stacking{NAME}{DAMAGE}
    [/filter_attack]

    {VARIABLE_OP tmp_stacking_dmgbonus add 1}

    [object]
        silent=yes
        duration=turn end
        [filter]
            find_in=unit
        [/filter]
        [effect]
            apply_to=attack
            special_id=steppe_stacking{NAME}{DAMAGE}
            increase_damage=1
        [/effect]
    [/object]
[/event]

[event]
    name=attack end
    id=steppe_stacking_event3
    first_time_only=no
    [filter_attack]
        special_id=steppe_stacking{NAME}{DAMAGE}
    [/filter_attack]

#reset the damage
    [object]
        silent=yes
        duration=turn end
        [filter]
            find_in=unit
        [/filter]
        [effect]
            apply_to=attack
            special_id=steppe_stacking{NAME}{DAMAGE}
            increase_damage=-$tmp_stacking_dmgbonus
        [/effect]
    [/object]
    {CLEAR_VARIABLE tmp_stacking_dmgbonus}
[/event]

[event]
    name=attack
    id=steppe_stacking_event12{NAME}{DAMAGE}
    first_time_only=no
    [filter_second_attack]
        special_id=steppe_stacking{NAME}{DAMAGE}
    [/filter_second_attack]

    {VARIABLE tmp_stacking_dmgbonus2 0}
[/event]

[event]
    name=defender_hits
    first_time_only=no
    id=steppe_stacking_event22
    [filter_second_attack]
        special_id=steppe_stacking{NAME}{DAMAGE}
    [/filter_second_attack]

    {VARIABLE_OP tmp_stacking_dmgbonus2 add 1}

    [object]
        silent=yes
        duration=turn end
        [filter]
            find_in=second_unit
        [/filter]
        [effect]
            apply_to=attack
            special_id=steppe_stacking{NAME}{DAMAGE}
            increase_damage=1
        [/effect]
    [/object]
[/event]

[event]
    name=attack end
    id=steppe_stacking_event32
    first_time_only=no
    [filter_second_attack]
        special_id=steppe_stacking{NAME}{DAMAGE}
    [/filter_second_attack]

#reset the damage
    [object]
        silent=yes
        duration=turn end
        [filter]
            find_in=second_unit
        [/filter]
        [effect]
            apply_to=attack
            special_id=steppe_stacking{NAME}{DAMAGE}
            increase_damage=-$tmp_stacking_dmgbonus2
        [/effect]
    [/object]
    {CLEAR_VARIABLE tmp_stacking_dmgbonus2}
[/event]
#enddef

#define WEAPON_SPECIAL_STEPPE_STACKING NAME DAMAGE
# wmlindent: start ignoring
# wmlxgettext: [attack]
# wmlxgettext: [specials]

# wmlindent: stop ignoring
    {STEPPE_STACKING_DUMMY_SPECIAL {NAME} {DAMAGE}}
[/specials]
# wmlindent: start ignoring
[/attack]
# wmlindent: stop ignoring
{STEPPE_STACKING_EVENTS {NAME} {DAMAGE}}
[+attack]
# wmlindent: start ignoring

[+specials]
# wmlxgettext: [/specials]
# wmlxgettext: [/attack]
# wmlindent: stop ignoring
#enddef

#define WEAPON_SPECIAL_STEPPE_KAMIKAZE
# wmlindent: start ignoring
# wmlxgettext: [attack]
# wmlxgettext: [specials]

# wmlindent: stop ignoring
    [dummy]
        id=steppe_kamikaze
        name=_"kamikaze"
        description=_"When this unit hits an enemy with this attack, the unit dies."
    [/dummy]
[/specials]
# wmlindent: start ignoring
[/attack]
# wmlindent: stop ignoring

#more complicated than EoMa's kamikaze, to avoid breaking some events (the kamikaze unit is hidden/petrified until other events trigger first, and THEN killed):

[event]
    name=attacker_hits
    id=steppe_kamikaze_event
    first_time_only=no

    [filter_attack]
        special_id=steppe_kamikaze
    [/filter_attack]

    [hide_unit]
        id=$unit.id
    [/hide_unit]

#petrifying the unit to end the attack
    [petrify]
        id=$unit.id
    [/petrify]
[/event]

[event]
    name=attack end
    id=steppe_kamikaze_event2
    first_time_only=no

    [filter_attack]
        special_id=steppe_kamikaze
    [/filter_attack]

    [kill]
        id=$unit.id
        animate=no
        fire_event=yes
    [/kill]
[/event]

[+attack]
# wmlindent: start ignoring

[+specials]
# wmlxgettext: [/specials]
# wmlxgettext: [/attack]
# wmlindent: stop ignoring
#enddef

#define WEAPON_SPECIAL_STEPPE_LESSER_PERCENTILE_DAMAGE PERCENT MULT
[damage]
    id=steppe_lesser_percenticle_damage{PERCENT}
    name= _ "lesser percentile damage"+" {PERCENT}%"
    description= _ "This attack deals bonus damage equal to "+{PERCENT}+_"% of the enemy's current hitpoints. (the bonus damage is still affected by resistances though)."
    add="(defender.hitpoints * {MULT})"
    apply_to=self
    active_on=offense
[/damage]
[damage]
    id=steppe_lesser_percenticle_damage{PERCENT}
    add="(attacker.hitpoints * {MULT})"
    apply_to=self
    active_on=defense
[/damage]
#enddef

#define WEAPON_SPECIAL_STEPPE_PERCENTILE_DAMAGE PERCENT MULT
[damage]
    id=steppe_percenticle_damage{PERCENT}
    name= _ "percentile damage"+" {PERCENT}%"
    description= _ "This attack deals bonus damage equal to "+{PERCENT}+_"% of the enemy's max hitpoints (the bonus damage is still affected by resistances though)."
    add="(defender.max_hitpoints * {MULT})"
    apply_to=self
    active_on=offense
[/damage]
[damage]
    id=steppe_percenticle_damage{PERCENT}
    add="(attacker.max_hitpoints * {MULT})"
    apply_to=self
    active_on=defense
[/damage]
#enddef