#textdomain wesnoth-gse

#define ABILITY_STEPPE_REPAIR VALUE
    [heals]
        value={VALUE}
#        id=healingsteppe{VALUE}
        id=healing
        affect_allies=yes
        name=_"repair"+" +{VALUE}"
        description=_"This unit heals adjacent mechanical units by "+{VALUE}+_" HP per turn"
        affect_self=no
        poison=cured
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
            [filter]
                trait=mechanical#so it works on other add-ons' machine races
            [/filter]
        [/affect_adjacent]
    [/heals]
#enddef

#define EVENTLOADER_EVENTS_SLAV_BUILDING
[event]
name=side turn 1
id=slav_spawnwalls_event
first_time_only=no
#Wall spawning is disabled for balance reasons, but the code can stay just in case (for stuff like campaigns maybe)
[if]
#{VARIABLE_CONDITIONAL steppe_disablebuildings not_equals yes}
{VARIABLE_CONDITIONAL steppe_spawnwall_enabled equals yes}
[then]
{IF_VAR steppe_wallradius greater_than 0 (
[else]
{VARIABLE steppe_wallradius 3}
[/else])}
{VARIABLE steppe_wallradius2 $steppe_wallradius}
{IF_VAR steppe_thickwalls equals yes (
[then]
{VARIABLE_OP steppe_wallradius2 sub 2}
[/then]
[else]
{VARIABLE_OP steppe_wallradius2 sub 1}
[/else])}
[store_locations]
[filter]
   ability=slavfaction
   canrecruit=yes
   side=$side_number
[/filter]
radius=$steppe_wallradius
include_borders=no #otherwise causes weird bugs if the starting keep is close to the border and the leader is AI
variable=walls
[/store_locations]
[if]
[have_unit]
   ability=slavfaction
   side=$side_number
   canrecruit=yes
   formula="(level >= 3)"
[/have_unit]
[then]
{VARIABLE walltype Tall_Woodwall}

    [store_unit]
        [filter]
            side=$side_number
            canrecruit=yes
        [/filter]
        variable=tmp_wall_leader
    [/store_unit]

    {VARIABLE tmp_wall_level 0}
    {GSE_DEPRECATED_MACRO_FOREACH tmp_wall_leader i}
    {IF_VAR tmp_wall_leader[$i].level greater_than $tmp_wall_level (
    [then]
        {VARIABLE tmp_wall_level $tmp_wall_leader[$i].level}
    [/then]
    )}
    {GSE_DEPRECATED_MACRO_NEXT i}


   {VARIABLE tmp_wall_hpbonus $tmp_wall_level}
   {VARIABLE_OP tmp_wall_hpbonus sub 3}
   {VARIABLE_OP tmp_wall_hpbonus multiply 30}

   {CLEAR_VARIABLE tmp_wall_leader}
   {CLEAR_VARIABLE tmp_wall_level}

[/then]
[else]
{VARIABLE walltype Woodwall}
[/else]
[/if]
#[if]
#[have_unit]
#   ability=slavfaction
#   side=$side_number
#   canrecruit=yes
#   level=4
#[/have_unit]
#[then]
#{VARIABLE walltype Dwarvenwall}
#[/then]
#[/if]
{GSE_DEPRECATED_MACRO_FOREACH walls i}

[if]
[not]
[have_unit]
   ability=slavfaction
   side=$side_number
   canrecruit=yes
   [filter_location]
      x,y=$walls[$i].x,$walls[$i].y
      radius=$steppe_wallradius2
   [/filter_location]
[/have_unit]
[/not]
[and]
[not]
[have_location]
#   terrain=_off^_usr,Q*,W*,*^X*,X*,*^V*,Ce*,Ch,Ch*,Cv*,Co*,Cu*,Ct*#,K*
   terrain=_off^_usr,Q*,W*,*^X*,X*,*^V*,C*,K*
   x,y=$walls[$i].x,$walls[$i].y
   [not]
     terrain=Wwf
   [/not]
[/have_location]
[/not]
[/and]
[and]
[not]
[have_unit]
   x,y=$walls[$i].x,$walls[$i].y
[/have_unit]
[/not]
[/and]
[then]
    {UNIT $side_number $walltype| $walls[$i].x $walls[$i].y ()}
    {IF_VAR tmp_wall_hpbonus greater_than 0 (
    [then]
    [object]
        silent=yes
        duration=forever
        [filter]
            x,y=$walls[$i].x,$walls[$i].y
        [/filter]
        [effect]
            apply_to=hitpoints
            increase=$tmp_wall_hpbonus
            increase_total=$tmp_wall_hpbonus
        [/effect]
    [/object]
    [/then]
    )}
       #debug code to see which buildings were made by the wallspawn event
#       [label]
#          x,y=$walls[$i].x,$walls[$i].y
#          text=$walls[$i].x,$walls[$i].y
#       [/label]
[/then]
[/if]

{GSE_DEPRECATED_MACRO_NEXT i}
{CLEAR_VARIABLE walls}
{CLEAR_VARIABLE walltype}
{CLEAR_VARIABLE tmp_wall_hpbonus}
[/then]
[/if]
[/event]
[event]
name=start
id=steppe_demolish_menu
first_time_only=no
    [set_menu_item]
        id=steppe_demolish
        description=_"Destroy this building (gives a <span color='#cccc33'>33%</span> gold refund, costs <span color='#2c9fed'>40%</span> of the demolisher's moves)"
        image="misc/arsonicon.png"
        [show_if]
        [/show_if]

        [filter_location]
            [filter]
                    ability=steppe_building
            [filter_side]
            [allied_with]
                    side=$side_number
            [/allied_with]
            [/filter_side]
            [/filter]
            [filter_adjacent_location]
                [filter]
                    side=$side_number
                    formula=($this_unit.moves >= $this_unit.max_moves * 0.40)
                    [not]
                    ability=steppe_building
                    [/not]
                [/filter]
            [/filter_adjacent_location]
        [/filter_location]
        [command]
   [store_unit]
       [filter]
           side=$side_number
           formula=($this_unit.moves >= $this_unit.max_moves * 0.40)
           [filter_adjacent]
               x,y=$x1,$y1
           [/filter_adjacent]
           [not]
           trait=mechanical#so it works on other add-ons' machine races
           [/not]
       [/filter]
       variable=able_to_demolish
   [/store_unit]

    [if]
    [variable]
        name=able_to_demolish.length
        greater_than=0
    [/variable]
    [then]

    {VARIABLE demolisher_random_limit $able_to_demolish.length}
    {VARIABLE_OP demolisher_random_limit sub 1}
    {RANDOM 0..$demolisher_random_limit}

#since the array number is offset by one from the length (if there are 2 units, the length is 2, but the units are [0] and [1])

#the exp is calculated based on cost and level
#    {VARIABLE tmp_demolisher_exp 1}
#    {VARIABLE_OP able_to_demolish[$random].experience add $tmp_demolisher_exp}
    {VARIABLE demolishmoves $able_to_demolish[$random].max_moves}
    {VARIABLE_OP demolishmoves multiply 0.40}
    {VARIABLE_OP able_to_demolish[$random].moves sub $demolishmoves}

    [unstore_unit]
        variable=able_to_demolish[$random]
        find_vacant=no
    [/unstore_unit]
    [fire_event]
        name=post demolish
        [primary_unit]
            x,y=$x1,$y1
        [/primary_unit]
    [/fire_event]
    [/then]
    [/if]
    {CLEAR_VARIABLE demolisher_random_limit}
    {CLEAR_VARIABLE tmp_demolisher_exp}
    {CLEAR_VARIABLE demolishmoves}

        [store_unit]
            [filter]
                 x,y=$x1,$y1
            [/filter]
            variable=destroyedbuilding
        [/store_unit]
        {VARIABLE destroyrefund $destroyedbuilding.cost}
        {VARIABLE_OP destroyrefund divide 3}
        {VARIABLE_OP destroyrefund round ceil}
    [gold]
        side=$side_number
        amount=$destroyrefund
    [/gold]
    [sound]
      name=gold.ogg
    [/sound]
        [unstore_unit]
            variable=destroyedbuilding
            text=_"$destroyrefund|g"
            red=255
            green=255
            blue=0
            find_vacant=no
        [/unstore_unit]
        {CLEAR_VARIABLE destroyedbuilding}
        {CLEAR_VARIABLE destroyedbuildingtype}
        {CLEAR_VARIABLE destroyrefund}

        [kill]
            x,y=$x1,$y1
            animate=yes
            fire_event=yes
        [/kill]
        [/command]
    [/set_menu_item]
[/event]
[event]
name=start
id=steppe_building_guide_menu
first_time_only=no
    [set_menu_item]
        id=building_guide
        description=_"Building guide"
        image="items/book2.png~CROP(21,23,27,24)~SCALE(20,20)"
        #This is to prevent the menu from being shown to more than one player. IF THIS MENU CAUSES OOS, THIS SETTING IS THE PROBLEM:
        synced=no
        [show_if]
        [/show_if]
        [filter_location]
            [filter]
                ability=steppe_build
                side=$side_number
            [/filter]
        [/filter_location]
        [command]

    [set_variables]
        name=buildguide_options[0]
        mode=replace
        [value]
            image=_"attacks/blank-attack.png"
            message=_"Return to the game"
            [command]
            [allow_undo] [/allow_undo]
            [/command]
        [/value]
    [/set_variables]

    [store_unit]
        [filter]
            x,y=$x1,$y1
        [/filter]
        variable=tmp_buildguide_unit
        kill=no
    [/store_unit]

    [foreach]
        array=tmp_buildguide_unit.abilities.build_option
        index_var=i
        [do]
        [store_unit_type]
            type=$this_item.build_unit
            variable=tmp_buildguide_building
        [/store_unit_type]
        [set_variables]
            name=buildguide_options
            mode=append
            [value]
                image="$tmp_buildguide_building.image|~TC($side_number,magenta)"
#                description=_"$tmp_buildguide_unit.name| - costs <span color='#cccc33'>$this_item.build_cost|</span> gold and <span color='#2c9fed'>$this_item.build_movescost_name|%</span> moves to build"
                description=$tmp_buildguide_building.name|
                [command]
                [open_help]
                    topic=unit_$this_item.build_unit
                [/open_help]
                [allow_undo] [/allow_undo]
                {CLEAR_VARIABLE tmp_buildguide_building}
                [/command]
            [/value]
        [/set_variables]
        [/do]
    [/foreach]

#    {CLEAR_VARIABLE buildguide_options[0]}#to fix weirdness with append

    [message]
        x,y=$x1,$y1
        caption=_"Building Guide"
        message=_"Which of this unit's buildings do you want to see the description of?"
        side_for=$side_number
        [insert_tag]
            name=option
            variable=buildguide_options
        [/insert_tag]
    [/message]

    {CLEAR_VARIABLE buildguide_options}
    {CLEAR_VARIABLE tmp_buildguide_unit}

        [/command]
    [/set_menu_item]
[/event]    
#enddef

#define ABILITY_STEPPE_BUILD ID NAME NOTES
    [build]
        id=steppe_build
        name={NAME}
        description=_"This unit can build new units on adjacent tiles via a rightclick menu. This costs gold and a percentage of their moves. After building, the unit gains some exp, with the exp depending on the cost of the building, and the unit's level. You cannot build buildings in deep water, or on unwalkable/impassable terrain

"+{NOTES}
    [/build] # wmlxgettext: [abilities]
[/abilities]
#NOTE: the {ID} parameter is pretty much no longer use it, but am keeping it just in case I need it later
    [event]
#        name=select,recruit,recall
        name=unused
        id=build_select_event
        first_time_only=no
        [filter]
            ability=steppe_build
            side=$side_number
        [/filter]

        [store_unit]
            [filter]
                x,y=$x1,$y1
            [/filter]
            variable=last_selected_unit
        [/store_unit]
    [fire_event]
       name=forcebuildoptions
    [/fire_event]
    [/event]
#moved it into a seperate event from unit place, so it doesn't needlessly trigger
    [event]
        name=side turn,post build #added post build, so the calculation also happens after markets are built too
        id=steppe_calculate_marketvalue
        first_time_only=no

        {IF_VAR tmp_marketcalculate_side greater_than 0 (
        [then]
        [store_side]
            side=$tmp_marketcalculate_side
            variable=steppe_marketside
        [/store_side]
        {CLEAR_VARIABLE tmp_marketcalculate_side}
        [/then]
        [else]
        [store_side]
            side=$side_number
            variable=steppe_marketside
        [/store_side]
        [/else]
        )}

        {VARIABLE steppe_marketplace_cost 1} #adding 1 base gold to account for the unit's hp and survivability, even if the income is nonexistent
        {VARIABLE_OP steppe_marketplace_cost add $steppe_marketside.village_gold}
        {VARIABLE_OP steppe_marketplace_cost multiply 6} #slightly pricier than repairing a village
        {VARIABLE_OP steppe_marketplace_cost add $steppe_marketside.village_support}

    [/event]
[+abilities] # wmlxgettext: [/abilities]
#enddef

#the events can be added seperately to units with building-adding AMLAs

#define BUILDOPTION_EVENT ID DESCRIPTION COST UNIT MOVESCOST
    [event]
        name=unit placed,post advance#added post advance as unit placed doesn't seem to trigger on advancement
        id=build_init_event_{ID}
        first_time_only=no
        [filter]
            ability=steppe_build_option_{ID}
        [/filter]

        {IF_VAR steppe_marketplace_cost greater_than 0 (
        [else]
            {VARIABLE tmp_marketcalculate_side $unit.side}
            [fire_event]
               id=steppe_calculate_marketvalue
            [/fire_event]
        [/else]
        )}

        {BUILD_MENU_ITEM {ID} {DESCRIPTION} {COST} {UNIT} {MOVESCOST}}

    [/event]
#enddef 

#define ABILITY_STEPPE_BUILDOPTION ID DESCRIPTION COST UNIT MOVESCOST
[build_option]
    id=steppe_build_option_{ID}
    build_id={ID}
    build_cost={COST}
    build_unit={UNIT}
    build_movescost={MOVESCOST}
#    build_movescost=0.{MOVESCOST}
#    build_movescost_name={MOVESCOST}
    menu_description={DESCRIPTION}
#    menu_rusdescription={RUSDESCRIPTION}
[/build_option]
[/abilities]
   {BUILDOPTION_EVENT {ID} {DESCRIPTION} {COST} {UNIT} {MOVESCOST}}
[+abilities] # wmlxgettext: [/abilities]
#enddef

#define BUILD_MENU_ITEM ID DESCRIPTION COST UNIT MOVESCOST
#creates the event first, then the menu item that uses it
    {BUILD_EVENT {ID} {COST} {UNIT} {MOVESCOST}}
    [clear_menu_item]
        id=build_{ID} #the menu item is cleared so variable changes can be taken into account
    [/clear_menu_item]
#TODO: remove BUILDER from the define
    [set_menu_item]
        id=build_{ID}
        description={DESCRIPTION}+_ " - price: <span color='#cccc33'>"+{COST}+_"</span> gold and <span color='#2c9fed'>"+{MOVESCOST}+_"</span> moves"
        image="misc/buildicon.png"
        [show_if]
        [/show_if]
#NOTE: setting movescost to 100 doesn't work, as the movecost is after 0. and thus the result will be 0.1
        [filter_location]
            [filter_adjacent_location]
                [filter]
#                    type={BUILDER}
                    ability=steppe_build_option_{ID}
                    side=$side_number
#starting from patch 1.4.4 build movecost is a fixed number
#                    formula=($this_unit.moves >= $this_unit.max_moves * 0.{MOVESCOST})
                    formula=($this_unit.moves >= {MOVESCOST})
                [/filter]
            [/filter_adjacent_location]
            [not]
                [filter]
                [/filter]
                [or]
                    terrain=_off^_usr,Q*,*^X*,X*,Wo*^*#*^V*,W*
                [/or]
            [/not]
        [/filter_location]
        [command]


#TODO: add a better way of choosing which building is built, so it's possible to pass parameters to the AI, and check which units a builder can build

#put x1 and y1 into a variable so they carry over into the build event
        {VARIABLE tmp_build_x $x1}
        {VARIABLE tmp_build_y $y1}
#        [fire_event]
#            name=steppe_customevent_build
#            id=steppe_build_event_{ID}
#            [primary_unit]
#                x,y=$x1,$y1
#            [/primary_unit]
#        [/fire_event]

        {VARIABLE tmp_build_id {ID}}

#the lua code is not strictly necessary, but it does work

        [lua]
            code=<<
--            wesnoth.message("steppe_build_event_"..wml.variables["tmp_build_id"])
            wesnoth.fire_event_by_id("steppe_build_event_"..wml.variables["tmp_build_id"], wml.variables["tmp_build_x"], wml.variables["tmp_build_y"], {})
            >>
        [/lua]
        {CLEAR_VARIABLE tmp_build_id}


        [/command]
    [/set_menu_item]
#enddef

#define BUILD_EVENT ID COST UNIT MOVESCOST
[event]
    name=steppe_customevent_build
    id=steppe_build_event_{ID}
    first_time_only=no
    {VARIABLE x1 $tmp_build_x}
    {VARIABLE y1 $tmp_build_y}
    {CLEAR_VARIABLE tmp_build_x}
    {CLEAR_VARIABLE tmp_build_y}
    {VARIABLE tmp_buildcost {COST}}
#    [chat]
#        message=$x1,$y1
#    [/chat]
            [store_gold]
                variable=actualgold
                side=$side_number
            [/store_gold]
            [if]
            [variable]
                name=actualgold
                greater_than_equal_to={COST}
            [/variable]
            [or]
            #this check is so that free buildings can work even at negative income
            [variable]
                name=tmp_buildcost
                less_than_equal_to=0
            [/variable]  
            [/or]
            [then]
                    [gold]
                        amount=-{COST}
                        side=$side_number
                    [/gold]
                    [store_unit]
                        [filter]
                            ability=steppe_build_option_{ID}
                            side=$side_number
#starting from patch 1.4.4 build movecost is a fixed number
#                            formula=($this_unit.moves >= $this_unit.max_moves * 0.{MOVESCOST})
                            formula=($this_unit.moves >= {MOVESCOST})
                            [filter_location]
                                x,y=$x1,$y1
                                radius=1
                            [/filter_location]
                        [/filter]
                        variable=able_to_build
                        kill=no
                    [/store_unit]

    [if]
    [variable]
        name=able_to_build.length
        greater_than=0
    [/variable]
    [then]

    {VARIABLE builder_random_limit $able_to_build.length}
    {VARIABLE_OP builder_random_limit sub 1}
    {RANDOM 0..$builder_random_limit}

#check if the built unit is a trap, if the unit is a trap, don't play the animation (otherwise it would easily alert the enemy)

    [store_unit_type]
        type={UNIT}
        variable=tmp_buildingtype
    [/store_unit_type]

#    [chat]
#        message=$tmp_buildingtype.abilities.trap.is_trap
#    [/chat]

    [if]
    {VARIABLE_CONDITIONAL tmp_buildingtype.abilities.trap.is_trap equals yes}
    [else]
    [animate_unit]
        flag=build
        [filter]
            id=$able_to_build[$random].id
        [/filter]
        [facing]
            x,y=$x1,$y1
        [/facing]
        hits=yes
    [/animate_unit]
    [/else]
    [/if]
    {CLEAR_VARIABLE tmp_buildingtype}


#since the array number is offset by one from the length (if there are 2 units, the length is 2, but the units are [0] and [1])

#the exp is calculated based on cost and level
    {VARIABLE tmp_builder_exp {COST}}
    {VARIABLE_OP tmp_builder_exp multiply 0.33}
    {VARIABLE_OP tmp_builder_exp add 1}
    {VARIABLE_OP tmp_builder_exp multiply $able_to_build[$random].level}
    {VARIABLE_OP tmp_builder_exp round ceil}
    {VARIABLE_OP able_to_build[$random].experience add $tmp_builder_exp}
#starting from patch 1.4.4 build movecost is a fixed number
#    {VARIABLE buildmoves $able_to_build[$random].max_moves}
#    {VARIABLE_OP buildmoves multiply 0.{MOVESCOST}}
    {VARIABLE buildmoves {MOVESCOST}}
    {VARIABLE_OP able_to_build[$random].moves sub $buildmoves}

    [unstore_unit]
        variable=able_to_build[$random]
        text="+$tmp_builder_exp| exp"
#        red=0
#        green=0
#        blue=255
        find_vacant=no
    [/unstore_unit]
    [fire_event]
        name=post build
        [primary_unit]
            x,y=$x1,$y1
        [/primary_unit]
        [secondary_unit]
            id=$able_to_build[$random].id
        [/secondary_unit]
    [/fire_event]
    [/then]
    [/if]

    [unit]
        type={UNIT}
        side=$side_number
        x,y=$x1,$y1
        moves=0
        animate=yes
    [/unit]
#    [chat]
#        message=$able_to_build[$random].abilities.building_boost_damage.bonus
#    [/chat]
    [if]
    [have_unit]
        id=$able_to_build[$random].id
        ability=steppe_building_damage_boost
    [/have_unit]
    [then]
        [object]
            silent=yes
            duration=forever
            [filter]
                x,y=$x1,$y1
            [/filter]
            [effect]
                apply_to=attack
                increase_damage=$able_to_build[$random].abilities.building_boost_damage.bonus|%
            [/effect]
        [/object]
    [/then]
    [/if]

    [if]
    [have_unit]
        id=$able_to_build[$random].id
        ability=steppe_building_hitpoint_boost
    [/have_unit]
    [then]
        [object]
            silent=yes
            duration=forever
            [filter]
                x,y=$x1,$y1
            [/filter]
            [effect]
                apply_to=hitpoints
                increase=$able_to_build[$random].abilities.building_boost_hitpoint.bonus|%
                increase_total=$able_to_build[$random].abilities.building_boost_hitpoint.bonus|%
            [/effect]
        [/object]
    [/then]
    [/if]

    [fire_event]
        name=recruit
        [primary_unit]
            x,y=$x1,$y1
        [/primary_unit]
    [/fire_event]

    [redraw]
           clear_shroud=yes
    [/redraw]
    [store_unit]
        [filter]
            x,y=$x1,$y1
        [/filter]
        variable=tmp_building
        kill=no
    [/store_unit]
    {VARIABLE tmp_building.attacks_left 0}
    {VARIABLE tmp_building.moves 0}
    {VARIABLE tmp_building.cost {COST}} #this is to make the demolish refund more accurate
    [unstore_unit]
        variable=tmp_building
        find_vacant=no
    [/unstore_unit]

    {CLEAR_VARIABLE builder_random_limit}
    {CLEAR_VARIABLE tmp_builder_exp}
    {CLEAR_VARIABLE buildmoves}

                [/then]
                [else]
                    [store_unit]
                        [filter]
                            ability=steppe_build_option_{ID}
                            side=$side_number
#starting from patch 1.4.4 build movecost is a fixed number
#                            formula=($this_unit.moves >= $this_unit.max_moves * 0.{MOVESCOST})
                            formula=($this_unit.moves >= {MOVESCOST})
                            [filter_location]
                                x,y=$x1,$y1
                                radius=1
                            [/filter_location]
                        [/filter]
                        variable=able_to_build
                        kill=no
                    [/store_unit]
                    [message]
                        speaker=$able_to_build.id
                        side_for=$side_number
                        message=_"Not enough gold for this building!"
                    [/message]
                [/else]
            [/if]
            {CLEAR_VARIABLE actualgold}
            {CLEAR_VARIABLE able_to_build}
            {CLEAR_VARIABLE tmp_buildcost}
[/event]
#enddef

#define ABILITY_STEPPE_WALL TERRAIN
    [dummy]
        id=steppe_wall{TERRAIN}
        name=_"wall"
        description= _"This unit places castle terrain at its location when created. However, it turns into the original tile the wall was built on."
    [/dummy]
    [dummy]
        id=walldummy #just in case I need to filter walls
    [/dummy]
    [/abilities]
    [event]
    name=die
    id=steppe_wall_event2{TERRAIN}
    first_time_only=no
    [filter]
        ability=steppe_wall{TERRAIN}
    [/filter]
#    [chat]
#        message=$unit.variables.orig_terrain
#    [/chat]
    #repeating the code from the unit placed event in case a village is spawned on top of a wall via repair
        [if]
        [have_location]
            terrain=*^V*
            x,y=$x1,$y1
        [/have_location]
        [then]
        {VARIABLE unit.variables.orig_layer base}
        [/then]
        [else]
        {VARIABLE unit.variables.orig_layer both}
        [/else]
        [/if]

[terrain]
terrain=$unit.variables.orig_terrain
x,y=$x1,$y1
layer=$unit.variables.orig_layer
[/terrain]
    [/event]
    [event]
    name=unit placed,post advance
    id=steppe_wall_event3{TERRAIN}
    first_time_only=no
    [filter]
        ability=steppe_wall{TERRAIN}
    [/filter]
    [filter_condition]
    {VARIABLE_CONDITIONAL tmp_steppe_antiloop not_equals yes}
    [/filter_condition]
    [store_locations]
        x,y=$x1,$y1
        variable=tmp_steppe_wall_location
    [/store_locations]
    {VARIABLE tmp_steppe_antiloop yes}
    [if]
    [have_location]
        terrain={TERRAIN}^*
        x,y=$x1,$y1
    [/have_location]
    [else]
        [if]
        {VARIABLE_CONDITIONAL unit.variables.orig_terrain not_equals $steppe_emptyvar}
        [else]
        {VARIABLE unit.variables.orig_terrain $tmp_steppe_wall_location.terrain}
        [/else]
        [/if]
        [if]
        [have_location]
            terrain=*^V*
            x,y=$x1,$y1
        [/have_location]
        [then]
        {VARIABLE unit.variables.orig_layer base}
        [/then]
        [else]
        {VARIABLE unit.variables.orig_layer both}
        [/else]
        [/if]
        [unstore_unit]
            variable=unit
            find_vacant=no
        [/unstore_unit]    
        [terrain]
        terrain={TERRAIN}
        x,y=$x1,$y1
        layer=$unit.variables.orig_layer
        [/terrain]
    [/else]
    [/if]
    {CLEAR_VARIABLE tmp_steppe_wall_location}
    {CLEAR_VARIABLE tmp_steppe_antiloop}
    {CLEAR_VARIABLE tmp_steppe_wall}
    [/event]
#this is to make walls work properly with scenarios that change terrain sometimes (like dark forecast)
    [event]
    name=turn refresh
    id=steppe_wall_event_turn_refresh{TERRAIN}
    first_time_only=no

    [store_unit]
        [filter]
            ability=steppe_wall{TERRAIN}
            [not]
                [filter_location]
                    terrain={TERRAIN}^*
                [/filter_location]
            [/not]
        [/filter]
        variable=walls_on_wrong_terrain
        kill=no
    [/store_unit]
    [foreach]
        array=walls_on_wrong_terrain
        index_var=i
        [do]

    [store_locations]
        x,y=$this_item.x,$this_item.y
        variable=tmp_steppe_wall_location
    [/store_locations]
    [if]
    [have_location]
        terrain={TERRAIN}^*
        x,y=$this_item.x,$this_item.y
    [/have_location]
    [else]

#        [if]
#        {VARIABLE_CONDITIONAL this_item.variables.orig_terrain not_equals $steppe_emptyvar}
#        [else]
#        {VARIABLE this_item.variables.orig_terrain $tmp_steppe_wall_location.terrain}
#        [/else]
#        [/if]

#resets orig terrain to match the updated base terrain:
        {VARIABLE this_item.variables.orig_terrain $tmp_steppe_wall_location.terrain}

        [if]
        [have_location]
            terrain=*^V*
            x,y=$this_item.x,$this_item.y
        [/have_location]
        [then]
        {VARIABLE this_item.variables.orig_layer base}
        [/then]
        [else]
        {VARIABLE this_item.variables.orig_layer both}
        [/else]
        [/if]
        [unstore_unit]
            variable=this_item
            find_vacant=no
        [/unstore_unit]    
    [/else]
    [/if]
[terrain]
terrain={TERRAIN}
x,y=$this_item.x,$this_item.y
layer=$this_item.variables.orig_layer
[/terrain]
    {CLEAR_VARIABLE tmp_steppe_wall_location}
    {CLEAR_VARIABLE tmp_steppe_wall}            
        [/do]
    [/foreach]
    {CLEAR_VARIABLE walls_on_wrong_terrain}            

    [/event]    
[+abilities]
#enddef

#define ABILITY_STEPPE_BUILDING
#dummy ability to make buildings removed from the recall list automatically
    [dummy]
        id=steppe_building
    [/dummy]
    [/abilities]
    [event]
    name=start
    id=steppe_clear_buildings
    [kill]
       x,y=recall,recall
       ability=steppe_building
       fire_event=no
       animate=no
    [/kill]
    [/event]
[+abilities]
#enddef

#define ABILITY_STEPPE_REPAIR_VILLAGE
    [dummy]
        id=steppe_repair_village
        name=_"repair village"
        description=_"This unit can repair villages via a rightclick menu when standing in a 1-tile radius from a village destroyed by the 'pillage' ability. The cost of repairing a village depends on the income of a single village."
    [/dummy] # wmlxgettext: [abilities]
[/abilities]
#    [event]
#        name=side turn
#        id=steppe_calculate_village_repair
#        first_time_only=no
##        {VARIABLE unit.upkeep -$steppe_marketside.village_support}
#    [/event]

    [event]
        name=steppe_customevent_repairvillage
        id=steppe_repairvillage_event
        first_time_only=no

        {VARIABLE x1 $tmp_repair_x}
        {VARIABLE y1 $tmp_repair_y}
        {CLEAR_VARIABLE tmp_repair_x}
        {CLEAR_VARIABLE tmp_repair_y}


            [store_gold]
                variable=actualgold
                side=$side_number
            [/store_gold]
            [if]
            {VARIABLE_CONDITIONAL actualgold greater_than_equal_to $steppe_village_repaircost}
            [then]
                [gold]
                    amount=-$steppe_village_repaircost
                    side=$side_number
                [/gold]
                [sound]
                  name=gold.ogg
                [/sound]
    [store_unit]
        [filter]
            ability=steppe_repair_village
            side=$side_number
            formula=($this_unit.moves >= $this_unit.max_moves * 0.66)
            [filter_location]
                x,y=$x1,$y1
                radius=1
            [/filter_location]
        [/filter]
        variable=able_to_repair
    [/store_unit]
    [if]
    [variable]
        name=able_to_repair.length
        greater_than=0
    [/variable]
    [then]

    {VARIABLE builder_random_limit $able_to_repair.length}
    {VARIABLE_OP builder_random_limit sub 1}
    {RANDOM 0..$builder_random_limit}

    [if]
    [have_unit]
        id=$able_to_repair[$random].id
        x,y=$x1,$y1
    [/have_unit]
    [then]
    [animate_unit]
        flag=build_long
        [filter]
            id=$able_to_repair[$random].id
        [/filter]
#        [facing]
#            x,y=$x1,$y1
#        [/facing]
    [/animate_unit]
    [/then]
    [else]
    [animate_unit]
        flag=build_long
        [filter]
            id=$able_to_repair[$random].id
        [/filter]
        [facing]
            x,y=$x1,$y1
        [/facing]
        hits=yes
    [/animate_unit]
    [/else]
    [/if]


#since the array number is offset by one from the length (if there are 2 units, the length is 2, but the units are [0] and [1])

#the exp is calculated based on cost and level
    {VARIABLE tmp_builder_exp $steppe_village_repaircost}
    {VARIABLE_OP tmp_builder_exp multiply 0.33}
    {VARIABLE_OP tmp_builder_exp add 1}
    {VARIABLE_OP tmp_builder_exp multiply $able_to_repair[$random].level}
    {VARIABLE_OP tmp_builder_exp round ceil}
    {VARIABLE_OP able_to_repair[$random].experience add $tmp_builder_exp}
    {VARIABLE buildmoves $able_to_repair[$random].max_moves}
    {VARIABLE_OP buildmoves multiply 0.66}
    {VARIABLE_OP able_to_repair[$random].moves sub $buildmoves}

    [unstore_unit]
        variable=able_to_repair[$random]
        text=_"+$tmp_builder_exp| exp"
#        red=0
#        green=0
#        blue=255
        find_vacant=no
    [/unstore_unit]
    [/then]
    [/if]

    {GSE_DEPRECATED_MACRO_FOREACH destroyed_village_information i}
        [if]
            {VARIABLE_CONDITIONAL destroyed_village_information[$i].x equals $x1}
            [and]
            {VARIABLE_CONDITIONAL destroyed_village_information[$i].y equals $y1}
            [/and]
            [then]
#                [chat]
#                    message=_"repair event succeeded x: $destroyed_village_information[$i].x, y: $destroyed_village_information[$i].y"
#                [/chat]

                [remove_item]
                    x=$destroyed_village_information[$i].x
                    y=$destroyed_village_information[$i].y
                    image=steppe_rubble
                [/remove_item]
                [remove_sound_source]
                    id=steppe_flames_$destroyed_village_information[$i].x|_$destroyed_village_information[$i].y|
                [/remove_sound_source]


                {GSE_DEPRECATED_MACRO_FOREACH burning_tile_information a}
                    [if]
                        {VARIABLE_CONDITIONAL burning_tile_information[$a].x equals $x1}
                        [and]
                        {VARIABLE_CONDITIONAL burning_tile_information[$a].y equals $y1}
                        [/and]

                        [then]
                            [remove_item]
                                x=$burning_tile_information[$a].x
                                y=$burning_tile_information[$a].y
                                image=steppe_flames
                            [/remove_item]
                            [remove_item]
                                x=$burning_tile_information[$a].x
                                y=$burning_tile_information[$a].y
                                image=steppe_burnedvillage
                            [/remove_item]
 
                            [clear_variable]
                                name=burning_tile_information[$a]
                            [/clear_variable]
                        [/then]
                    [/if]
                {GSE_DEPRECATED_MACRO_NEXT a}

                [terrain]
                terrain=$destroyed_village_information[$i].terrain
                x,y=$x1,$y1
                layer=overlay
                [/terrain]
                [capture_village]
                x,y=$x1,$y1
                side=$side_number
                [/capture_village]
#                {VARIABLE tmp_village_fixed yes}


                [scroll_to]
                    x,y=$x1,$y1
                    check_fogged=yes
                [/scroll_to]

                [floating_text]
                   x,y=$x1,$y1
                   text=_"<span color='#00ff00'>village repaired</span>"
                [/floating_text]
 
                [clear_variable]
                    name=destroyed_village_information[$i]
                [/clear_variable]
            [/then]
        [/if]
    {GSE_DEPRECATED_MACRO_NEXT i}
            [store_unit]
                variable=able_to_repair
                [filter]
                    ability=steppe_repair_village
                    side=$side_number
                    [filter_wml]
                        moves=$this_unit.max_moves
                    [/filter_wml]
                    [filter_adjacent_location]
                        x,y=$x1,$y1
                    [/filter_adjacent_location]
                [/filter]
            [/store_unit]    
        [/then]
        [else]
            [store_unit]
                variable=able_to_repair
                [filter]
                    ability=steppe_repair_village
                    side=$side_number
                    [filter_wml]
                        moves=$this_unit.max_moves
                    [/filter_wml]
                    [filter_adjacent_location]
                        x,y=$x1,$y1
                    [/filter_adjacent_location]
                [/filter]
            [/store_unit]
            [message]
                speaker=$able_to_repair.id
                side_for=$side_number
                message=_"Not enough gold for the repair!"
            [/message]
        [/else]
    [/if]
    {CLEAR_VARIABLE actualgold}
    {CLEAR_VARIABLE tmp_village_fixed}
    {CLEAR_VARIABLE able_to_repair}

    [/event]


    [event]
        name=unit placed,post advance
        id=steppe_repairvillage_menu_event
        first_time_only=no
        [filter]
            ability=steppe_repair_village
        [/filter]
        [store_side]
            side=$unit.side
            variable=steppe_villageside
        [/store_side]
        {VARIABLE steppe_village_repaircost 1} #adding 1 base gold to account for the defense and healing, even if the income is nonexistent
        {VARIABLE_OP steppe_village_repaircost add $steppe_villageside.village_gold}
        {VARIABLE_OP steppe_village_repaircost multiply 3}
        {VARIABLE_OP steppe_village_repaircost add $steppe_villageside.village_support}

#clear the menu item to refresh the variable in the event name
    [clear_menu_item]
        id=steppe_repair_village
    [/clear_menu_item]

    [set_menu_item]
        id=steppe_repair_village
        description=_"Repair this village - costs <span color='#cccc33'>$steppe_village_repaircost|</span> gold and <span color='#2c9fed'>66%</span> moves"
        image="misc/villageicon.png"
        [show_if]
#unused code            
##TODO: add a lua-based check in [show_if]
#        [lua]
#        code=<<
#        local location_matches = false
#
#        local destroyed_village_information = wml.variables["destroyed_village_information"]
#
#             if destroyed_village_information then
#                wesnoth.message("destroyed village found")
#     
#            for i,village in ipairs(destroyed_village_information) do
#                wesnoth.message("destroyed village check triggered")
#                wesnoth.message(village[i].x,village[i].y)
#
#                if village[i].x == wml.variables[x1] and village[i].y == wml.variables[y1] then
#                 location_matches = true
#                end
#            end
#
#       end
#
#
#return (location_matches == true)
#
#
#        >>
#        [/lua]
        [/show_if]

        [filter_location]
            find_in=destroyed_village_information
            [and]
                [filter]
                    side=$side_number
                    ability=steppe_repair_village
                    formula=($this_unit.moves >= $this_unit.max_moves * 0.66)
                [/filter]
                radius=1
            [/and]
        [/filter_location]
        [command]

        {VARIABLE tmp_repair_x $x1}
        {VARIABLE tmp_repair_y $y1}
        [fire_event]
            name=steppe_customevent_repairvillage
        [/fire_event]

        [/command]
    [/set_menu_item]
    [/event]
[+abilities] # wmlxgettext: [/abilities]
#enddef

#define ABILITY_STEPPE_BUILDING_BONUS_DAMAGE PERCENTAGE
    [building_boost_damage]
        id=steppe_building_damage_boost
        name=_"building damage boost"+" {PERCENTAGE}%"
        description= _"Buildings build by this unit have "+{PERCENTAGE}+_"% more damage"
        bonus={PERCENTAGE}
    [/building_boost_damage]
#enddef

#define ABILITY_STEPPE_BUILDING_BONUS_HITPOINTS PERCENTAGE
    [building_boost_hitpoint]
        id=steppe_building_hitpoint_boost
        name=_"building hitpoint boost"+" {PERCENTAGE}%"
        description= _"Buildings build by this unit have "+{PERCENTAGE}+_"% more HP"
        bonus={PERCENTAGE}
    [/building_boost_hitpoint]
#enddef

#define ABILITY_STEPPE_ENLIST TYPE DESCRIPTION RUSDESCRIPTION
    [enlist]
        id=steppe_enlist{TYPE}
        name=_"enlist units"
        description=_"This unit can enlist new units on adjacent tiles via a rightclick menu. This costs gold equal to recruiting the unit. You cannot enlist units in deep water, or on unwalkable/impassable terrain"
        type={TYPE}
    [/enlist] # wmlxgettext: [abilities]
[/abilities]

[event]
    name=unit placed,post advance#added post advance as unit placed doesn't seem to trigger on advancement
    id=enlist_init_event_{TYPE}
    first_time_only=no
    [filter]
        ability=steppe_enlist{TYPE}
    [/filter]

    {ENLIST_MENU_ITEM {TYPE} {DESCRIPTION} {RUSDESCRIPTION}}
[/event]

{ENLIST_EVENT {TYPE}}

[+abilities] # wmlxgettext: [/abilities]
#enddef

#define ENLIST_MENU_ITEM TYPE DESCRIPTION
#creates the event first, then the menu item that uses it
    {ENLIST_EVENT {TYPE}}
    [clear_menu_item]
        id=enlist_{TYPE} #the menu item is cleared so variable changes can be taken into account
    [/clear_menu_item]

    [store_unit_type]
        type={TYPE}
        variable=tmp_enlist_type
    [/store_unit_type]

    [set_menu_item]
        id=enlist_{TYPE}
        description={DESCRIPTION}+" - "+ _ "price:<span color='#cccc33'>"+" "+$tmp_enlist_type.cost|+"</span> gold"
        image="misc/coinsicon.png"
        [show_if]
        [/show_if]
        [filter_location]
            [filter_adjacent_location]
                [filter]
                    ability=steppe_enlist{TYPE}
                    side=$side_number
                [/filter]
            [/filter_adjacent_location]
            [not]
                [filter]
                [/filter]
                [or]
                    terrain=_off^_usr,Q*,*^X*,X*,Wo*^*#*^V*,W*
                [/or]
            [/not]
        [/filter_location]
        [command]
#put x1 and y1 into a variable so they carry over into the enlist event
        {VARIABLE tmp_enlist_x $x1}
        {VARIABLE tmp_enlist_y $y1}
#        [fire_event]
#            name=steppe_customevent_enlist
#            id=steppe_enlist_event_{ID}
#            [primary_unit]
#                x,y=$x1,$y1
#            [/primary_unit]
#        [/fire_event]

        {VARIABLE tmp_enlist_type {TYPE}}

#the lua code is not strictly necessary, but it does work

        [lua]
            code=<<
--            wesnoth.message("steppe_enlist_event_"..wml.variables["tmp_enlist_id"])
            wesnoth.fire_event_by_id("steppe_enlist_event_"..wml.variables["tmp_enlist_type"], wml.variables["tmp_enlist_x"], wml.variables["tmp_enlist_y"], {})
            >>
        [/lua]
        {CLEAR_VARIABLE tmp_enlist_type}


        [/command]
    [/set_menu_item]
#enddef

#define ENLIST_EVENT TYPE
[event]
    name=steppe_customevent_enlist
    id=steppe_enlist_event_{TYPE}
    first_time_only=no
    {VARIABLE x1 $tmp_enlist_x}
    {VARIABLE y1 $tmp_enlist_y}
    {CLEAR_VARIABLE tmp_enlist_x}
    {CLEAR_VARIABLE tmp_enlist_y}

    [store_unit_type]
        type={TYPE}
        variable=tmp_enlist_type
    [/store_unit_type]

    {VARIABLE tmp_enlistcost $tmp_enlist_type.cost}

            [store_gold]
                variable=actualgold
                side=$side_number
            [/store_gold]
            [if]
            [variable]
                name=actualgold
                greater_than_equal_to=$tmp_enlistcost
            [/variable]
            [or]
            #this check is so that free enlistings can work even at negative income
            [variable]
                name=tmp_enlistcost
                less_than_equal_to=0
            [/variable]  
            [/or]
            [then]
                    [gold]
                        amount=-$tmp_enlistcost
                        side=$side_number
                    [/gold]

    [unit]
        type={TYPE}
        side=$side_number
        x,y=$x1,$y1
        moves=0
        animate=yes
    [/unit]

    [fire_event]
        name=recruit
        [primary_unit]
            x,y=$x1,$y1
        [/primary_unit]
    [/fire_event]

    [redraw]
           clear_shroud=yes
    [/redraw]
    [store_unit]
        [filter]
            x,y=$x1,$y1
        [/filter]
        variable=tmp_enlisting
        kill=no
    [/store_unit]
    {VARIABLE tmp_enlisting.attacks_left 0}
    {VARIABLE tmp_enlisting.moves 0}
    [unstore_unit]
        variable=tmp_enlisting
        find_vacant=no
    [/unstore_unit]

                [/then]
                [else]
                    [message]
                        speaker=narrator
                        side_for=$side_number
                        message=_"Not enough gold to enlisting!"
                    [/message]
                [/else]
            [/if]
            {CLEAR_VARIABLE actualgold}
            {CLEAR_VARIABLE able_to_enlist}
            {CLEAR_VARIABLE tmp_enlistcost}
[/event]
#enddef

#define ABILITY_STEPPE_UPGRADEABLE COST
    [upgradeable]
        id=steppe_upgradeable
        cost={COST}
    [/upgradeable]
#enddef

#define ABILITY_STEPPE_UPGRADE_BUILDINGS MAX_LEVEL MOVESCOST
    [upgrade_buildings]
        id=steppe_upgrade_buildings
        name=_"upgrade buildings"+" {MAX_LEVEL}"
        description=_"This unit can upgrade buildings on adjacent tiles via a rightclick menu. Can only upgrade units to level "+{MAX_LEVEL}+_", and only works on buildings who can advance."
        movescost=0.{MOVESCOST}
        movescost_percentage={MOVESCOST}
        max_level={MAX_LEVEL}
    [/upgrade_buildings] # wmlxgettext: [abilities]
[/abilities]

[event]
    name=unit placed,post advance#added post advance as unit placed doesn't seem to trigger on advancement
    id=upgrade_building_init_event
    first_time_only=no
    [filter]
        ability=steppe_upgrade_buildings
    [/filter]

#    [clear_menu_item]
#        id=steppe_upgrade_buildings
#    [/clear_menu_item]

    [set_menu_item]
        id=steppe_upgrade_buildings
        description=_"Upgrade Building (costs gold and moves)"
        image="misc/buildicon.png"
        [show_if]
        [/show_if]
        [filter_location]
            [filter_adjacent_location]
                [filter]
                    ability=steppe_upgrade_buildings
                    side=$side_number
                    formula=($this_unit.moves >= $this_unit.max_moves * $this_unit.abilities.upgrade_buildings.movescost)
                [/filter]
            [/filter_adjacent_location]
            [filter]
                ability=steppe_upgradeable
            [/filter]
        [/filter_location]
        [command]

        [store_unit]
            [filter]
                x,y=$x1,$y1
            [/filter]
            variable=tmp_upgraded_building
            kill=no
        [/store_unit]

        [if]
        [have_unit]
            ability=steppe_upgrade_buildings
            side=$side_number
            formula=($this_unit.abilities.upgrade_buildings.max_level > $tmp_upgraded_building.level)
            [and]
                formula=($this_unit.moves >= $this_unit.max_moves * $this_unit.abilities.upgrade_buildings.movescost)
            [/and]
            [filter_location]
                x,y=$x1,$y1
                radius=1
            [/filter_location]
        [/have_unit]
        [then]

        {VARIABLE tmp_steppe_upgradecost $tmp_upgraded_building.abilities.upgradeable.cost}

            [store_gold]
                variable=actualgold
                side=$side_number
            [/store_gold]
            [if]
            [variable]
                name=actualgold
                greater_than_equal_to=$tmp_steppe_upgradecost
            [/variable]
            [or]
            #this check is so that free upgrades can work even at negative income
            [variable]
                name=tmp_steppe_upgradecost
                less_than_equal_to=0
            [/variable]  
            [/or]
            [then]

                    [store_unit]
                        [filter]
                            ability=steppe_upgrade_buildings
                            side=$side_number
                            formula=($this_unit.abilities.upgrade_buildings.max_level > $tmp_upgraded_building.level)
                            [and]
                                formula=($this_unit.moves >= $this_unit.max_moves * $this_unit.abilities.upgrade_buildings.movescost)
                            [/and]
                            [filter_location]
                                x,y=$x1,$y1
                                radius=1
                            [/filter_location]
                        [/filter]
                        variable=able_to_upgrade
                        kill=no
                    [/store_unit]

    {VARIABLE builder_random_limit $able_to_upgrade.length}
    {VARIABLE_OP builder_random_limit sub 1}
    {RANDOM 0..$builder_random_limit}

    [store_unit_type]
        type=$tmp_upgraded_building.advances_to
        variable=tmp_building_upgrade
    [/store_unit_type]

    [message]
        speaker=$able_to_upgrade[$random].id
        side_for=$side_number
        message=_"Do you want to upgrade this building for <span color='#cccc33'>$tmp_steppe_upgradecost|</span> gold and <span color='#2c9fed'>$able_to_upgrade[$random].abilities.upgrade_buildings.movescost_percentage|%</span> moves?"
        [option]
            image=$tmp_building_upgrade.image
            description=_"Yes"
            [command]

            [sound]
                name=gold.ogg
            [/sound]

            [gold]
                amount=-$tmp_steppe_upgradecost
                side=$side_number
            [/gold]


    [animate_unit]
        flag=build_long
        [filter]
            id=$able_to_upgrade[$random].id
        [/filter]
        [facing]
            x,y=$x1,$y1
        [/facing]
        hits=yes
    [/animate_unit]


    {ADVANCE_UNIT x,y=$x1,$y1 ()}
    {MODIFY_UNIT x,y=$x1,$y1 attacks_left 0}
    {MODIFY_UNIT x,y=$x1,$y1 moves 0}
    {MODIFY_UNIT x,y=$x1,$y1 experience $tmp_upgraded_building.experience}#the unit keeps any pre-upgrade experience


#since the array number is offset by one from the length (if there are 2 units, the length is 2, but the units are [0] and [1])

#the exp is calculated based on cost and level
    {VARIABLE tmp_builder_exp $tmp_steppe_upgradecost}
    {VARIABLE_OP tmp_builder_exp multiply 0.33}
    {VARIABLE_OP tmp_builder_exp add 1}
    {VARIABLE_OP tmp_builder_exp multiply $able_to_upgrade[$random].level}
    {VARIABLE_OP tmp_builder_exp round ceil}
    {VARIABLE_OP able_to_upgrade[$random].experience add $tmp_builder_exp}
    {VARIABLE buildmoves $able_to_upgrade[$random].max_moves}
    {VARIABLE_OP buildmoves multiply 0.{MOVESCOST}}
    {VARIABLE_OP able_to_upgrade[$random].moves sub $buildmoves}

    [unstore_unit]
        variable=able_to_upgrade[$random]
        text=_"+$tmp_builder_exp| exp"
#        red=0
#        green=0
#        blue=255
        find_vacant=no
    [/unstore_unit]
    [fire_event]
        name=post upgrade
        [primary_unit]
            x,y=$x1,$y1
        [/primary_unit]
        [secondary_unit]
            id=$able_to_upgrade[$random].id
        [/secondary_unit]
    [/fire_event]

    [redraw]
           clear_shroud=yes
    [/redraw]

    {CLEAR_VARIABLE builder_random_limit}
    {CLEAR_VARIABLE tmp_builder_exp}
    {CLEAR_VARIABLE buildmoves}
    [/command]
    [/option]
        [option]
            image=_"attacks/blank-attack.png"
            description=_"No"
            [command]
            [/command]
        [/option]
    [/message]


                [/then]
                [else]
                    [store_unit]
                        [filter]
                            ability=steppe_upgrade_buildings
                            side=$side_number
                            formula=($this_unit.abilities.upgrade_buildings.max_level > $tmp_upgraded_building.level)
                            [and]
                                formula=($this_unit.moves >= $this_unit.max_moves * $this_unit.abilities.upgrade_buildings.movescost)
                            [/and]
                            [filter_location]
                                x,y=$x1,$y1
                                radius=1
                            [/filter_location]
                        [/filter]
                        variable=able_to_upgrade
                        kill=no
                    [/store_unit]
                    [message]
                        speaker=$able_to_upgrade.id
                        side_for=$side_number
                        message=_"Not enough gold for this building!"
                    [/message]
                [/else]
            [/if]

        [/then]
        [else]
        #dialog if the unit doesn't have a good enough ability to upgrade
                    [store_unit]
                        [filter]
                            ability=steppe_upgrade_buildings
                            side=$side_number
                            formula=($this_unit.abilities.upgrade_buildings.max_level <= $tmp_upgraded_building.level)
                            [and]
                                formula=($this_unit.moves >= $this_unit.max_moves * $this_unit.abilities.upgrade_buildings.movescost)
                            [/and]
                            [filter_location]
                                x,y=$x1,$y1
                                radius=1
                            [/filter_location]
                        [/filter]
                        variable=able_to_upgrade
                        kill=no
                    [/store_unit]
                    [message]
                        speaker=$able_to_upgrade.id
                        side_for=$side_number
                        message=_"I'm not skilled enough to upgrade this building!"
                    [/message]
        [/else]
        [/if]

        {CLEAR_VARIABLE tmp_steppe_upgradecost}
        {CLEAR_VARIABLE tmp_upgraded_building}
        {CLEAR_VARIABLE tmp_building_upgrade}

        [/command]
    [/set_menu_item]
[/event]


[+abilities] # wmlxgettext: [/abilities]
#enddef

#dummy ability to make the AI not prioritize such units:
#define ABILITY_STEPPE_UNIMPORTANT_TARGET
    [dummy]
        id=steppe_unimportant_target
    [/dummy]
#enddef
