#textdomain wesnoth-gse

#define ABILITY_HUNNFACTION
    [dummy]
        id=hunnfaction
    [/dummy]
#enddef

#define ABILITY_STEPPE_WOLF
#dummy used for the wolf pack ability
    [dummy]
        id=steppe_wolf
    [/dummy]
#enddef

#define ABILITY_STEPPE_SCYTHIAN
#dummy used for the mound tsar ability
    [dummy]
        id=steppe_hunn_scythian
    [/dummy]
#enddef

#define ABILITY_STEPPE_WOLF_PACK
#ability for Hunn wolves, translate later
    [skirmisher]
        id=steppe_wolfpack
        name=_"wolf pack"
        description=_"This unit negates enemy Zones of Control around itself for allied wolf units (but not for itself)."
        affect_self=no
        affect_allies=yes
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
            [filter]
                race=wolf
                [or]
                    ability=steppe_wolf
                [/or]
            [/filter]
        [/affect_adjacent]
    [/skirmisher]
#enddef

#unused ability:

#define WEAPON_SPECIAL_STEPPE_CONSUME_FEAR
    # Canned definition of the Drain ability to be included in a
    # [specials] clause.
    [dummy]
        id=steppe_consume_fear
#the wolf OOS issue is due to the description being part of the checksum
        name=_"consume fear"
        description=_"If there is a an enemy of the target behind the target (like with backstab), this unit heals itself for half the amount of damage it deals (rounded down) on hit, and if used offensively, the target deals 20% less damage when counterattacking. Only works on living units."
    [/dummy]
    #moved description to [dummy] as an attempt to fix OOS
    [drains]
        id=steppe_consume_fear2
        active_on=offense
        [filter_opponent]
            formula="
                enemy_of(self, flanker) and not flanker.petrified
            where
                flanker = unit_at(direction_from(loc, other.facing))    
            "
        [/filter_opponent]
    [/drains]
    [damage]
        id=steppe_consume_fear3
        multiply=0.8
        apply_to=opponent
        active_on=offense
        [filter_opponent]
            formula="
                enemy_of(self, flanker) and not flanker.petrified
            where
                flanker = unit_at(direction_from(loc, other.facing))
            "
            [not]
            [filter_wml]
                [status]
                    not_living="yes"
                [/status]
            [/filter_wml]
            [/not]
        [/filter_opponent]
    [/damage]
#enddef

#define WEAPON_SPECIAL_STEPPE_UNHINDERED
[damage]
    id=steppe_unhindered
    name=_"unhindered"
    description=_"This attack always has at least a 50% chance to hit, and its damage is unaffected by the `slowed` status."
    apply_to=self
    multiply=2
    [filter_self]
        [filter_wml]
            [status]
                slowed="yes"
            [/status]
        [/filter_wml]
    [/filter_self]
[/damage]
[chance_to_hit]
    id=steppe_unhindered2
    value=50
    cumulative=yes
[/chance_to_hit]
#enddef


#define STEPPE_CONTAINER_EVENTS VARIABLENUMBER UNITVAR FILTERS
[event]
    name=attack
    id=steppe_container_of_darkness_event{VARIABLENUMBER}1
    first_time_only=no

    {FILTERS}

#the number at the end is to differentiate the variables when there are two units with this ability fighting eachother
    {VARIABLE steppe_container_orighp{VARIABLENUMBER} ${UNITVAR}.hitpoints}
[/event]

[event]
    name=attack end
    id=steppe_container_of_darkness_event{VARIABLENUMBER}2
    first_time_only=no

    {FILTERS}

    {VARIABLE steppe_container_newhp{VARIABLENUMBER} ${UNITVAR}.hitpoints}

    {VARIABLE steppe_container_currentheal{VARIABLENUMBER} $steppe_container_orighp{VARIABLENUMBER} }
    {VARIABLE_OP steppe_container_currentheal{VARIABLENUMBER} sub $steppe_container_newhp{VARIABLENUMBER} }
    {VARIABLE_OP steppe_container_currentheal{VARIABLENUMBER} multiply 0.4} #multiplies the healing by a percentage
#    {VARIABLE_OP steppe_container_currentheal{VARIABLENUMBER} round ceil}
    {VARIABLE_OP steppe_container_currentheal{VARIABLENUMBER} round floor}

#    [chat]
#       speaker=_"Debug"
#       message= _ "orig hp: $steppe_container_orighp{VARIABLENUMBER}| new hp: $steppe_container_newhp{VARIABLENUMBER}| current heal: $steppe_container_currentheal{VARIABLENUMBER}|"
#    [/chat]

    [heal_unit]
        [filter]
        [filter_side]
        [allied_with]
            side=${UNITVAR}.side
        [/allied_with]
        [/filter_side]
        [filter_adjacent]
            id=${UNITVAR}.id
        [/filter_adjacent]
        [and]
        trait=undead#so it works on vampires/other add-ons' custom undead races
        [/and]
        [/filter]
        amount=$steppe_container_currentheal{VARIABLENUMBER}
        animate=yes
        restore_statuses=no
    [/heal_unit]

    {CLEAR_VARIABLE steppe_container_orighp{VARIABLENUMBER}}
    {CLEAR_VARIABLE steppe_container_newhp{VARIABLENUMBER}}
    {CLEAR_VARIABLE steppe_container_currentheal{VARIABLENUMBER}}
[/event]
#enddef

#define ABILITY_STEPPE_CONTAINER_OF_DARKNESS
    [dummy]
        id=steppe_container_of_darkness
        name=_"container of darkness"
        description= _"At the end of an attack, adjacent undead allies are healed by 40% (rounded down) of the damage the unit has received while fighting."
    [/dummy]
     # wmlxgettext: [abilities]
[/abilities]
{STEPPE_CONTAINER_EVENTS 1 second_unit (
    [filter_second]
        ability=steppe_container_of_darkness
    [/filter_second]
)}
{STEPPE_CONTAINER_EVENTS 2 unit (
    [filter]
        ability=steppe_container_of_darkness
    [/filter]
)}
[+abilities]
#enddef

#define ABILITY_HUNN_BARROW_TSAR
    #used by the mancatcher/slaver apprentice/slaver
    #invisible ability used both as a filter, and as a 20% damage buff to the bodyguard (as I couldn't code an adjacent filter properly)
    [leadership]
        id=steppe_barrow_tsar
        name=_"scythian tsar"
        description= _"Adjacent barrow riders and barrow wardens deal 20% more damage"
        value=20
        cumulative=no
        affect_self=no
        affect_allies=yes
        [affect_adjacent]
            [filter]
                ability=steppe_hunn_scythian
                formula="level < other.level"
            [/filter]
        [/affect_adjacent]
    [/leadership]
#enddef


#define ABILITY_STEPPE_PATRIARCH_OF_UNLIFE
#the unit has a chance to defect
    [dummy]
        id=steppe_patriarch_of_unlife
        name=_"patriarch of unlife"
        description= _"When an allied undead unit is defeated next to this unit, the undead unit is resurrected with 25% HP, and becomes marked with a purple skull overlay. Marked units cannot be revived again, but the mark is removed if the unit advances or the battle ends. The ability doesn't work on self."
    [/dummy]
     # wmlxgettext: [abilities]
[/abilities]
[event]
    name=last breath
    id=steppe_hunn_patriarch_ability_event
    first_time_only=no
    [filter]
        [and]
        trait=undead#so it works on vampires/other add-ons' custom undead races
        [/and]
        [not]
            ability=steppe_revived_by_patriarch
        [/not]
        [filter_location]
            [filter]
                ability=steppe_patriarch_of_unlife
            [filter_side]
            [allied_with]
                side=$unit.side
            [/allied_with]
            [/filter_side]
            [not]
                id=$unit.id #to prevent the unit from self-reviving
            [/not]
            [/filter]
            radius=1
        [/filter_location]
    [/filter]
#    [filter_second_attack]
#    [not]
#       special_id=steppe_capture
#    [/not]
#    [/filter_second_attack]

#remove the exp the enemy would've gotten from the kill, but give attack exp instead:
    {EXP_VALUE_CALC $unit.id steppe_revived_exp}
    {VARIABLE_OP second_unit.experience sub $steppe_revived_exp}
    {VARIABLE_OP second_unit.experience add $unit.level}#add exp equal to having attacked the unit normally
    [unstore_unit]
        variable=second_unit
        find_vacant=no
    [/unstore_unit]
    {CLEAR_VARIABLE steppe_revived_exp}


    [store_unit]
        [filter]
            ability=steppe_patriarch_of_unlife
            [filter_side]
            [allied_with]
                side=$unit.side
            [/allied_with]
            [/filter_side]
            [filter_adjacent]
                id=$unit.id
            [/filter_adjacent]
        [/filter]
        variable=steppe_patriarch
        kill=no
    [/store_unit]

    [animate_unit]
        flag=revive
        [filter]
            id=$steppe_patriarch[0].id
        [/filter]
        [filter_second]
            id=$unit.id
        [/filter_second]
        [facing]
            x,y=$x1,$y1
        [/facing]
    [/animate_unit]

    {CLEAR_VARIABLE steppe_patriarch}


    {MODIFY_UNIT id=$unit.id hitpoints 0}
        [heal_unit]
            [filter]
                id=$unit.id
            [/filter]
            amount="$($unit.max_hitpoints| / 4)"
            animate=yes
            restore_statuses=no
        [/heal_unit]
    [object]
        silent=yes
        duration=scenario
        [filter]
            find_in=unit
        [/filter]
        [effect]
            apply_to=new_ability
#this is for filtering, so the same unit cannot be revived more than once
            [abilities]
              [dummy]
                 id=steppe_revived_by_patriarch
              [/dummy]
            [/abilities]
        [/effect]   
    [/object]
    [unit_overlay]
        id=$unit.id
        image="misc/overlay-resurrected.png"
    [/unit_overlay]
[/event]
[event]
    name=post advance
    id=steppe_hunn_removepatriarcheffect
    first_time_only=no
    [filter]
      ability=steppe_revived_by_patriarch
    [/filter]

    [object]
        silent=yes
        duration=scenario
        [filter]
            find_in=unit
        [/filter]
        [effect]
            apply_to=remove_ability
            [abilities]
              [dummy]
                 id=steppe_revived_by_patriarch
              [/dummy]
            [/abilities]
        [/effect]   
    [/object]

    [remove_unit_overlay]
        id=$unit.id
        image="misc/overlay-resurrected.png"
    [/remove_unit_overlay]
[/event]
[event]
    name=scenario_end
    id=steppe_hunn_patriarch_clear_overlays
    first_time_only=no
    [store_unit]
        [filter]
            ability=steppe_revived_by_patriarch
        [/filter]
        variable=revive_overlay
        kill=no
    [/store_unit]
    [if]
    [variable]
        name=revive_overlay.length
        greater_than=0
    [/variable]
    [then]

    [foreach]
        array=revive_overlay
        index_var=i
        [do]
        [remove_unit_overlay]
            id=$this_item.id
            image="misc/overlay-resurrected.png"
        [/remove_unit_overlay]
        [/do]
    [/foreach]
    {CLEAR_VARIABLE revive_overlay}
    [/then]
    [/if]
[/event]
[+abilities]
#enddef



#define STEPPE_PRIMALRAGE_EVENTS VARIABLENUMBER UNITVAR FILTERS
[event]
    name=attack
    id=steppe_primalrage_event{VARIABLENUMBER}1
    first_time_only=no

    {FILTERS}

#    [chat]
#       speaker=_"Debug"
#       message= _ "currently stored damage ${UNITVAR}.variables.primalrage_damage|"
#    [/chat]

#the number at the end is to differentiate the variables when there are two units with this ability fighting eachother
    {VARIABLE steppe_primalrage_orighp{VARIABLENUMBER} ${UNITVAR}.hitpoints}
[/event]

[event]
    name=attack end
    id=steppe_primalrage_event{VARIABLENUMBER}2
    first_time_only=no

    {FILTERS}

    {VARIABLE steppe_primalrage_newhp{VARIABLENUMBER} ${UNITVAR}.hitpoints}

    {VARIABLE steppe_primalrage_currentdmgbonus{VARIABLENUMBER} $steppe_primalrage_orighp{VARIABLENUMBER} }
    {VARIABLE_OP steppe_primalrage_currentdmgbonus{VARIABLENUMBER} sub $steppe_primalrage_newhp{VARIABLENUMBER} }
    {VARIABLE_OP steppe_primalrage_currentdmgbonus{VARIABLENUMBER} multiply 0.66} #multiplies the healing by a percentage
    {VARIABLE_OP steppe_primalrage_currentdmgbonus{VARIABLENUMBER} round ceil}

    {VARIABLE_OP {UNITVAR}.variables.primalrage_damage add $steppe_primalrage_currentdmgbonus{VARIABLENUMBER} }

#    [chat]
#       speaker=_"Debug"
#       message= _ "orig hp: $steppe_primalrage_orighp{VARIABLENUMBER}| new hp: $steppe_primalrage_newhp{VARIABLENUMBER}| current damage bonus: $steppe_primalrage_currentdmgbonus{VARIABLENUMBER}| currently stored damage ${UNITVAR}.variables.primalrage_damage|"
#    [/chat]

    [foreach]
        array={UNITVAR}.attack
        index_var=i
        [do]
            [if]
                [have_unit]
                    id=${UNITVAR}.id
                    [has_attack]
                        name=$this_item.name
                        description=$this_item.description
                        type=$this_item.type
                        special_id=steppe_primal_rage2
                    [/has_attack]
                [/have_unit]
                [then]
                    {VARIABLE tmp_primalrage_index $i}
                [/then]
            [/if]
        [/do]
    [/foreach]

    {VARIABLE_OP {UNITVAR}.attack[$tmp_primalrage_index].damage add $steppe_primalrage_currentdmgbonus{VARIABLENUMBER} }

    {CLEAR_VARIABLE tmp_primalrage_index}

    [unstore_unit]
        variable={UNITVAR}
    [/unstore_unit]

    {CLEAR_VARIABLE steppe_primalrage_orighp{VARIABLENUMBER}}
    {CLEAR_VARIABLE steppe_primalrage_newhp{VARIABLENUMBER}}
    {CLEAR_VARIABLE steppe_primalrage_currentdmgbonus{VARIABLENUMBER}}
[/event]
#enddef


#define ABILITY_STEPPE_PRIMAL_RAGE
    [dummy]
        id=steppe_primal_rage
        name=_"primal rage"
        description= _"After being attacked, the unit's attack with the 'rampage' special gains damage equal to 66% of the HP the unit lost during the attack. The bonus damage is reset upon successfully hitting an enemy with the rampage attack."
    [/dummy]
     # wmlxgettext: [abilities]
[/abilities]
{STEPPE_PRIMALRAGE_EVENTS 1 second_unit (
    [filter_second]
        ability=steppe_primal_rage
    [/filter_second]
)}
{STEPPE_PRIMALRAGE_EVENTS 2 unit (
    [filter]
        ability=steppe_primal_rage
    [/filter]
)}

#todo: add an attacker_hits event here to reset the damage, or in a seperate weapon special

[+abilities]
#enddef

#define WEAPON_SPECIAL_STEPPE_PRIMAL_RAGE
#Dummy special that applies a screenshake effect when the attack hits
# wmlxgettext: [specials]
    [dummy]
        id=steppe_primal_rage2
        name=_"rampage"
        description= _"This attack's damage is affected by the 'primal rage' ability. The bonus damage is reset upon successfully hitting an enemy with the rampage attack."
    [/dummy]
[/specials]
# wmlindent: start ignoring
[/attack]
# wmlindent: stop ignoring

[event]
    name=attacker_hits
    id=steppe_primal_rage_reset_event
    first_time_only=no

    [filter_attack]
        special_id=steppe_primal_rage2
    [/filter_attack]

#note: the array is set to [1] to apply the damage bonus to the second attack. as of now, the ability isn't really intended to be directly used for other units, but if/when it is, I might need to add the array as a macro option, kind of like how EoMa does it

    {VARIABLE_OP unit.attack[1].damage sub $unit.variables.primalrage_damage }
    {VARIABLE unit.variables.primalrage_damage 0}

    [unstore_unit]
        variable=unit
    [/unstore_unit]
[/event]
[+attack]
# wmlindent: start ignoring

[+specials]
# wmlxgettext: [/specials]
# wmlxgettext: [/attack]
# wmlindent: stop ignoring
#enddef


#define CAROUSEL_SECOND_ATTACK UNITVAR ATTACK_NAME ATTACKLIMIT
    [set_variable]
        name={UNITVAR}.attacks_left
        add=1
    [/set_variable]

    [unstore_unit]
        text= _ "attacks left: $({ATTACKLIMIT} - ${UNITVAR}.variables.carousel_attacks_done|)"
        red=200
        green=0
        blue=255
        variable={UNITVAR}
    [/unstore_unit]


    [set_variable]
        name={UNITVAR}.moves
        add=$(${UNITVAR}.max_moves * 0.25)
    [/set_variable]

    [set_variables]
        name={UNITVAR}.variables
        mode=merge
        [value]
            carousel_turn=$turn_number
        [/value]
    [/set_variables]

    [set_variable]
        name={UNITVAR}.variables.carousel_attacks_done
        add=1
    [/set_variable]

    [unstore_unit]
        variable={UNITVAR}
    [/unstore_unit]

    [if]
        [variable]
            name={UNITVAR}.variables.carousel_attacks_done
            less_than={ATTACKLIMIT}
        [/variable]

        [then]
            {GSE_DEPRECATED_MACRO_FOREACH {UNITVAR}.attack i}
                [if]
                    [variable]
                        name={UNITVAR}.attack[$i].name
                        equals={ATTACK_NAME}
                    [/variable]

                    [then]
                    {VARIABLE steppe_carousel_attackedunit $second_unit.id}
                    [object]
                        silent=yes
                        duration=turn#turn end
                
                        [filter]
                            find_in={UNITVAR}
                        [/filter]
                
                        [effect]
                            apply_to=attack
                            #todo: fix this filter:
                            name=$tmp_carousel_unit_store.attack[$i].name
                            [set_specials]
                                mode=append
                                [disable]
                                    id=steppe_carousel_disable$steppe_carousel_attackedunit
                                    [filter_opponent]
                                        id=$steppe_carousel_attackedunit
                                    [/filter_opponent]
                                [/disable]
                            [/set_specials]
                        [/effect]
                    [/object]
                    {CLEAR_VARIABLE steppe_carousel_attackedunit}
                    [/then]

                    [else]
                    [object]
                        silent=yes
                        duration=turn#turn end
                
                        [filter]
                            find_in={UNITVAR}
                        [/filter]
                
                        [effect]
                            apply_to=attack
                            #todo: fix this filter:
                            name=$tmp_carousel_unit_store.attack[$i].name
                            [set_specials]
                                mode=append
                                {WEAPON_SPECIAL_CAROUSEL_DISABLEATTACK}
                            [/set_specials]
                        [/effect]
                    [/object]
                    [/else]
                [/if]
            {GSE_DEPRECATED_MACRO_NEXT i}
        [/then]
    [/if]
#enddef

#define WEAPON_SPECIAL_CAROUSEL_DISABLEATTACK
#invisible weapon special for the carousel to disable other attacks
    [disable]
        id=steppe_carousel_disableattack
#commented out, as it's just for debugging
#        name="carousel disable" "хоровод выключает"}
        active_on=offense
    [/disable]
#enddef

#define WEAPON_SPECIAL_STEPPE_CAROUSEL TYPE ATTACK_NAME ATTACKLIMIT
    # wmlxgettext: [attack]
    # wmlxgettext: [specials]
    [dummy]
        id=steppe_carousel
        name=_"carousel"+" {ATTACKLIMIT}"
        description= _"After using this attack, this unit regains 25% of their moves, and can attack again (but only with the same attack). This attack cannot attack the same unit twice in one turn. This ability can be used up to "+{ATTACKLIMIT}+_" times in one turn."
    [/dummy]
[/specials]
# wmlindent: start ignoring
[/attack]
# wmlindent: stop ignoring

[event]
    name=side turn
    id=steppe_carousel_event{TYPE}
    first_time_only=no

    [store_unit]
        [filter]
            type={TYPE}
        [/filter]
        variable=carousel_unit_store
    [/store_unit]

    {GSE_DEPRECATED_MACRO_FOREACH carousel_unit_store i}
#        [if]
#            {VARIABLE_CONDITIONAL carousel_unit_store[$i].variables.carousel_attacked boolean_equals yes}
#            [then]
#                {FOREACH carousel_unit_store[$i].attack j}
#                    [if]
#                        {VARIABLE_CONDITIONAL carousel_unit_store[$i].attack[$j].name not_equals {ATTACK_NAME}}
#                        [then]
#                            {VARIABLE_OP carousel_unit_store[$i].attack[$j].attack_weight add 1}
#                        [/then]
#                    [/if]
#                {NEXT j}

                {VARIABLE carousel_unit_store[$i].variables.carousel_attacks_done 0}

                [unstore_unit]
                    variable=carousel_unit_store[$i]
                [/unstore_unit]
#            [/then]
#        [/if]
    {GSE_DEPRECATED_MACRO_NEXT i}
    {CLEAR_VARIABLE carousel_unit_store}
[/event]

[event]
    name=attack_end
    id=steppe_carousel_event2{TYPE}
    first_time_only=no
    [filter_attack]
        special_id=steppe_carousel
    [/filter_attack]

    [filter]
        type={TYPE}
    [/filter]

    [store_unit]
        [filter]
            id=$unit.id
        [/filter]
        variable=tmp_carousel_unit_store
    [/store_unit]

    [if]
        {VARIABLE_CONDITIONAL tmp_carousel_unit_store.variables.carousel_attacks_done less_than {ATTACKLIMIT} }
        [then]
            {CAROUSEL_SECOND_ATTACK unit {ATTACK_NAME} {ATTACKLIMIT} }
        [/then]
        [else]
            [if]
                {VARIABLE_CONDITIONAL tmp_carousel_unit_store.variables.carousel_turn not_equals $turn_number}
                [then]
                    {VARIABLE unit.variables.carousel_attacks_done 0}
                    {CAROUSEL_SECOND_ATTACK unit {ATTACK_NAME} {ATTACKLIMIT} }
                [/then]
            [/if]
        [/else]
    [/if]

    [object]
        silent=yes
        duration=turn#turn end
    
        [filter]
            id=$second_unit.id
        [/filter]

        [effect]
            apply_to=new_ability
            [abilities]
              [dummy]
                 id=attacked_by_hunn
              [/dummy]
            [/abilities]
        [/effect]    
   [/object]
[/event]

[event]
    name=victory,side turn
    id=steppe_carousel_event3{TYPE}
    first_time_only=no

    {CLEAR_VARIABLE tmp_carousel_unit_store}
    {CLEAR_VARIABLE carousel_unit_store}
[/event]
[+attack]
    [+specials]
        # wmlxgettext: [/specials]
        # wmlxgettext: [/attack]
#enddef

#define STEPPE_DEMON_BUFFS UNITVAR
    [if]
    [have_unit]
        ability=steppe_demon_effects_demon_general
        [filter_side]
        [allied_with]
            side=$side_number
        [/allied_with]
        [/filter_side]
        [not]
        ability=steppe_captured
        [/not]
    [/have_unit]
    [then]
    #using modify_unit with object instead of just object, as [object] can't directly modify units on the recall list
        [modify_unit]
        [filter]
            id=${UNITVAR}.id
        [/filter]
        [object]
            silent=yes
            duration=forever
            [effect]
                apply_to=attack
                increase_damage=1
            [/effect]
        [/object]
        [/modify_unit]
    [/then]
    [/if]

    [if]
    [have_unit]
        ability=steppe_demon_effects_demon_warmonger
        [filter_side]
        [allied_with]
            side=$side_number
        [/allied_with]
        [/filter_side]
        [not]
        ability=steppe_captured
        [/not]
    [/have_unit]
    [then]
        [modify_unit]
            [filter]
                id=${UNITVAR}.id
            [/filter]
            {TRAIT_FEARLESS}
        [/modify_unit]
    [/then]
    [/if]
    [modify_unit]
    [filter]
        id=${UNITVAR}.id
    [/filter]
    [object]
        silent=yes
        duration=scenario
        #removing the dummy ability, which was used to tell apart birther kanavars
        [effect]
            apply_to=remove_ability
            [abilities]
              [dummy]
                 id=steppe_birthed_nodemonbuffs
              [/dummy]
            [/abilities]
        [/effect]
    [/object]
    [/modify_unit]
#enddef

#define EVENTLOADER_EVENTS_HUNN
[event]
    name=preload
    first_time_only=no
    [lua]
       code = << wesnoth.require "~add-ons/1The_Great_Steppe_Era/lua/steppe_lua_functions.lua"

       steppe_attach_unit_status_renderer()

        >>
    [/lua]
[/event]

[event]
    name=start
    id=steppe_hunn_start_event
    first_time_only=no
#ifdef OGRE_RUSSIAN
    {VARIABLE steppe_hunntext_russian_enabled yes}
#else
    {VARIABLE steppe_hunntext_russian_enabled no}
#endif
[/event]

[event]
    name=recall
    id=steppe_hunn_recall_cost_reset_event
    first_time_only=no

    [filter]
        ability=steppe_birthed_recalled
    [/filter]

#resets the recall cost to its normal state
    {MODIFY_UNIT id=$unit.id recall_cost -1}
[/event]

[event]
    name=turn refresh #used instead of side turn to make it trigger after healing
    id=steppe_hunn_depleting_event
    first_time_only=no
    [store_unit]
        [filter]
            side=$side_number
            ability=steppe_depleting_hunn
        [not]
        [filter_wml]
        [status]
            petrified=yes
        [/status]
        [/filter_wml]
        [/not]
        [/filter]
        variable=depleting
        kill=no
    [/store_unit]
    [if]
    [variable]
        name=depleting.length
        greater_than=0
    [/variable]
    [then]
    {GSE_DEPRECATED_MACRO_FOREACH depleting i}

    [if]
    [have_unit]
        id=$depleting[$i].variables.decay_cursed_by
    [/have_unit]
    [else]
            {STEPPE_CURSE_OF_DECAY_UNCURSE2 depleting[$i]}
    [/else]
    [then]

    [if]
    [have_unit]
        id=$depleting[$i].variables.decay_cursed_by
        [filter_wml]
        [status]
            petrified=yes
        [/status]
        [/filter_wml]
    [/have_unit]
    [then]
    [store_unit]
        [filter]
            id=$depleting[$i].variables.decay_cursed_by
        [/filter]
        variable=tmp_steppe_curser
        kill=no
    [/store_unit]
    {STEPPE_CURSE_OF_DECAY_UNCURSE tmp_steppe_curser $depleting[$i].variables.decay_damage}
    [unstore_unit]
        variable=tmp_steppe_curser
        find_vacant=no
    [/unstore_unit]
    {CLEAR_VARIABLE tmp_steppe_curser}
    [/then]
    [else]

    [store_unit]
        [filter]
            id=$depleting[$i].variables.decay_cursed_by
        [/filter]
        variable=tmp_steppe_curser
        kill=no
    [/store_unit]

    {IF_VAR depleting[$i].variables.decay_damage greater_than_equal_to $depleting[$i].hitpoints (
    [then]
#        [chat]
#            message=$depleting[$i].variables.decay_cursed_by
#        [/chat]
        [harm_unit]
            [filter]
                id=$depleting[$i].id
            [/filter]
            [filter_second]
                id=$depleting[$i].variables.decay_cursed_by
            [/filter_second]
            amount=$depleting[$i].variables.decay_damage
            experience=yes
            fire_event=yes
            animate=defender
            kill=yes
        [/harm_unit]

        [if]
        [have_unit]
            id=$depleting[$i].id
        [/have_unit]
        [else]
        {IF_VAR depleting[$i].status.unplagueable not_equals yes (
        [then]
            [sound]
                name={SOUND_LIST:ZOMBIE_HIT}
            [/sound]

            [unit]
                type=Hunn_Lesser_Ghoul
                generate_name=yes
                side=$tmp_steppe_curser.side
                x=$depleting[$i].x
                y=$depleting[$i].y
                placement=map
                overwrite=no
                attacks_left=0
                moves=0
            [/unit]            

        {CLEAR_VARIABLE tmp_steppe_curser}
        [/then]
        )}
        [/else]
        [/if]
    [/then]
    [else]
        [harm_unit]
            [filter]
                id=$depleting[$i].id
            [/filter]
            amount=$depleting[$i].variables.decay_damage
            experience=no
            fire_event=yes
            animate=yes
            kill=no
        [/harm_unit] 
    [/else]
    )}
    [/else]
    [/if]
    [/then]
    [/if]
    {GSE_DEPRECATED_MACRO_NEXT i}
    {CLEAR_VARIABLE depleting}
    [/then]
    [/if]
[/event]

[event]
    name=pre advance
    id=steppe_hunn_scale_curse_of_decay_effect1
    first_time_only=no
    [filter]
      ability=steppe_curseeffect_decay
    [/filter]

    [remove_unit_overlay]
        id=$unit.id
        image="misc/overlay-curseofdecay.png~SCALE($unit.variables.curse_image_size_width|,$unit.variables.curse_image_size_height|)"
    [/remove_unit_overlay]
[/event]

[event]
    name=post advance
    id=steppe_hunn_scale_curse_of_decay_effect2
    first_time_only=no
    [filter]
      ability=steppe_curseeffect_decay
    [/filter]

    {STEPPE_LUA_CALCULATE_UNIT_SPRITE_SIZE unit steppe_cursesize_calc_width steppe_cursesize_calc_height}

    {VARIABLE unit.variables.curse_image_size_width $steppe_cursesize_calc_width}
    {VARIABLE unit.variables.curse_image_size_height $steppe_cursesize_calc_height}

    [unstore_unit]
        variable=unit
        find_vacant=no
    [/unstore_unit]

    [unit_overlay]
        id=$unit.id
        image="misc/overlay-curseofdecay.png~SCALE($unit.variables.curse_image_size_width|,$unit.variables.curse_image_size_height|)"
    [/unit_overlay]
[/event]

[event]
    name=pre advance
    id=steppe_hunn_scale_curse_of_nature_effect1
    first_time_only=no
    [filter]
      ability=stepped_cursed_curse_of_nature
    [/filter]

    [remove_unit_overlay]
        id=$unit.id
        image="misc/overlay-curseofnature.png~SCALE($unit.variables.curse_image_size_width|,$unit.variables.curse_image_size_height|)"
    [/remove_unit_overlay]
[/event]

[event]
    name=post advance
    id=steppe_hunn_scale_curse_of_nature_effect2
    first_time_only=no
    [filter]
      ability=stepped_cursed_curse_of_nature
    [/filter]

    {STEPPE_LUA_CALCULATE_UNIT_SPRITE_SIZE unit steppe_cursesize_calc_width steppe_cursesize_calc_height}

    {VARIABLE unit.variables.curse_image_size_width $steppe_cursesize_calc_width}
    {VARIABLE unit.variables.curse_image_size_height $steppe_cursesize_calc_height}

    [unstore_unit]
        variable=unit
        find_vacant=no
    [/unstore_unit]

    [unit_overlay]
        id=$unit.id
        image="misc/overlay-curseofnature.png~SCALE($unit.variables.curse_image_size_width|,$unit.variables.curse_image_size_height|)"
    [/unit_overlay]
[/event]

[event]
    name=pre advance
    id=steppe_hunn_scale_evileye_effect1
    first_time_only=no
    [filter]
      ability=steppe_evileyed
    [/filter]

    [remove_unit_overlay]
        id=$unit.id
        image="misc/overlay-evileye.png~SCALE($unit.variables.curse_image_size_width|,$unit.variables.curse_image_size_height|)"
    [/remove_unit_overlay]
[/event]

[event]
    name=post advance
    id=steppe_hunn_scale_evileye_effect2
    first_time_only=no
    [filter]
      ability=steppe_evileyed
    [/filter]

    {STEPPE_LUA_CALCULATE_UNIT_SPRITE_SIZE unit steppe_cursesize_calc_width steppe_cursesize_calc_height}

    {VARIABLE unit.variables.curse_image_size_width $steppe_cursesize_calc_width}
    {VARIABLE unit.variables.curse_image_size_height $steppe_cursesize_calc_height}

    [unstore_unit]
        variable=unit
        find_vacant=no
    [/unstore_unit]

    [unit_overlay]
        id=$unit.id
        image="misc/overlay-evileye.png~SCALE($unit.variables.curse_image_size_width|,$unit.variables.curse_image_size_height|)"
    [/unit_overlay]
[/event]

[event]
    name=steppe_customevent_changeside
    id=steppe_curse_of_decay_changeside_event
    first_time_only=no

    [filter]
        ability=steppe_curseeffect_decay
    [/filter]

    {STEPPE_CURSE_OF_DECAY_UNCURSE2 unit}
[/event]

[event]
    name=recruit
    id=steppe_hunn_recruit_demon_buffs
    first_time_only=no
    [filter]
#todo: maybe make this filter via ability
        race=kanavar
    [/filter]
    [if]
    [have_unit]
        ability=steppe_demon
        [filter_side]
        [allied_with]
            side=$side_number
        [/allied_with]
        [/filter_side]
    [/have_unit]
    [then]
    {STEPPE_DEMON_BUFFS unit}
    [/then]
    [/if]
[/event]

[event]
    name=unit placed,post advance
    id=steppe_demon_halo
    first_time_only=no
    [filter]
    ability=steppe_demon
    [/filter]
    {IF_VAR steppe_disable_demon_halos not_equals yes  (
    [then]
    [object]
        silent=yes
        duration=forever
        id=steppe_demon_halo
        take_only_once=no

        [filter]
            id=$unit.id
        [/filter]

        [effect]
            apply_to=halo
            halo="halo/demon-aura.png"
        [/effect]
        [effect]
            apply_to=new_ability
            [abilities]
              [dummy]
                 id=steppe_demon_halo_dummy_ability #for filtering later
              [/dummy]
            [/abilities]
        [/effect]        
    [/object]
    [/then]
    )}
[/event]

#removes the halo if the unit is somehow transformed into a non-overseer unit, via add-ons

[event]
    name=post advance
    id=steppe_demon_halo_remover
    first_time_only=no
    [filter]
    ability=steppe_demon_halo_dummy_ability
    [not]
    ability=steppe_demon
    [/not]
    [/filter]
    {IF_VAR steppe_disable_demon_halos not_equals yes  (
    [then]
    [remove_object]
        id=$unit.id
        object_id=steppe_demon_halo
    [/remove_object]
    [/then]
    )}
[/event]

[event]
    name=start
    id=steppe_witchcurse_calculator_menu
    first_time_only=no

    [set_menu_item]
        id=steppe_curseofdecay_calculator
        description=_"Which enemy is this unit cursed by?"
        image=items/book2.png~CROP(21,23,27,24)~SCALE(20,20)
        #DO NOT SET SYNCED TO NO FOR ANY MENUS THAT ACTUALLY AFFECT THE GAME!!!
        synced=yes
        [show_if]
        {VARIABLE_CONDITIONAL steppe_disable_calculator_menu not_equals yes}
        [/show_if]

        [filter_location]
            [filter]
                ability=steppe_depleting_hunn
            [/filter]
        [/filter_location]
        [command]
    [allow_undo] [/allow_undo]

    [store_unit]
        [filter]
            x,y=$x1,$y1
        [/filter]
        variable=steppe_cursecalc_unit
        kill=no
    [/store_unit]

[if]
[have_unit]
id=$steppe_cursecalc_unit.variables.decay_cursed_by
[filter_vision]
    visible=yes
    side=$side_number
[/filter_vision]
[not]
    ability_type_active=hides
    [not]
      status=uncovered
    [/not]            
[/not]
[/have_unit]
[then]
    [store_unit]
        [filter]
            id=$steppe_cursecalc_unit.variables.decay_cursed_by
        [/filter]
        variable=tmp_steppe_curser
        kill=no
    [/store_unit]
    {STEPPE_TMP_HIGHLIGHT_IMAGE $tmp_steppe_curser.x $tmp_steppe_curser.y "misc/unit-pointer.png" $side_number 3 500}
    {CLEAR_VARIABLE tmp_steppe_curser}
[/then]
[else]

        [message]
            speaker=narrator
            side_for=$side_number
            message=_"The curser isn't visible..."
            image=portraits/factionhint-hunn.png
        [/message]

[/else]
[/if]

    {CLEAR_VARIABLE steppe_cursecalc_unit}

        [/command]
    [/set_menu_item]
[/event]
#enddef

#define ABILITY_STEPPE_BIRTHER_OF_FIENDS ID TYPE RECALL_COST EFFECTS BIRTHTURNS
#the unit has a chance to defect
    [birther_of_fiends]
        id=steppe_birther_of_fiends{ID}
        name=_"birther of fiends"
        description= _"If there is an allied demon in a 3-tile radius from this unit, she will start birthing a Kanavar. After"+" {BIRTHTURNS} "+_"turns pass, the kanavar is birthed and added to the recall list (costing"+" {RECALL_COST} "+_"gold instead of the default 21 on first recall, but having 4 upkeep instead 1 until the unit advances), the unit gets experience equal to number of turns it takes to give birth multiplied by her level, and the timer is reset."
    [/birther_of_fiends]
#dummy ability for filtering:
    [dummy]
        id=steppe_birther_of_fiends
    [/dummy]
     # wmlxgettext: [abilities]
[/abilities]
#TODO: give the abilities seperate ids
[event]
    name=side turn
    id=steppe_hunn_birther_event{ID}
    first_time_only=no

    [store_unit]
        [filter]
            side=$side_number
            ability=steppe_birther_of_fiends{ID}
        [not]
        [filter_wml]
        [status]
            petrified=yes
        [/status]
        [/filter_wml]
        [or]
            x,y=recall,recall
        [/or]
        [/not]
        [/filter]
        variable=birther
        kill=no
    [/store_unit]
    [if]
    [variable]
        name=birther.length
        greater_than=0
    [/variable]
    [then]

    {GSE_DEPRECATED_MACRO_FOREACH birther i}

    [if]
    [have_unit]
        ability=steppe_demon
        [filter_side]
        [allied_with]
            side=$side_number
        [/allied_with]
        [/filter_side]
        [not]
        ability=steppe_captured
        [/not]
        [filter_location]
           x,y=$birther[$i].x,$birther[$i].y
           radius=3
        [/filter_location]
    [/have_unit]
    [then]
    {VARIABLE birther[$i].variables.pregnant yes}
    [/then]
    [/if]

#    [chat]
#       message="witch pregnant: $birther[$i].variables.pregnant|"
#    [/chat]


{IF_VAR birther[$i].variables.pregnant equals yes (
[then]

#note: this need unstoring the unit to work properly, and the unstore event is at the bottom of the event

    {IF_VAR birther[$i].variables.birthturns greater_than 0 (
    [else]
    {VARIABLE birther[$i].variables.birthturns 0}
    [/else]
    )}

    {VARIABLE_OP birther[$i].variables.birthturns add 1}

    {IF_VAR birther[$i].variables.birthturns greater_than_equal_to {BIRTHTURNS} (
    [then]
    {VARIABLE birther[$i].variables.birthturns 0}

    [scroll_to]
        x,y=$birther[$i].x,$birther[$i].y
        side=$side_number
    [/scroll_to]

    {VARIABLE birther[$i].variables.pregnant no}

    {VARIABLE tmp_witchexp {BIRTHTURNS}}
    {VARIABLE_OP tmp_witchexp multiply $birther[$i].level}

    {VARIABLE_OP birther[$i].experience add $tmp_witchexp}

    {CLEAR_VARIABLE tmp_witchexp}

    [unit]
        type={TYPE}
        side=$side_number
        x,y=recall,recall
        random_name=yes
        random_traits=yes
        random_gender=yes
        recall_cost={RECALL_COST}
        [modifications]
    [object]
        silent=yes
        duration=scenario
        [effect]
            apply_to=new_ability
            [abilities]
              [dummy]
                 id=steppe_birthed_recalled #for reverting the recall cost back to 20 later on
              [/dummy]
#for demon buffs:
              [dummy]
                 id=steppe_birthed_nodemonbuffs
              [/dummy]
            [/abilities]
        [/effect]
    [/object]
#for various stat buffs
    [object]
        silent=yes
        duration=forever
        {EFFECTS}
    [/object]
        [/modifications]
    [/unit]
    [store_unit]
        [filter]
            ability=steppe_birthed_nodemonbuffs
        [/filter]
        variable=steppe_demonbuffs_unit
        kill=no
    [/store_unit]
#    [chat]
#        message=$steppe_demonbuffs_unit.id
#    [/chat]
    {STEPPE_DEMON_BUFFS steppe_demonbuffs_unit}
    {CLEAR_VARIABLE steppe_demonbuffs_unit}
    [sound]
      name={SOUND_LIST:HUMAN_FEMALE_HIT}
    [/sound]
    [sound]
      name=magic-dark.ogg
    [/sound]
    [/then]
    [else]
    {VARIABLE tmp_hunn_birth_turns_left {BIRTHTURNS}}
    {VARIABLE_OP tmp_hunn_birth_turns_left sub $birther[$i].variables.birthturns}
    [/else])}
#    [chat]
#       message="$birther[$i].variables.birthturns"
#    [/chat]
#    [chat]
#       message=$tmp_hunn_birth_text
#    [/chat]

    {VARIABLE birther[$i].variables.birth_turns_left $tmp_hunn_birth_turns_left|}

    [unstore_unit]
        variable=birther[$i]
        find_vacant=no
    [/unstore_unit]

    {IF_VAR birther[$i].variables.pregnant equals yes (
    [then]
    [unit_overlay]
        id=$birther[$i].id
        image="misc/overlay-witch-kanavar.png"
    [/unit_overlay]
    [/then]
    [else]
    [remove_unit_overlay]
        id=$birther[$i].id
        image="misc/overlay-witch-kanavar.png"
    [/remove_unit_overlay]
    [/else]
    )}




#    [chat]
#       message="$birther[$i].x| $birther[$i].y|"
#    [/chat]

#    [chat]
#       message="birthtext russian: $steppe_hunntext_russian_enabled|"
#    [/chat]

    {IF_VAR birther[$i].variables.birthturns equals 0 (
    [then]

#using floating text instead of text in [unstore_unit], as using multiple unstores in one event breaks the text for some reason

[floating_text]
   x,y=$birther[$i].x,$birther[$i].y
   text="<span color='#c800ff'>" + _ "kanavar birthed!" + "</span>"
[/floating_text]

    [delay]
       time=100
    [/delay]
    [/then]
    [else]
    [scroll_to]
        x,y=$birther[$i].x,$birther[$i].y
        side=$side_number
    [/scroll_to]

#[floating_text]
#   x,y=$birther[$i].x,$birther[$i].y
#   text="Test Text!"
#[/floating_text]

#[floating_text]
#   x,y=$birther[$i].x,$birther[$i].y
#   text="<span color='#c800ff'>$tmp_hunn_birth_turns_left| ходов до рождения</span>"
#[/floating_text]


[floating_text]
   x,y=$birther[$i].x,$birther[$i].y
   text=_"<span color='#c800ff'> $tmp_hunn_birth_turns_left| turns before birth</span>"
[/floating_text]


    [delay]
       time=100
    [/delay]
    [/else]
    )}

    [/then])}

    {GSE_DEPRECATED_MACRO_NEXT i}
    [/then]
    [/if]
    {CLEAR_VARIABLE birther}
    {CLEAR_VARIABLE tmp_hunn_birth_turns_left}
[/event]
#removed for now, as it makes balancing more difficult
#[event]
#    name=recruit
#    id=steppe_hunn_recruit_blood{ID}
#    first_time_only=no
#    [filter]
##todo: maybe make this filter via ability
#        race=kanavar
#    [/filter]
#    [if]
#    [have_unit]
#            ability=steppe_birther_of_fiends{ID}
#            side=$side_number
#            canrecruit=yes
#    [/have_unit]
#    [then]
#    [object]
#        silent=yes
#        duration=forever
#        [filter]
#            x,y=$x1,$y1
#        [/filter]
#        {EFFECTS}
#    [/object]
#    [/then]
#    [/if]
#[/event]
[+abilities]
#enddef

#define ABILITY_DEPLETING_HUNN NUMBER
#note: the number is only for display. the actual damage is done via variable.
    [dummy]
        id=steppe_depleting_hunn
        name=_"decay -"+{NUMBER}
        description=_"This unit loses "+{NUMBER}+_" hp each turn. Unlike poison, this ability can kill (in which case, the unit who applied this effect receives the experience). Living units killed by the curse are replaced by Lesser Ghouls for the curser's side."
    [/dummy]
#enddef

#define ABILITY_STEPPE_DEMON ID NAME DESCR
#put the names/descriptions in macros, as each demon has different effects, and making seperate abiliites for each feels rather clunky
    [dummy]
        id=steppe_demon
        name={NAME}
        description={DESCR}
    [/dummy]
#will likely be used for filtering for demon-specific kanavar buffs later on:
    [dummy]
        id=steppe_demon_effects_{ID}
    [/dummy]
#enddef

#define STEPPE_CURSE_OF_DECAY_REMOVE_CURSE ID NUMBER
    [object]
        silent=yes
        duration=scenario

        [filter]
            id={ID}
        [/filter]

        [effect]
            apply_to=remove_ability
            [abilities]
            {ABILITY_DEPLETING_HUNN {NUMBER}}
            [dummy]
                id=steppe_curseeffect_decay
            [/dummy]
            [/abilities]
        [/effect]
    [/object]

    [store_unit]
        [filter]
            id={ID}
        [/filter]

        variable=steppe_uncurse_unit
        kill=no
    [/store_unit]

#    [chat]
#        message=_"id: $steppe_uncurse_unit.id|"
#    [/chat]

    {VARIABLE steppe_uncurse_unit.variables.decay_cursed_by ""}

    [unstore_unit]
        variable=steppe_uncurse_unit
        find_vacant=no
        text= _ "curse lifted"
        {COLOR_HEAL}
    [/unstore_unit]

    [remove_unit_overlay]
        id={ID}
        image="misc/overlay-curseofdecay.png~SCALE($steppe_uncurse_unit.variables.curse_image_size_width|,$steppe_uncurse_unit.variables.curse_image_size_height|)"
    [/remove_unit_overlay]
#    [chat]
#        message="$steppe_uncurse_unit.variables.curse_image_size_width|,$steppe_uncurse_unit.variables.curse_image_size_height|"
#    [/chat]

[floating_text]
   x,y=$steppe_uncurse_unit.x,$steppe_uncurse_unit.y
   text="<span color='#00ff00'>" + _ "curse lifted" + "</span>"
[/floating_text]

    {CLEAR_VARIABLE steppe_uncurse_unit}
#enddef


#define STEPPE_CURSE_OF_DECAY_UNCURSE UNITVAR NUMBER
{IF_VAR {UNITVAR}.variables.last_cursed_unit_exists equals yes (
[and]
[have_unit]
    id=${UNITVAR}.variables.last_cursed_unit_id
[/have_unit]
[/and]
[then]
    {STEPPE_CURSE_OF_DECAY_REMOVE_CURSE ${UNITVAR}.variables.last_cursed_unit_id {NUMBER}}
    {CLEAR_VARIABLE {UNITVAR}.variables.last_cursed_unit_id} 
    {VARIABLE {UNITVAR}.variables.last_cursed_unit_exists no}
[/then]
[else]
    {CLEAR_VARIABLE {UNITVAR}.variables.last_cursed_unit_id} 
    {VARIABLE {UNITVAR}.variables.last_cursed_unit_exists no}
[/else]
)}
#enddef

#unlike the first uncurse macro, this one checks by unit

#define STEPPE_CURSE_OF_DECAY_UNCURSE2 UNITVAR

[if]
[have_unit]
id=${UNITVAR}.variables.decay_cursed_by
[/have_unit]
[then]
    [store_unit]
        [filter]
            id=${UNITVAR}.variables.decay_cursed_by
        [/filter]
        variable=tmp_steppe_curser
        kill=no
    [/store_unit]
    {STEPPE_CURSE_OF_DECAY_UNCURSE tmp_steppe_curser ${UNITVAR}.variables.decay_damage}
    [unstore_unit]
        variable=tmp_steppe_curser
        find_vacant=no
    [/unstore_unit]
    {CLEAR_VARIABLE tmp_steppe_curser}
[/then]
[else]
    {STEPPE_CURSE_OF_DECAY_REMOVE_CURSE ${UNITVAR}.id ${UNITVAR}.variables.decay_damage}
[/else]
[/if]
#enddef

#define STEPPE_CURSE_OF_DECAY_ERASE_CURSEVARS UNITVAR NUMBER

#this macro checks which witch cursed a specific unit, and removes the curse variables from said unit
    [store_unit]
        [filter]
            side=$side_number
            [has_attack]
                special_id=steppe_curse_of_decay
            [/has_attack]
        [/filter]
        variable=steppe_curser
        kill=no
    [/store_unit]
    [if]
    [variable]
        name=steppe_curser.length
        greater_than=0
    [/variable]
    [then]
    {GSE_DEPRECATED_MACRO_FOREACH steppe_curser i}
    {IF_VAR steppe_curser[$i].variables.last_cursed_unit_id equals ${UNITVAR}.id (
    [then]
#    [chat]
#        message="curse vars erased"
#    [/chat]
    {VARIABLE steppe_curser[$i].variables.last_cursed_unit_id ""}
    {VARIABLE steppe_curser[$i].variables.last_cursed_unit_exists no}

    [unstore_unit]
        variable=steppe_curser[$i]
        find_vacant=no
    [/unstore_unit]

    [/then]
    )}

    {GSE_DEPRECATED_MACRO_NEXT i}
    [/then]
    [/if]
    {CLEAR_VARIABLE steppe_curser}
#enddef


#define WEAPON_SPECIAL_STEPPE_CURSE_OF_DECAY NUMBER
# wmlindent: start ignoring
# wmlxgettext: [attack]
# wmlxgettext: [specials]

# wmlindent: stop ignoring
    [dummy]
        id=steppe_curse_of_decay{NUMBER}
        name=_"curse of decay {NUMBER}"
        description=_"When used offensively, this attack applies the 'decay {NUMBER}' effect to the target unit, making them lose {NUMBER} hp per turn (unlike poison, this can kill, and gives the unit who applied the status experience on kill). The curse is removed if either:
- the unit with this attack applies the curse to a different unit
- the unit who applied the curse is killed, changes sides, or is petrified
- the cursed unit changes sides

If a unit is killed either by the attack or the debuff, it is replaced by a Lesser Ghoul of the curser's side. Applying a stronger curse will replace the weaker one."
    [/dummy]
    [dummy]
#second dummy ability, used for some filters
        id=steppe_curse_of_decay
    [/dummy]
[/specials]
# wmlindent: start ignoring
[/attack]
# wmlindent: stop ignoring

[event]
    name=attacker_hits
    id=steppe_curse_of_decay_event{NUMBER}1
    first_time_only=no

    [filter_attack]
        special_id=steppe_curse_of_decay{NUMBER}
    [/filter_attack]

#    [filter_second]
#        [not]
#            [filter_wml]
#                [status]
#                    not_living="yes"
#                [/status]
#            [/filter_wml]
#            [or]
#                ability=steppe_depleting_hunn
#            [/or]
#        [/not]
#    [/filter_second]

    [if]
    [have_unit]
         id=$second_unit.id
         ability=steppe_depleting_hunn
    [/have_unit]
    [then]

    {IF_VAR second_unit.variables.decay_damage less_than {NUMBER} (
    [then]

#    [chat]
#        message=_"curse removal triggered"
#    [/chat]

    {VARIABLE tmp_curseremoval_object yes}

    {STEPPE_CURSE_OF_DECAY_ERASE_CURSEVARS second_unit {NUMBER}}

    {STEPPE_CURSE_OF_DECAY_UNCURSE unit {NUMBER}}

    {VARIABLE tmp_cancurse_enemy yes}
    [/then]
    [else]
    {VARIABLE tmp_cancurse_enemy no}
    [/else])}

    [/then]
    [else]
    {VARIABLE tmp_cancurse_enemy yes}

    {STEPPE_CURSE_OF_DECAY_UNCURSE unit {NUMBER}}

    [/else]
    [/if]

    {IF_VAR tmp_cancurse_enemy equals yes (
    [then]

    {VARIABLE second_unit.variables.decay_damage {NUMBER}}
    {VARIABLE second_unit.variables.decay_cursed_by $unit.id} #variable just in case

    [if]
        [variable]
            name=second_unit.gender
            equals=female
        [/variable]

        [then]
            [set_variable]
                name=tmp_cursed_text
                value= _ "female^cursed"
            [/set_variable]
        [/then]

        [else]
            [set_variable]
                name=tmp_cursed_text
                value= _ "cursed"
            [/set_variable]
        [/else]
    [/if]

[floating_text]
   x,y=$x2,$y2
   text=_"<span color='#c800ff'>curse of decay</span>"
[/floating_text]

    [if]
    [have_unit]
         id=$second_unit.id
         [not]
         ability=steppe_curseeffect_decay
         [/not]
    [/have_unit]
    [then]
    {STEPPE_LUA_CALCULATE_UNIT_SPRITE_SIZE second_unit steppe_cursesize_calc_width steppe_cursesize_calc_height}

    {VARIABLE second_unit.variables.curse_image_size_width $steppe_cursesize_calc_width}
    {VARIABLE second_unit.variables.curse_image_size_height $steppe_cursesize_calc_height}
    [/then]
    [/if]



    [unstore_unit]
        variable=second_unit
        find_vacant=no
#        text=$tmp_cursed_text
#        {COLOR_HARM}
    [/unstore_unit]

    {IF_VAR tmp_curseremoval_object equals yes (
    [then]

    [object]
        silent=yes
        duration=scenario

        [filter]
            find_in=second_unit
        [/filter]

        [effect]
            apply_to=remove_ability
            [abilities]
            {ABILITY_DEPLETING_HUNN $second_unit.variables.decay_damage}
            [dummy]
                id=steppe_curseeffect_decay
            [/dummy]
            [/abilities]
        [/effect]
    [/object]

    [/then]
    )}

    [if]
    [have_unit]
         id=$second_unit.id
         [not]
         ability=steppe_curseeffect_decay
         [/not]
    [/have_unit]
    [then]
    [unit_overlay]
        id=$second_unit.id
        image="misc/overlay-curseofdecay.png~SCALE($second_unit.variables.curse_image_size_width|,$second_unit.variables.curse_image_size_height|)"
    [/unit_overlay]
    [/then]
    [/if]


    [object]
        silent=yes
        duration=scenario

        [filter]
            id=$second_unit.id
        [/filter]

        [effect]
            apply_to=new_ability
            [abilities]
            {ABILITY_DEPLETING_HUNN {NUMBER}}
            [dummy]
                id=steppe_curseeffect_decay
            [/dummy]
            [/abilities]
        [/effect]
    [/object]



    [clear_variable]
        name=tmp_cursed_text
    [/clear_variable]

    {VARIABLE unit.variables.last_cursed_unit_id $second_unit.id}
    {VARIABLE unit.variables.last_cursed_unit_exists yes}

    [unstore_unit]
        variable=unit
        find_vacant=no
    [/unstore_unit]

    [/then])}
    {CLEAR_VARIABLE tmp_cancurse_enemy}
    {CLEAR_VARIABLE tmp_curseremoval_object}
[/event]

[event]
    id=steppe_curse_of_decay_death_event{NUMBER}
    name=die
    first_time_only=no

    [filter]
    [not]
        ability=steppe_notrigger_onkill_abilities
        [or]
            [filter_wml]
                [status]
                    unplagueable="yes"
                [/status]
            [/filter_wml]
        [/or]
    [/not]
    [/filter]

    [filter_second_attack]
       special_id=steppe_curse_of_decay{NUMBER}
    [/filter_second_attack]

    [sound]
        name={SOUND_LIST:ZOMBIE_HIT}
    [/sound]

    [unit]
        type=Hunn_Lesser_Ghoul
        generate_name=yes
        side=$second_unit.side
        x=$x1
        y=$y1
        placement=map
        overwrite=yes#otherwise the ghoul will spawn on a different tile
        attacks_left=0
        moves=0
    [/unit]            

[/event]

#removes the curse if the cursing unit is killed

[event]
    name=die,steppe_customevent_changeside
    id=steppe_curse_of_decay_event{NUMBER}3
    first_time_only=no

    [filter]
    [has_attack]
        special_id=steppe_curse_of_decay{NUMBER}
    [/has_attack]
    [/filter]

    {STEPPE_CURSE_OF_DECAY_UNCURSE unit {NUMBER}}

[/event]

[+attack]
# wmlindent: start ignoring

[+specials]
# wmlxgettext: [/specials]
# wmlxgettext: [/attack]
# wmlindent: stop ignoring
#enddef

#define ABILITY_STEPPE_CURSE_OF_NATURE
    [dummy]
       id=stepped_cursed_curse_of_nature
       name=_"curse of nature"
       description=_"Whenever a unit with this debuff gets hit, the other unit gets healed by 50% of the damage dealt."
    [/dummy]
#enddef


#define WEAPON_SPECIAL_STEPPE_CURSE_OF_NATURE
# wmlindent: start ignoring
# wmlxgettext: [attack]
# wmlxgettext: [specials]

# wmlindent: stop ignoring
    [dummy]
        id=steppe_curse_of_nature
        name=_"curse of nature"
        description=_"This unit applies the 'curse of nature' effect to the target enemy for a turn. Whenever a unit with this debuff gets hit, the other unit gets healed by 50% of the damage dealt."
    [/dummy]

[/specials]
# wmlindent: start ignoring
[/attack]
# wmlindent: stop ignoring

[event]
    name=attacker_hits
    id=steppe_curse_of_nature_event1
    first_time_only=no

    [filter_attack]
        special_id=steppe_curse_of_nature
    [/filter_attack]

    [filter_second]
        [not]
            ability=stepped_cursed_curse_of_nature
        [/not]
    [/filter_second]

    [set_variable]
         name=tmp_cursed_text
         value= _ "curse of nature"
    [/set_variable]

    {STEPPE_LUA_CALCULATE_UNIT_SPRITE_SIZE second_unit steppe_cursesize_calc_width steppe_cursesize_calc_height}

    {VARIABLE second_unit.variables.curse_image_size_width $steppe_cursesize_calc_width}
    {VARIABLE second_unit.variables.curse_image_size_height $steppe_cursesize_calc_height}

    [unstore_unit]
        variable=second_unit
        find_vacant=no
        text=$tmp_cursed_text
        red,green,blue=30,200,0
    [/unstore_unit]

    [object]
        silent=yes
        duration=scenario

        [filter]
            id=$second_unit.id
        [/filter]

        [effect]
            apply_to=new_ability
            [abilities]
            {ABILITY_STEPPE_CURSE_OF_NATURE}
            [/abilities]
        [/effect]
    [/object]
    [unit_overlay]
        id=$second_unit.id
        image="misc/overlay-curseofnature.png~SCALE($second_unit.variables.curse_image_size_width|,$second_unit.variables.curse_image_size_height|)"
    [/unit_overlay]

    [clear_variable]
        name=tmp_cursed_text
    [/clear_variable]
[/event]

[event]
    name=defender_hits
    id=steppe_curse_of_nature_event2
    first_time_only=no

    [filter_second_attack]
        special_id=steppe_curse_of_nature
    [/filter_second_attack]

    [filter]
        [not]
            ability=stepped_cursed_curse_of_nature
        [/not]
    [/filter]

    [set_variable]
         name=tmp_cursed_text
         value= _ "curse of nature"
    [/set_variable]

    {STEPPE_LUA_CALCULATE_UNIT_SPRITE_SIZE unit steppe_cursesize_calc_width steppe_cursesize_calc_height}

    {VARIABLE unit.variables.curse_image_size_width $steppe_cursesize_calc_width}
    {VARIABLE unit.variables.curse_image_size_height $steppe_cursesize_calc_height}

    [unstore_unit]
        variable=unit
        find_vacant=no
        text=$tmp_cursed_text
        red,green,blue=30,200,0
    [/unstore_unit]

    [object]
        silent=yes
        duration=scenario

        [filter]
            id=$unit.id
        [/filter]

        [effect]
            apply_to=new_ability
            [abilities]
            {ABILITY_STEPPE_CURSE_OF_NATURE}
            [/abilities]
        [/effect]
    [/object]
    [unit_overlay]
        id=$unit.id
        image="misc/overlay-curseofnature.png~SCALE($unit.variables.curse_image_size_width|,$unit.variables.curse_image_size_height|)"
    [/unit_overlay]

    [clear_variable]
        name=tmp_cursed_text
    [/clear_variable]
[/event]

[event]
    name=side turn end
    id=steppe_curse_of_nature_event3
    first_time_only=no

    [store_unit]
        [filter]
            side=$side_number
            ability=stepped_cursed_curse_of_nature
        [/filter]
        variable=steppe_curseofnatured
        kill=no
    [/store_unit]

    {GSE_DEPRECATED_MACRO_FOREACH steppe_curseofnatured i}
    [remove_unit_overlay]
        id=$steppe_curseofnatured[$i].id
        image="misc/overlay-curseofnature.png~SCALE($steppe_curseofnatured[$i].variables.curse_image_size_width|,$steppe_curseofnatured[$i].variables.curse_image_size_height|)"
    [/remove_unit_overlay]
    [object]
        silent=yes
        duration=scenario

        [filter]
            id=$steppe_curseofnatured[$i].id
        [/filter]

        [effect]
            apply_to=remove_ability
            [abilities]
            {ABILITY_STEPPE_CURSE_OF_NATURE}
            [/abilities]
        [/effect]
    [/object]    
    {GSE_DEPRECATED_MACRO_NEXT i}

    {CLEAR_VARIABLE steppe_curseofnatured}
[/event]

[event]
    name=die,steppe_customevent_changeside
    id=steppe_curse_of_nature_event_changeside
    first_time_only=no

    [filter]
        ability=stepped_cursed_curse_of_nature
    [/filter]

    [remove_unit_overlay]
        id=$unit.id
        image="misc/overlay-curseofnature.png~SCALE($unit.variables.curse_image_size_width|,$unit.variables.curse_image_size_height|)"
    [/remove_unit_overlay]
    [object]
        silent=yes
        duration=scenario

        [filter]
            id=$unit.id
        [/filter]

        [effect]
            apply_to=remove_ability
            [abilities]
            {ABILITY_STEPPE_CURSE_OF_NATURE}
            [/abilities]
        [/effect]
    [/object]    

[/event]

[event]
    name=attacker hits
    id=steppe_curse_of_nature_onhit1
    first_time_only=no
   
    [filter_second]
        ability=stepped_cursed_curse_of_nature
    [/filter_second]

        [heal_unit]
            [filter]
                id=$unit.id
            [/filter]
            amount="$($damage_inflicted| * 0.5)"
            animate=yes
            restore_statuses=no
        [/heal_unit]
[/event]

[event]
    name=defender hits
    id=steppe_curse_of_nature_onhit2
    first_time_only=no
   
    [filter]
        ability=stepped_cursed_curse_of_nature
    [/filter]

        [heal_unit]
            [filter]
                id=$second_unit.id
            [/filter]
            amount="$($damage_inflicted| * 0.5)"
            animate=yes
            restore_statuses=no
        [/heal_unit]
[/event]
[+attack]
# wmlindent: start ignoring

[+specials]
# wmlxgettext: [/specials]
# wmlxgettext: [/attack]
# wmlindent: stop ignoring
#enddef



#define WEAPON_SPECIAL_STEPPE_EVILEYED
    [chance_to_hit]
        id=steppe_evileyed
        name=_"evil eye"
        description=_"This attack's chance to hit is reduced by 20%."
        sub=20
        cumulative=yes
    [/chance_to_hit]
#enddef

#define WEAPON_SPECIAL_STEPPE_EVIL_EYE
# wmlindent: start ignoring
# wmlxgettext: [attack]
# wmlxgettext: [specials]

# wmlindent: stop ignoring
    [dummy]
        id=steppe_evileye
        name=_"evil eye"
        description=_"On hit, this reduces the enemy's chance to hit by 20% on all attacks for 1 turn."
    [/dummy]

[/specials]
# wmlindent: start ignoring
[/attack]
# wmlindent: stop ignoring

[event]
    name=attacker_hits
    id=steppe_evil_eye_event1
    first_time_only=no

    [filter_attack]
        special_id=steppe_evileye
    [/filter_attack]

    [filter_second]
        [not]
            ability=steppe_evileyed
        [/not]
    [/filter_second]

    [set_variable]
         name=tmp_cursed_text
#ifdef OGRE_RUSSIAN
         value= _ "сглаз"
#else
         value= _ "evil eye"
#endif
    [/set_variable]

    {STEPPE_LUA_CALCULATE_UNIT_SPRITE_SIZE second_unit steppe_cursesize_calc_width steppe_cursesize_calc_height}

    {VARIABLE second_unit.variables.curse_image_size_width $steppe_cursesize_calc_width}
    {VARIABLE second_unit.variables.curse_image_size_height $steppe_cursesize_calc_height}

    [unstore_unit]
        variable=second_unit
        find_vacant=no
        text=$tmp_cursed_text
        red,green,blue=150,150,150
    [/unstore_unit]

    [object]
        silent=yes
        duration=turn end

        [filter]
            id=$second_unit.id
        [/filter]

        [effect]
            apply_to=attack
            [set_specials]
                mode=append
                {WEAPON_SPECIAL_STEPPE_EVILEYED}
            [/set_specials]
        [/effect]
    [/object]
    [object]
        silent=yes
        duration=scenario

        [filter]
            id=$second_unit.id
        [/filter]

        [effect]
            apply_to=new_ability
            [abilities]
              [dummy]
                 id=steppe_evileyed
              [/dummy]
            [/abilities]
        [/effect]
    [/object]
    [unit_overlay]
        id=$second_unit.id
        image="misc/overlay-evileye.png~SCALE($second_unit.variables.curse_image_size_width|,$second_unit.variables.curse_image_size_height|)"
    [/unit_overlay]

    [clear_variable]
        name=tmp_cursed_text
    [/clear_variable]
[/event]

[event]
    name=defender_hits
    id=steppe_evil_eye_event2
    first_time_only=no

    [filter_second_attack]
        special_id=steppe_evileye
    [/filter_second_attack]

    [filter]
        [not]
            ability=steppe_evileyed
        [/not]
    [/filter]

    [set_variable]
         name=tmp_cursed_text
         value= _ "evil eye"
    [/set_variable]

    {STEPPE_LUA_CALCULATE_UNIT_SPRITE_SIZE unit steppe_cursesize_calc_width steppe_cursesize_calc_height}

    {VARIABLE unit.variables.curse_image_size_width $steppe_cursesize_calc_width}
    {VARIABLE unit.variables.curse_image_size_height $steppe_cursesize_calc_height}

    [unstore_unit]
        variable=unit
        find_vacant=no
        text=$tmp_cursed_text
        red,green,blue=150,150,150
    [/unstore_unit]

    [object]
        silent=yes
        duration=turn end

        [filter]
            id=$unit.id
        [/filter]

        [effect]
            apply_to=attack
            [set_specials]
                mode=append
                {WEAPON_SPECIAL_STEPPE_EVILEYED}
            [/set_specials]
        [/effect]
    [/object]
    [object]
        silent=yes
        duration=scenario

        [filter]
            id=$unit.id
        [/filter]

        [effect]
            apply_to=new_ability
            [abilities]
              [dummy]
                 id=steppe_evileyed
              [/dummy]
            [/abilities]
        [/effect]
    [/object]
    [unit_overlay]
        id=$unit.id
        image="misc/overlay-evileye.png~SCALE($unit.variables.curse_image_size_width|,$unit.variables.curse_image_size_height|)"
    [/unit_overlay]

    [clear_variable]
        name=tmp_cursed_text
    [/clear_variable]
[/event]

[event]
    name=side turn end
    id=steppe_evileye_event3
    first_time_only=no

    [store_unit]
        [filter]
            side=$side_number
            ability=steppe_evileyed
        [/filter]
        variable=steppe_evileyed
    [/store_unit]

    {GSE_DEPRECATED_MACRO_FOREACH steppe_evileyed i}
    [remove_unit_overlay]
        id=$steppe_evileyed[$i].id
        image="misc/overlay-evileye.png~SCALE($steppe_evileyed[$i].variables.curse_image_size_width|,$steppe_evileyed[$i].variables.curse_image_size_height|)"
    [/remove_unit_overlay]
    [object]
        silent=yes
        duration=scenario

        [filter]
            id=$steppe_evileyed[$i].id
        [/filter]

        [effect]
            apply_to=remove_ability
            [abilities]
              [dummy]
                 id=steppe_evileyed
              [/dummy]
            [/abilities]
        [/effect]
    [/object]    
    {GSE_DEPRECATED_MACRO_NEXT i}

    {CLEAR_VARIABLE steppe_evileyed}
[/event]

[+attack]
# wmlindent: start ignoring

[+specials]
# wmlxgettext: [/specials]
# wmlxgettext: [/attack]
# wmlindent: stop ignoring
#enddef

#define ABILITY_STEPPE_QUEEN_OF_WOLVES
#ability for Hunn wolves, translate later
    [leadership]
        id=steppe_queen_of_wolves
        value=25
        cumulative=no
        name=_"queen of wolves"
        description=_"Adjacent allied wolves deal 25% more damage. If this unit is selected as leader (doesn't work if advanced into), she can recruit Fear Manifestations, and 2 Fear Shadows are added to the recall list (costing 9 gold)."
        affect_self=no
        affect_allies=yes
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
            [filter]
                race=wolf
                [or]
                    ability=steppe_wolf
                [/or]
            [/filter]
        [/affect_adjacent]
    [/leadership]
    #note: the recruitment code is handled in the eventloader
    # wmlxgettext: [abilities]
[/abilities]
[event]
    name=side turn 1
    id=steppe_hunn_wildwitch_event
    first_time_only=no
    [allow_extra_recruit]
        ability=steppe_queen_of_wolves
        extra_recruit=Hunn_Fear_Manifestation
    [/allow_extra_recruit]
    [if]
    [have_unit]
        ability=steppe_queen_of_wolves
        side=$side_number
        canrecruit=yes
    [/have_unit]
    [then]
    {REPEAT 2 (
    [unit]
        type=Hunn_Fear_Shadow
        side=$side_number
        x,y=recall,recall
        random_name=yes
        random_traits=yes
        random_gender=yes
        recall_cost=9
        [modifications]
    [object]
        silent=yes
        duration=scenario
        [effect]
            apply_to=new_ability
            [abilities]
              [dummy]
              #using the same ability that kanavars use
                 id=steppe_birthed_recalled #for reverting the recall cost back to 20 later on
              [/dummy]
            [/abilities]
        [/effect]
    [/object]
        [/modifications]
    [/unit]
    )}
    [/then]
    [/if]
[/event]
[+abilities]
    # wmlxgettext: [/abilities]
#enddef

#define ABILITY_STEPPE_DEVOURER_OF_SOULS
#using a custom tag name for lua filtering
    [devourer_of_souls]
        id=steppe_devourer_of_souls
        name=_"devourer of souls"
        description=_"Whenever this unit kills an enemy, he absorbs an amount of souls equal to the level of the killed unit (10 souls max). If the unit absorbs souls when at max souls, he gains +1 max hp per excess soul instead. If this is unit is killed and has 5 or more souls, he revives with 50% hp, teleports to his side's leader (or an ally leader if teleporting to the leader is not an option), and loses 5 souls."
    [/devourer_of_souls]
    # wmlxgettext: [abilities]
[/abilities]
[event]
    id=steppe_hunn_devourer_of_souls_event
    name=die
    first_time_only=no

    [filter]
    [not]
        ability=steppe_notrigger_onkill_abilities
        [or]
           level=0
        [/or]
    [/not]
    [/filter]

    [filter_second]
        ability=steppe_devourer_of_souls
        [not]
            ability=steppe_notrigger_onkill_abilities
        [/not]
    [/filter_second]

    [sound]
      name=magic-dark.ogg
    [/sound]
    [sound]
      name=magic-faeriefire.ogg
    [/sound]
    [sound]
      name=wail-long.wav
    [/sound]

    {VARIABLE tmp_souls_gained $unit.level}

    {VARIABLE_OP second_unit.variables.collected_souls add $unit.level}

    {IF_VAR second_unit.variables.collected_souls greater_than_equal_to 10 (
    [then]
    {VARIABLE tmp_hp_buff $second_unit.variables.collected_souls}
    {VARIABLE_OP tmp_hp_buff sub 10}
    {VARIABLE second_unit.variables.collected_souls 10}
    [/then]
    )}
 
        [unstore_unit]
            variable=second_unit
            text=_"soul devoured"
            red=200
            green=0
            blue=255
            find_vacant=no
        [/unstore_unit]  
    {IF_VAR tmp_hp_buff greater_than 0 (
    [then]  
    [object]
        silent=yes
        duration=forever

        [filter]
            id=$second_unit.id
        [/filter]

        [effect]
            apply_to=hitpoints
            increase_total=$tmp_hp_buff
            increase=$tmp_hp_buff
        [/effect]
    [/object]
    [/then]
    )}
    {CLEAR_VARIABLE tmp_hp_buff}
[/event]
[event]
    name=last breath
    id=steppe_hunn_devourer_of_souls_revive_event
    first_time_only=no
    [filter]
        ability=steppe_devourer_of_souls
        [not]
            ability=steppe_notrigger_onkill_abilities
        [/not]
    [/filter]

#todo: change this to be greaten than 5, and reduce the souls by 10
    {IF_VAR unit.variables.collected_souls greater_than_equal_to 5 (
    [then]

    {VARIABLE_OP unit.variables.collected_souls sub 5}
    {VARIABLE unit.hitpoints 0}
    [unstore_unit]
        variable=unit
        find_vacant=no
    [/unstore_unit]

        [heal_unit]
            [filter]
                id=$unit.id
            [/filter]
            amount="$($unit.max_hitpoints| * 0.5)"
            animate=yes
            restore_statuses=no
        [/heal_unit]
    {MODIFY_UNIT id=$unit.id moves 0}
    {MODIFY_UNIT id=$unit.id attacks_left 0}
        [sound]
            name=magic-dark-big.ogg
        [/sound]

#move the revived unit to his side's leader

        [store_unit]
            [filter]
                side=$unit.side
                canrecruit=yes
                [not]
                   id=$unit.id
                [/not]
            [/filter]
            variable=steppe_hunn_leader
            kill=no
        [/store_unit]

        [store_locations]
           x,y=$steppe_hunn_leader.x,$steppe_hunn_leader.y
           variable=steppe_demonrevive_loc
        [/store_locations]

        [if]
        [variable]
            name=steppe_demonrevive_loc.length
            greater_than=0
        [/variable]
        [else]
#if no leader found, or if the devourer of souls is a leader himself, telepeport to an ally leader
        [store_unit]
            [filter]
                canrecruit=yes
                [filter_side]
                [allied_with]
                    side=$unit.side
                [/allied_with]
                [/filter_side]
                [not]
                   id=$unit.id
                [/not]
            [/filter]
            variable=steppe_hunn_leader
            kill=no
        [/store_unit]

        [store_locations]
           x,y=$steppe_hunn_leader.x,$steppe_hunn_leader.y
           variable=steppe_demonrevive_loc
        [/store_locations]
        [/else]
        [/if]

        [if]
        [variable]
            name=steppe_demonrevive_loc.length
            greater_than=0
        [/variable]
        [then]
        [teleport]
           [filter]
               id=$unit.id
           [/filter]
           animate=yes
           x,y=$steppe_hunn_leader.x,$steppe_hunn_leader.y
           check_passability=yes
           clear_shroud=yes
        [/teleport]
        [/then]
        [/if]
        {CLEAR_VARIABLE steppe_demonrevive_loc}

        {CLEAR_VARIABLE steppe_hunn_leader}
    [/then])}
[/event]
[+abilities]
    # wmlxgettext: [/abilities]
#enddef
# wmllint: unbalanced-off


#define ABILITY_STEPPE_SOUL_BURST
#using a custom tag name for lua filtering
    [dummy]
        id=steppe_soul_burst
        name=_"soul burst"
        description=_"Whenever this attack kills an enemy, adjacent enemies take arcane damage equal to the exp you get from killing an enemy (8 for lvl1, 16 for lvl2, 24 for lvl3, etc.)."
    [/dummy]
    # wmlxgettext: [abilities]
[/abilities]
[event]
    id=steppe_hunn_soul_burst_event
    name=die
    first_time_only=no

    [filter]
    [not]
        ability=steppe_notrigger_onkill_abilities
    [/not]
    [/filter]

    [filter_second]
        ability=steppe_soul_burst
        [not]
            ability=steppe_notrigger_onkill_abilities
        [/not]
    [/filter_second]

    {IF_VAR steppe_soulburst_activated not_equals yes (
    [then]

#this is to prevent an infinite loop when a unit is killed by the soul burst
    {VARIABLE steppe_soulburst_activated yes}

#fake attack animation, for the soul burst effect
    [animate_unit]
        flag=soulburst
        [filter]
            id=$second_unit.id
        [/filter]
        [facing]
            x,y=$x1,$y1
        [/facing]
        hits=yes
    [/animate_unit]

    {VARIABLE tmp_soulburst_damage $unit.level}

    {IF_VAR tmp_soulburst_damage equals 0 (
    [then]
        {VARIABLE tmp_soulburst_damage 4}
    [/then]
    [else]
        {VARIABLE_OP tmp_soulburst_damage multiply 8}
    [/else]
    )}

    [harm_unit]
        [filter]
            [filter_adjacent]
                id=$unit.id
            [/filter_adjacent]
            [filter_side]
                [enemy_of]
                    side=$second_unit.side
                [/enemy_of]
            [/filter_side]
        [/filter]
        [filter_second]
            id=$second_unit.id
        [/filter_second]
#        amount="$($second_weapon.damage * $second_weapon.number * 0.25)"
        amount="$tmp_soulburst_damage"
#        alignment=$thundershaman[$e].alignment
        damage_type=arcane
        experience=yes
        fire_event=yes
        animate=yes
    [/harm_unit]

    {CLEAR_VARIABLE tmp_soulburst_damage}

    [/then])}
[/event]
[event]
    id=steppe_hunn_soul_burst_clear_event
    name=attack end
    first_time_only=no
#    [filter]
#        ability=steppe_soul_burst
#    [/filter]
    {CLEAR_VARIABLE steppe_soulburst_activated}
[/event]
[+abilities]
    # wmlxgettext: [/abilities]
#enddef
# wmllint: unbalanced-off


#define ABILITY_STEPPE_CONTAINER_OF_DARKNESS_HEALS VALUE FORMULA1 FORMULA2
    [heals]
        value={VALUE}
#        id=healingsteppe{VALUE}
        id=containerofdarkness_heal
        affect_allies=yes
#        name=_"container of darkness +{VALUE}" "вместитилище тьмы +{VALUE}"}
#so the ability is invisible when inactive:
        name_inactive=""
#        description=_"This unit heals adjacent undead units. The healing amount starts at +2hp and heals 1 more for each 10% hp the unit lost (+12 max)."
        affect_self=no
        poison=slowed
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
            [and]
                trait=undead#so it works on vampires/other add-ons' custom undead races
            [/and]
        [/affect_adjacent]
        [filter]
            formula={FORMULA1}
            [and]
                formula={FORMULA2}
            [/and]
        [/filter]
    [/heals]
#enddef

#define ABILITY_STEPPE_CONTAINER_OF_DARKNESS_UNUSED
    [dummy]
        id=steppe_container_of_darkness
        name=_"container of darkness"
        description=_"This unit heals adjacent undead units. The healing amount starts at +2hp and heals 1 more for each 10% hp the unit lost (+2 when at fully hp, +3 when at/above 90% hp, +4 when at/above 80% hp, etc. up to +12 max)."
     [/dummy]

{ABILITY_STEPPE_CONTAINER_OF_DARKNESS_HEALS 2 "(self.hitpoints >= self.max_hitpoints)" "(self.hitpoints >= self.max_hitpoints)"}

{ABILITY_STEPPE_CONTAINER_OF_DARKNESS_HEALS 3 "(self.hitpoints < self.max_hitpoints)" "(self.hitpoints >= self.max_hitpoints * 0.9)"}

{ABILITY_STEPPE_CONTAINER_OF_DARKNESS_HEALS 4 "(self.hitpoints < self.max_hitpoints * 0.9)" "(self.hitpoints >= self.max_hitpoints * 0.8)"}

{ABILITY_STEPPE_CONTAINER_OF_DARKNESS_HEALS 5 "(self.hitpoints < self.max_hitpoints * 0.8)" "(self.hitpoints >= self.max_hitpoints * 0.7)"}

{ABILITY_STEPPE_CONTAINER_OF_DARKNESS_HEALS 6 "(self.hitpoints < self.max_hitpoints * 0.7)" "(self.hitpoints >= self.max_hitpoints * 0.6)"}

{ABILITY_STEPPE_CONTAINER_OF_DARKNESS_HEALS 7 "(self.hitpoints < self.max_hitpoints * 0.6)" "(self.hitpoints >= self.max_hitpoints * 0.5)"}

{ABILITY_STEPPE_CONTAINER_OF_DARKNESS_HEALS 8 "(self.hitpoints < self.max_hitpoints * 0.5)" "(self.hitpoints >= self.max_hitpoints * 0.4)"}

{ABILITY_STEPPE_CONTAINER_OF_DARKNESS_HEALS 9 "(self.hitpoints < self.max_hitpoints * 0.4)" "(self.hitpoints >= self.max_hitpoints * 0.3)"}

{ABILITY_STEPPE_CONTAINER_OF_DARKNESS_HEALS 10 "(self.hitpoints < self.max_hitpoints * 0.3)" "(self.hitpoints >= self.max_hitpoints * 0.2)"}

{ABILITY_STEPPE_CONTAINER_OF_DARKNESS_HEALS 11 "(self.hitpoints < self.max_hitpoints * 0.2)" "(self.hitpoints >= self.max_hitpoints * 0.1)"}

{ABILITY_STEPPE_CONTAINER_OF_DARKNESS_HEALS 12 "(self.hitpoints < self.max_hitpoints * 0.1)" "(self.hitpoints < self.max_hitpoints * 0.1)"}
#enddef

#define WEAPON_SPECIAL_STEPPE_ABSORB_POWER
#Dummy special that applies a screenshake effect when the attack hits
# wmlxgettext: [specials]
    [dummy]
        id=steppe_absorb_power
        name=_"absorb power"
        description= _"Whenever this attack kills an enemy, the attack's damage is permanently increased by the enemy's level."
    [/dummy]
[/specials]
# wmlindent: start ignoring
[/attack]
# wmlindent: stop ignoring

[event]
    name=die
    id=steppe_absorb_power
    first_time_only=no

    [filter_second_attack]
        special_id=steppe_absorb_power
    [/filter_second_attack]

    [if]
    {VARIABLE_CONDITIONAL unit.level greater_than 0}
    [then]

    [sound]
        name=magic-dark-big.ogg
    [/sound]

    [floating_text]
       x,y=$x2,$y2
       text=_"<span color='#c800ff'>+$unit.level| damage</span>"
    [/floating_text]

    [object]
        silent=yes
        duration=forever

        [filter]
            id=$second_unit.id
        [/filter]

        [effect]
            apply_to=attack
            name=$second_weapon.name
            increase_damage=$unit.level
        [/effect]
    [/object]

    [/then]
    [/if]

[/event]
[+attack]
# wmlindent: start ignoring

[+specials]
# wmlxgettext: [/specials]
# wmlxgettext: [/attack]
# wmlindent: stop ignoring
#enddef

#define ABILITY_STEPPE_SOUL_THRALLS
#the unit has a chance to defect
    [dummy]
        id=steppe_soul_thralls
        name=_"enslaver of souls"
        description= _"When a living unit (either ally or enemy) dies in a 2-tile radius from this unit, they are revived as a soul thrall of the resurrecting unit's side. Soul thralls have -40% damage/max hitpoints/exp/max exp, their level is reduced by 1, and the alignment changes to chaotic. If a dying unit is the radius of both an ally and enemy unit with this ability, the ally takes priority."
    [/dummy]
     # wmlxgettext: [abilities]
[/abilities]
[event]
    name=die
    id=steppe_hunn_soul_thralls_event
    first_time_only=no
    [filter]
        [not]
            [filter_wml]
                [status]
                    not_living="yes"
                [/status]
            [/filter_wml]
        [/not]
        [filter_location]
            [filter]
                ability=steppe_soul_thralls
#            [filter_side]
#            [allied_with]
#                side=$unit.side
#            [/allied_with]
#            [/filter_side]
            [not]
                id=$unit.id #to prevent the unit from self-reviving
            [/not]
            [/filter]
            radius=2
        [/filter_location]
    [/filter]

#do several different [store_unit]s by priority: if there is a resurrecter of same side, use him, if not, check if there is an ally resurrecter, if not, pick any including enemy

    [store_unit]
        [filter]
            side=$unit.side
            ability=steppe_soul_thralls
            [filter_location]
                x,y=$x1,$y1
                radius=2
            [/filter_location]
        [/filter]
        variable=steppe_shade_resurrecter
        kill=no
    [/store_unit]

    {IF_VAR steppe_shade_resurrecter.length greater_than 0 (
    [else]
    [store_unit]
        [filter]
            ability=steppe_soul_thralls
            [filter_side]
            [allied_with]
                side=$unit.side
            [/allied_with]
            [/filter_side]
            [filter_location]
                x,y=$x1,$y1
                radius=2
            [/filter_location]
        [/filter]
        variable=steppe_shade_resurrecter
        kill=no
    [/store_unit]
    [/else]
    )}

    {IF_VAR steppe_shade_resurrecter.length greater_than 0 (
    [else]
    [store_unit]
        [filter]
            ability=steppe_soul_thralls
            [filter_location]
                x,y=$x1,$y1
                radius=2
            [/filter_location]
        [/filter]
        variable=steppe_shade_resurrecter
        kill=no
    [/store_unit]
    [/else]
    )}

    [if]
    [have_unit]
        id=$steppe_shade_resurrecter[0].id
    [/have_unit]
    [then]

    [sound]
        name=magic-dark-big.ogg
    [/sound]

    {VARIABLE unit.side $steppe_shade_resurrecter[0].side}
    {IF_VAR unit.level greater_than 0 (
    [then]
    {VARIABLE_OP unit.level sub 1}
    [/then]
    )}
    [unstore_unit]
        variable=unit
        find_vacant=no
    [/unstore_unit]

    [modify_unit]
        [filter]
            id=$unit.id
            [not]
                trait=undead
            [/not]
        [/filter]
        {TRAIT_UNDEAD}
    [/modify_unit]

        [heal_unit]
            [filter]
                id=$unit.id
            [/filter]
            amount=full
            animate=no
            restore_statuses=yes
        [/heal_unit]


    #if the unit was in a cage before death, free it from the cage:

    {STEPPE_FREEUNIT $x1 $y1}

    #if the unit was a slave before death, "free" the unit:

    [if]
    [have_unit]
        id=$unit.id
        ability=steppe_slave
    [/have_unit]
    [then]
    {STEPPE_FREESLAVE $x1 $y1 $steppe_shade_resurrecter[0].side}
    [/then]
    [/if]

    [object]
        silent=yes
        duration=forever

        [filter]
            id=$unit.id
        [/filter]

        [effect]
            apply_to=hitpoints
            increase=-40%
            increase_total=-40%
        [/effect]        

        [effect]
            apply_to=attack
            increase_damage=-40%
        [/effect]

        [effect]
            apply_to=new_ability
            [abilities]
                [dummy]
                    id=steppe_shade#for reducing level on post advance
                [/dummy]
            [/abilities]
        [/effect]

        [effect]
            apply_to=alignment
            set=chaotic
        [/effect]

        [effect]
            apply_to=image_mod
            add="~GS()~BLEND(125,0,125,0.4)~O(50%)"
        [/effect]

        [effect]
            apply_to=experience
            increase=-40%
        [/effect]

        [effect]
            apply_to=max_experience
            increase=-40%
        [/effect]

    [/object]

#    [animate_unit]
#        flag=revive
#        [filter]
#            id=$steppe_patriarch[0].id
#        [/filter]
#        [filter_second]
#            id=$unit.id
#        [/filter_second]
#        [facing]
#            x,y=$x1,$y1
#        [/facing]
#    [/animate_unit]

    [/then]
    [/if]

    {CLEAR_VARIABLE steppe_shade_resurrecter}
[/event]
#event to ensure amlas don't reduce soul level
[event]
    name=pre advance
    id=steppe_shade_reduce_level_pre
    first_time_only=no
    [filter]
        ability=steppe_shade
        [not]
            [filter_wml]
                advances_to=""
            [/filter_wml]
        [/not]
    [/filter]
    {VARIABLE tmp_steppe_reduce_soul_level yes}
[/event]
#reduces shade level by 1 during post advance, as variable changes don't persist on levelup:
[event]
    name=post advance
    id=steppe_shade_reduce_level
    first_time_only=no
    [filter]
        ability=steppe_shade
    [/filter]

    {IF_VAR unit.level greater_than 0 (
    [and]
    {VARIABLE_CONDITIONAL tmp_steppe_reduce_soul_level equals yes}
    [/and]
    [then]
    {VARIABLE_OP unit.level sub 1}
    [/then]
    )}

    [unstore_unit]
        variable=unit
        find_vacant=no
    [/unstore_unit]

    {CLEAR_VARIABLE tmp_steppe_reduce_soul_level}
[/event]

[+abilities]
#enddef

#define STEPPE_TRANSFORMIMMUNE_FILTER
[not]
    [filter_wml]
        [status]
            not_living="yes"
        [/status]
    [/filter_wml]
#    ability=steppe_building
[/not]
[not]
    ability=steppe_dummy_transformed_by_curse
[/not]
#enddef

#macro to be used in AMLAs, without events
#define STEPPE_CURSE_OF_TRANSFORMATION LEVEL
    [curse_of_transformation]
        id=steppe_curse_of_transformation
        name=_"curse of transformation "+" {LEVEL}"
        description=_"On hit, if the enemy's level is "+{LEVEL}+_" or lower, the enemy is transformed into a random animal of the same level until the end of the unit's next turn. Only works on living enemies."
        level={LEVEL}
    [/curse_of_transformation]
#UNUSED: no longer needed in 1.16.5 and after, since the crash bug is fixed. besides, the attack is now no-counter too
#    #the unit is petrified, to avoid crashes (since wesnoth crashes if for example a unit with a ranged attack is transformed into a unit with only melee, while in the middle of combat)
#    [petrifies]
#        id=steppe_curse_of_transformation_petrify
#        [filter_opponent]
#            {STEPPE_TRANSFORMIMMUNE_FILTER}
#        [/filter_opponent]
#    [/petrifies]
#enddef

#define WEAPON_SPECIAL_STEPPE_CURSE_OF_TRANSFORMATION LEVEL
# wmlindent: start ignoring
# wmlxgettext: [attack]
# wmlxgettext: [specials]

# wmlindent: stop ignoring
    {STEPPE_CURSE_OF_TRANSFORMATION {LEVEL}}
[/specials]
# wmlindent: start ignoring
[/attack]
# wmlindent: stop ignoring

[event]
    name=attacker_hits
    id=steppe_curse_of_transformation_event
    first_time_only=no

    [filter_attack]
        special_id=steppe_curse_of_transformation
    [/filter_attack]

    [filter_second]
        {STEPPE_TRANSFORMIMMUNE_FILTER}
    [/filter_second]

#    [chat]
#        message=_"transform event triggered"
#    [/chat]

    {IF_VAR second_unit.level less_than_equal_to $weapon.specials.curse_of_transformation.level (
    [then]

#    [chat]
#        message=_"transform level filter passed"
#    [/chat]

        {IF_VAR second_unit.level equals 0 (
        [then]
            {VARIABLE_OP tmp_transformtype rand "Giant Rat","Giant Ant","Giant Scorpling"}
        [/then]
        )}

        {IF_VAR second_unit.level equals 1 (
        [then]
            {VARIABLE_OP tmp_transformtype rand "Fire Ant","Giant Scorpion","Wolf"}
        [/then]
        )}

        {IF_VAR second_unit.level equals 2 (
        [then]
            {VARIABLE_OP tmp_transformtype rand "Great Wolf"}
        [/then]
        )}

        {IF_VAR second_unit.level equals $emptyvar (
        [then]
            {VARIABLE tmp_transformtype "Giant Rat"}
            [chat]
                message=_"ERROR: there is no transform list for units of this level, transforming into rat as a failsafe"
            [/chat]
        [/then]
        )}

        #TODO: make it keep HP proportionally when transforming/untransforming

        [event]
            name=side turn end
            delayed_variable_substitution=no
            [filter_condition]
                {VARIABLE_CONDITIONAL side_number equals $second_unit.side}
            [/filter_condition]
            {TRANSFORM_UNIT id=$second_unit.id $second_unit.type}
            [object]
                silent=yes
                duration=scenario
                [filter]
                    id=$second_unit.id
                [/filter]
                [effect]
                    apply_to=remove_ability
                    [abilities]
                        [dummy]
                            id=steppe_dummy_transformed_by_curse
                        [/dummy]
                    [/abilities]
                [/effect]
            [/object]
        [/event]

        #UPD: this is now handled via [petrifies] tag
        #UPD2: this is no longer needed
#        [petrify]
#            id=$second_unit.id
#        [/petrify]

    [/then]
    [else]
        #TODO: add a floating text message saying "cannot transform"
    [/else]
    )}

[/event]

[event]
    name=attack end
    id=steppe_curse_of_transformation_event_end
    first_time_only=no

    [filter_attack]
        special_id=steppe_curse_of_transformation
    [/filter_attack]
    [filter_second]
        {STEPPE_TRANSFORMIMMUNE_FILTER}
    [/filter_second]

    {IF_VAR tmp_transformtype not_equals $emptyvar (
    [then]

    [object]
        silent=yes
        duration=scenario
        [filter]
            id=$second_unit.id            
        [/filter]
        [effect]
            apply_to=new_ability
            [abilities]
                [dummy]
                    id=steppe_dummy_transformed_by_curse
                [/dummy]
            [/abilities]
        [/effect]
    [/object]

    {TRANSFORM_UNIT id=$second_unit.id $tmp_transformtype}

#    [unpetrify]
#        id=$second_unit.id
#    [/unpetrify]

    [/then]
    )}

    {CLEAR_VARIABLE tmp_transformtype}
[/event]

[+attack]
# wmlindent: start ignoring

[+specials]
# wmlxgettext: [/specials]
# wmlxgettext: [/attack]
# wmlindent: stop ignoring
#enddef