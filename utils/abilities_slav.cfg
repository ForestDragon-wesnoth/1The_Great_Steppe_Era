#textdomain wesnoth-gse

#define ABILITY_SLAVFACTION
    [dummy]
        id=slavfaction
    [/dummy]
#enddef

#define ABILITY_SLAV_KRAD
    [dummy]
        id=slav_krad
    [/dummy]
#enddef

#define ABILITY_SLAV_TEMSK
    [dummy]
        id=slav_temsk
    [/dummy]
#enddef

#define ABILITY_SLAV_NOVGOROD
    [dummy]
        id=slav_novgorod
    [/dummy]
#enddef


#define ABILITY_STEPPE_SWAMPSTALK
    [hides]
        id=steppe_swampstalk
        name=_"swampstalk"
        description=_"This unit is invisible on swamp terrain."
        affect_self=yes
        [filter]
            [filter_location]
                terrain=Ss^*,St^*,Sm^*
            [/filter_location]
        [/filter]
    [/hides]
#enddef

#define STEPPE_ADAPTIVEARMOR_EVENT ID TYPE VALUE

#changes a resistance to the type by {VALUE}% for a turn
[event]
    name=attacker_hits
    id={ID}
    first_time_only=no

    [filter_attack]
        type={TYPE}
    [/filter_attack]

    [filter_second]
        ability=steppe_adaptive_armor
    [/filter_second]

    {VARIABLE tmp_textvalue {VALUE}}
    {VARIABLE_OP tmp_textvalue multiply -1}

    [store_unit]
        [filter]
            id=$second_unit.id
        [/filter]
        variable=steppe_adaptivearmorunit
        kill=no
    [/store_unit]

    {IF_VAR steppe_adaptivearmorunit.variables.adaptive_armor_stacks greater_than_equal_to 1 (
    [else]
    {VARIABLE steppe_adaptivearmorunit.variables.adaptive_armor_stacks 0}
    [/else]
    )}

    {VARIABLE_OP steppe_adaptivearmorunit.variables.adaptive_armor_stacks add 1}

    [unstore_unit]
        variable=steppe_adaptivearmorunit
        text=_"+$tmp_textvalue|% {TYPE}"
        find_vacant=no
    [/unstore_unit]
#    [chat]
#        message=$second_unit.variables.adaptive_armor_stacks
#    [/chat]


#check if the unit already has adaptive armor variables for that turn, and if so just add the number instead of making a seperate array entry, to reduce bugs
    [if]
    {VARIABLE_CONDITIONAL adaptive_armor_stacks_sub_information.length greater_than 0}
    [then]
    {FOREACH adaptive_armor_stacks_sub_information x}
    {IF_VAR adaptive_armor_stacks_sub_information[$x].id equals $second_unit.id (
    [and]
    {VARIABLE_CONDITIONAL adaptive_armor_stacks_sub_information[$x].turn_of_reducing equals $"($turn_number| + 0)"}
    [/and]
    [then]
    {VARIABLE tmp_adaptive_armor_unit_found yes}
    {VARIABLE_OP adaptive_armor_stacks_sub_information[$x].reduce_by add 1}
    [/then]
    [else]
    [/else]
    )}
    {NEXT x}
    [/then]
    [else]
    {VARIABLE tmp_adaptive_armor_unit_found no}
    [/else]
    [/if]

    {IF_VAR tmp_adaptive_armor_unit_found not_equals yes (
    [then]
    [set_variables]
        name=adaptive_armor_stacks_sub_information
        mode=append
        [value]
            id=$second_unit.id
            side=$second_unit.side
            reduce_by=1
            turn_of_reducing=$"($turn_number| + 0)"
        [/value]
    [/set_variables]
    [/then])}
    {CLEAR_VARIABLE tmp_adaptive_armor_unit_found}

    {CLEAR_VARIABLE tmp_textvalue}
    {CLEAR_VARIABLE steppe_adaptivearmorunit}

    [object]
        silent=yes
        duration=turn end

        [filter]
            x,y=$x2,$y2
        [/filter]

        [effect]
            apply_to=resistance
            replace=no
            [resistance]
                {TYPE}={VALUE}
            [/resistance]
        [/effect]
    [/object]

    [fire_event]
        name=steppe_customevent_adaptivearmor
        [primary_unit]
            id=$second_unit.id
        [/primary_unit]
    [/fire_event]
[/event]

#TODO: fix the defender event not working for some reason

[event]
    name=defender_hits
    id={ID}_defense
    first_time_only=no

    [filter_second_attack]
        type={TYPE}
    [/filter_second_attack]

    [filter]
        ability=steppe_adaptive_armor
    [/filter]

    {VARIABLE tmp_textvalue {VALUE}}
    {VARIABLE_OP tmp_textvalue multiply -1}

    [store_unit]
        [filter]
            id=$unit.id
        [/filter]
        variable=steppe_adaptivearmorunit
        kill=no
    [/store_unit]

    {IF_VAR steppe_adaptivearmorunit.variables.adaptive_armor_stacks greater_than_equal_to 1 (
    [else]
    {VARIABLE steppe_adaptivearmorunit.variables.adaptive_armor_stacks 0}
    [/else]
    )}

    {VARIABLE_OP steppe_adaptivearmorunit.variables.adaptive_armor_stacks add 1}

    [unstore_unit]
        variable=steppe_adaptivearmorunit
        text=_"+$tmp_textvalue|% {TYPE}"
        find_vacant=no
    [/unstore_unit]
#    [chat]
#        message=$unit.variables.adaptive_armor_stacks
#    [/chat]

#check if the unit already has adaptive armor variables for that turn, and if so just add the number instead of making a seperate array entry, to reduce bugs
    [if]
    {VARIABLE_CONDITIONAL adaptive_armor_stacks_sub_information.length greater_than 0}
    [then]
    {FOREACH adaptive_armor_stacks_sub_information x}
    {IF_VAR adaptive_armor_stacks_sub_information[$x].id equals $unit.id (
    [and]
    {VARIABLE_CONDITIONAL adaptive_armor_stacks_sub_information[$x].turn_of_reducing equals $"($turn_number| + 0)"}
    [/and]
    [then]
    {VARIABLE tmp_adaptive_armor_unit_found yes}
    {VARIABLE_OP adaptive_armor_stacks_sub_information[$x].reduce_by add 1}
    [/then]
    [else]
    [/else]
    )}
    {NEXT x}
    [/then]
    [else]
    {VARIABLE tmp_adaptive_armor_unit_found no}
    [/else]
    [/if]

    {IF_VAR tmp_adaptive_armor_unit_found not_equals yes (
    [then]
    [set_variables]
        name=adaptive_armor_stacks_sub_information
        mode=append
        [value]
            id=$unit.id
            side=$unit.side
            reduce_by=1
            turn_of_reducing=$"($turn_number| + 0)"
        [/value]
    [/set_variables]
    [/then])}
    {CLEAR_VARIABLE tmp_adaptive_armor_unit_found}


    {CLEAR_VARIABLE tmp_textvalue}
    {CLEAR_VARIABLE steppe_adaptivearmorunit}

    [object]
        silent=yes
        duration=turn end

        [filter]
            x,y=$x1,$y1
        [/filter]

        [effect]
            apply_to=resistance
            replace=no
            [resistance]
                {TYPE}=-5
            [/resistance]
        [/effect]
    [/object]

    [fire_event]
        name=steppe_customevent_adaptivearmor
        [primary_unit]
            id=$unit.id
        [/primary_unit]
    [/fire_event]
[/event]

[event]
    name=side turn end
    id=steppe_adaptive_armor_stacks_event
    first_time_only=no

    {FOREACH adaptive_armor_stacks_sub_information i}
#    [chat]
#        message=_"id: $adaptive_armor_stacks_sub_information[$i].id| side: $adaptive_armor_stacks_sub_information[$i].side| turn: $adaptive_armor_stacks_sub_information[$i].turn_of_reducing| reduce by: $adaptive_armor_stacks_sub_information[$i].reduce_by|"
#    [/chat]
        [if]
            [variable]
                name=adaptive_armor_stacks_sub_information[$i].turn_of_reducing
                less_than_equal_to=$turn_number
            [/variable]
            [else]
#                [chat]
#                    message="not the right turn yet"
#                [/chat]
            [/else]
            [then]

            [if]
                [variable]
                    name=adaptive_armor_stacks_sub_information[$i].side
                    equals=$side_number
                [/variable]
            [else]
#                [chat]
#                    message="not the right side yet"
#                [/chat]
            [/else]
            [then]
            [if]
            [have_unit]
                    id=$adaptive_armor_stacks_sub_information[$i].id
            [/have_unit]
            [then]
                [store_unit]
                    [filter]
                        id=$adaptive_armor_stacks_sub_information[$i].id
                    [/filter]
                    variable=steppe_adaptivearmorunit
                    kill=no
                [/store_unit]                
                {VARIABLE_OP steppe_adaptivearmorunit.variables.adaptive_armor_stacks sub $adaptive_armor_stacks_sub_information[$i].reduce_by}
                [unstore_unit]
                    variable=steppe_adaptivearmorunit
                    find_vacant=no
                [/unstore_unit]
#                [chat]
#                    message=$steppe_adaptivearmorunit.variables.adaptive_armor_stacks
#                [/chat]
                [clear_variable]
                    name=adaptive_armor_stacks_sub_information[$i]
                [/clear_variable]
                {CLEAR_VARIABLE steppe_adaptivearmorunit}
            [/then]
            [else]
#            [chat]
#                message=_"adaptive armor unit not found"
#            [/chat]
            [/else]
            [/if]
            [/then]
        [/if]
            [/then]
        [/if]
    {NEXT i}
[/event]
#enddef

 #for eventloader, since the ability is applied via [effect] in the mystical smith ability
#define STEPPE_ADAPTIVEARMOR_EVENTS
{STEPPE_ADAPTIVEARMOR_EVENT steppe_adaptivearmor_event_blade blade -5}
{STEPPE_ADAPTIVEARMOR_EVENT steppe_adaptivearmor_event_pierce pierce -5}
{STEPPE_ADAPTIVEARMOR_EVENT steppe_adaptivearmor_event_impact impact -5}
{STEPPE_ADAPTIVEARMOR_EVENT steppe_adaptivearmor_event_fire fire -5}
{STEPPE_ADAPTIVEARMOR_EVENT steppe_adaptivearmor_event_cold cold -5}
{STEPPE_ADAPTIVEARMOR_EVENT steppe_adaptivearmor_event_arcane arcane -5}
#enddef

#define ABILITY_STEPPE_ADAPTIVE_ARMOR
    [adaptive_armor]
        id=steppe_adaptive_armor
        name=_"adaptive armor"
        description= _"Whenever this unit gets hit, they gain +5% resistance to the damage type they were hit with until the end of their next turn."
    [/adaptive_armor]
     # wmlxgettext: [abilities]
[/abilities]
{STEPPE_ADAPTIVEARMOR_EVENTS}
[+abilities]
#enddef

#ability idea: brittle armor: like adaptive armor, but in reverse (each hit lowers the resistance further)


#define ABILITY_STEPPE_RAVENFORM TYPE SPECIES
    [ravenform]
        id=steppe_ravenform
        name=_"raven form"
        description= _"With a rightclick menu, you can transform this unit into a raven. In raven form, you can use the same menu to transform back. A unit can only transform once per turn. AI can use this ability too."
        transform_into={TYPE}
        species={SPECIES}
    [/ravenform]
#enddef

#define STEPPE_SLAV_TRANSFORM_MENU ID TEXT FILTER
    [set_menu_item]
        id=steppe_raven_menu{ID}
        description={TEXT}
        image=attacks/beak.png~SCALE(20,20)
        [show_if]
#        {VARIABLE_CONDITIONAL steppe_disable_calculator_menu not_equals yes}
        [/show_if]

        [filter_location]
            [filter]
                    {FILTER}
                    side=$side_number
                    [not]
                       ability=steppe_raven_alreadytransformed
                    [/not]
            [/filter]
        [/filter_location]
        [command]

        [fire_event]
            name=steppe_customevent_ravenform
            [primary_unit]
                x,y=$x1,$y1
            [/primary_unit]
        [/fire_event]

        [/command]
    [/set_menu_item]
#enddef

#define EVENTLOADER_EVENTS_SLAV
{STEPPE_ADAPTIVEARMOR_EVENTS}
[event]
    name=start
    id=steppe_raven_menu
    first_time_only=no
    {STEPPE_SLAV_TRANSFORM_MENU human_to_raven _"transform into a raven" (
    ability=steppe_ravenform
    [not]
        race=steppe_raven
    [/not]
    )}
    {STEPPE_SLAV_TRANSFORM_MENU raven_to_human _"return to human form"  (
    ability=steppe_ravenform
    race=steppe_raven
    )}

#ifdef STEPPE_ERROR
    [chat]
        message="Error: failed to load test factions" #dummy error
    [/chat]
#endif
[/event]
[event]
    name=steppe_customevent_ravenform
    id=steppe_ravenform_event
    first_time_only=no

    [if]
    [have_unit]
        x,y=$x1,$y1
        [not]
           ability=steppe_raven_alreadytransformed
        [/not]
    [/have_unit]
    [then]

        [store_unit]
            [filter]
                x,y=$x1,$y1
            [/filter]
            variable=steppe_raven_transform_unit
            kill=no
        [/store_unit]

#        [chat]
#            message=$steppe_raven_transform_unit.abilities.ravenform.transform_into
#        [/chat]

        {VARIABLE hpratio $steppe_raven_transform_unit.hitpoints}
        {VARIABLE_OP hpratio divide $steppe_raven_transform_unit.max_hitpoints}
        {VARIABLE mpratio $steppe_raven_transform_unit.moves}
        {VARIABLE_OP mpratio divide $steppe_raven_transform_unit.max_moves}

        [animate_unit]
            flag=transform
            [filter]
                x,y=$x1,$y1
            [/filter]
        [/animate_unit]
        {TRANSFORM_UNIT x,y=$x1,$y1 $steppe_raven_transform_unit.abilities.ravenform.transform_into}
#redraws the fog
        [redraw]
           clear_shroud=yes
        [/redraw]
        {CLEAR_VARIABLE steppe_raven_transform_unit}

        [store_unit]
            [filter]
                x,y=$x1,$y1
            [/filter]
    
            variable=steppe_raven_transform_unit
            kill=no
        [/store_unit]

        {VARIABLE steppe_raven_transform_unit.hitpoints $steppe_raven_transform_unit.max_hitpoints}
        {VARIABLE_OP steppe_raven_transform_unit.hitpoints multiply $hpratio}
        {VARIABLE steppe_raven_transform_unit.moves $steppe_raven_transform_unit.max_moves}
        {VARIABLE_OP steppe_raven_transform_unit.moves multiply $mpratio}

        [unstore_unit]
            variable=steppe_raven_transform_unit
            find_vacant=no
        [/unstore_unit]


        {CLEAR_VARIABLE steppe_raven_transform_unit}

#dummy ability to prevent units from transforming more than once per turn

        [object]
            silent=yes
            duration=turn

            [filter]
                x,y=$x1,$y1
            [/filter]

            [effect]
                apply_to=new_ability
                [abilities]
                  [ravenform_transformed]
                     id=steppe_raven_alreadytransformed
                  [/ravenform_transformed]
                [/abilities]
            [/effect]
        [/object]
        [redraw]
           clear_shroud=yes
        [/redraw]
    [/then]
    [/if]
[/event]
[event]
name=unused#side turn 1
id=steppe_marketspawn_event
first_time_only=no
{IF_VAR steppe_disablebuildings not_equals yes (
[and]
[have_unit]
side=$side_number
ability=slavfaction
canrecruit=yes
[/have_unit]
[/and]
[then]
        [store_unit]
            [filter]
                side=$side_number
                canrecruit=yes
            [/filter]
            variable=sideleader
            kill=no
        [/store_unit]

        [if]
        [have_unit]
                ability=slav_temsk
                side=$side_number
                canrecruit=yes
        [/have_unit]
        [then]
        [/then]
        [/if]

        [if]
        [have_unit]
                ability=slav_novgorod
                side=$side_number
                canrecruit=yes
        [/have_unit]
        [then]
        {UNIT $side_number Slav_Marketplace $sideleader.x $sideleader.y ()}
        [store_unit]
            [filter]
                side=$side_number
                type=Slav_Marketplace
            [/filter]
            variable=steppe_market
            kill=no
        [/store_unit]
        [store_side]
            side=$side_number
            variable=steppe_marketside
        [/store_side]
#        {VARIABLE steppe_market.variables.income $steppe_marketside.village_gold}
#        {VARIABLE steppe_market.upkeep -$steppe_marketside.village_support}
        {VARIABLE_OP steppe_market.hitpoints add "$(20 * ($sideleader.level| -2 ))"}
        {VARIABLE_OP steppe_market.max_hitpoints add "$(20 * ($sideleader.level| -2 ))"}
        [unstore_unit]
            variable=steppe_market
            find_vacant=no
        [/unstore_unit]
        [/then]
        [/if]

        {CLEAR_VARIABLE sideleader}
        {CLEAR_VARIABLE steppe_market}
        {CLEAR_VARIABLE steppe_marketside}
[/then])}
[/event]
[event]
    name=victory
    id=steppe_clear_smith_buff_overlays
    first_time_only=no
    [store_unit]
        [filter]
            ability=steppe_smith_buff1
            [or]
                ability=steppe_smith_buff2
            [/or]
            [or]
                ability=steppe_smith_buff3
            [/or]
        [/filter]
        variable=smith_buffed
        kill=no
    [/store_unit]
    [if]
    [variable]
        name=smith_buffed.length
        greater_than=0
    [/variable]
    [then]
    {FOREACH smith_buffed i}
    {SMITH_CLEAR_OVERLAYS $smith_buffed[$i].id}
    {NEXT i}
    {CLEAR_VARIABLE smith_buffed}
    [/then]
    [/if]
[/event]
[event]
    name=victory
    id=steppe_clear_idol_buff_overlays
    first_time_only=no
    [store_unit]
        [filter]
            ability=steppe_idol_buff1
            [or]
                ability=steppe_idol_buff2
            [/or]
            [or]
                ability=steppe_idol_buff3
            [/or]
        [/filter]
        variable=idol_buffed
        kill=no
    [/store_unit]
    [if]
    [variable]
        name=idol_buffed.length
        greater_than=0
    [/variable]
    [then]
    {FOREACH idol_buffed i}
    {IDOL_CLEAR_OVERLAYS $idol_buffed[$i].id}
    {NEXT i}
    {CLEAR_VARIABLE idol_buffed}
    [/then]
    [/if]
[/event]
#enddef

#define ABILITY_STEPPE_SURPRISE_ATTACK
    [dummy]
        id=steppe_surprise_attack
        name=_"surprise attack"
        description=_"At the start of the turn, if this unit is invisibile, they gain the 'reliable' weapon special on all attacks for 1 turn."
    [/dummy]
     # wmlxgettext: [abilities]
[/abilities]
    [event]
    name=turn refresh #not side turn, so the effect triggers after a unit's hidden-ness is calculated
    id=steppe_surpriseattack_event
    first_time_only=no
    [store_unit]
        [filter]
            side=$side_number
            ability=steppe_surprise_attack
            ability_type_active=hides
            [not]
              status=uncovered
            [/not]            
        [not]
        [filter_wml]
        [status]
            petrified=yes
        [/status]
        [/filter_wml]
        [/not]
        [/filter]
        variable=surpriseattacker
        kill=no
    [/store_unit]
    [if]
    [variable]
        name=surpriseattacker.length
        greater_than=0
    [/variable]
    [then]
#    [chat]
#        message="surprise attackers filter passed"
#    [/chat]
    {FOREACH surpriseattacker i}

    [object]
        silent=yes
        duration=turn end
        [filter]
            id=$surpriseattacker[$i].id
        [/filter]
        [effect]
            apply_to=attack
#            range=ranged
#            increase_attacks=1
            [set_specials]
                mode=append
                {WEAPON_SPECIAL_RELIABLE}
            [/set_specials]
        [/effect]
    [/object]
    {NEXT i}
    {CLEAR_VARIABLE surpriseattacker}
    [/then]
    [/if]
    [/event]

[+abilities] # wmlxgettext: [/abilities]
#enddef

#define SMITH_CLEAR_OVERLAYS ID
    [remove_unit_overlay]
        id={ID}
        image="misc/overlay-smith-buff-1.png"
    [/remove_unit_overlay]
    [remove_unit_overlay]
        id={ID}
        image="misc/overlay-smith-buff-2.png"
    [/remove_unit_overlay]
    [remove_unit_overlay]
        id={ID}
        image="misc/overlay-smith-buff-3.png"
    [/remove_unit_overlay]
#enddef

#define SMITH_ACTIONS ABILITY FILTER_ALLY EFFECT
    [store_unit]
        [filter]
            side=$side_number
            ability={ABILITY}
        [not]
        [filter_wml]
        [status]
            petrified=yes
        [/status]
        [/filter_wml]
        [/not]
        [/filter]
        variable=steppe_smith
        kill=no
    [/store_unit]
    [if]
    [variable]
        name=steppe_smith.length
        greater_than=0
    [/variable]
    [then]
    {FOREACH steppe_smith e}
    [if]
    [have_unit]
        [filter_adjacent]
            x,y=$steppe_smith[$e].x,$steppe_smith[$e].y
        [/filter_adjacent]
        [filter_side]
            [allied_with]
                side=$side_number
            [/allied_with]
        [/filter_side]
        {FILTER_ALLY}
        [not]
            ability=steppe_building
        [/not]
    [/have_unit]
    [then]
    [store_unit]
        [filter]
            [filter_adjacent]
                x,y=$steppe_smith[$e].x,$steppe_smith[$e].y
            [/filter_adjacent]
            [filter_side]
                [allied_with]
                    side=$side_number
                [/allied_with]
            [/filter_side]
            {FILTER_ALLY}
            [not]
                ability=steppe_building
            [/not]
        [/filter]
        variable=steppe_smithally
        kill=no
    [/store_unit]
    [/then]
    [else]
    [store_unit]
        [filter]
            [filter_adjacent]
                x,y=$steppe_smith[$e].x,$steppe_smith[$e].y
            [/filter_adjacent]
            [filter_side]
                [allied_with]
                    side=$side_number
                [/allied_with]
            [/filter_side]
            {FILTER_ALLY}
        [/filter]
        variable=steppe_smithally
        kill=no
    [/store_unit]
    [/else]
    [/if]

    [if]
    [variable]
        name=steppe_smithally.length
        greater_than=0
    [/variable]
    [then]
    {VARIABLE steppe_smithally_random_limit $steppe_smithally.length}
    {VARIABLE_OP steppe_smithally_random_limit sub 1}
    {RANDOM 0..$steppe_smithally_random_limit}

#since the array number is offset by one from the length (if there are 2 units, the length is 2, but the units are [0] and [1])

    [animate_unit]
        flag=smith
        [filter]
            id=$steppe_smith[$e].id
        [/filter]
        [filter_second]
            id=$steppe_smithally[$random].id
        [/filter_second]
        [facing]
            x,y=$steppe_smithally[$random].x,$steppe_smithally[$random].y
        [/facing]
    [/animate_unit]
#removes existing buff overlays, so new ones can be applied later

    {SMITH_CLEAR_OVERLAYS $steppe_smithally[$random].id}

    {EFFECT}

    {CLEAR_VARIABLE steppe_smithally}
    {CLEAR_VARIABLE steppe_smithally_random_limit}

    [/then]
    [/if]
    {NEXT e}
    {CLEAR_VARIABLE steppe_smith}
    [/then]
    [/if]
#enddef

#define ABILITY_STEPPE_SMITH
    [dummy]
        id=steppe_smith
        name=_"smith"
        description=_"Each turn, this unit upgrades a random adjacent ally's armor, increasing their physical resistances by 10% for the rest of the battle, and giving the smith 1 experience. Can't upgrade the same unit more than once per battle. Prioritizes normal units over buildings." 
    [/dummy]

     # wmlxgettext: [abilities]
[/abilities]
    [event]
    name=side turn
    id=steppe_smith
    first_time_only=no
    {SMITH_ACTIONS steppe_smith (
    [not]
        ability=steppe_smith_buff1
        [or]
            ability=steppe_smith_buff2
        [/or]
        [or]
            ability=steppe_smith_buff3
        [/or]
    [/not]
    ) (
    [floating_text]
       x,y=$steppe_smithally[$random].x,$steppe_smithally[$random].y
       text=_"upgraded armor!"
    [/floating_text]

    [object]
        silent=yes
        duration=scenario
        id=steppe_smithbuff1
        take_only_once=no

        [filter]
            id=$steppe_smithally[$random].id
        [/filter]

        [effect]
            apply_to=resistance
            replace=no
            [resistance]
                blade=-10
                pierce=-10
                impact=-10
            [/resistance]
        [/effect]
        [effect]
            apply_to=new_ability
            [abilities]
              [dummy]
                 id=steppe_smith_buff1
                 name=_"upgraded armor"
                 description=_"This unit has +10% physical resistances until the end of the battle."
              [/dummy]
            [/abilities]
        [/effect]   
    [/object]
    [unit_overlay]
        id=$steppe_smithally[$random].id
        image="misc/overlay-smith-buff-1.png"
    [/unit_overlay]

    [modify_unit]
      [filter]
        id=$steppe_smith[$e].id
      [/filter]
      experience="$($steppe_smith[$e].experience| + 1)"
    [/modify_unit]

    )}
    [/event]

[+abilities] # wmlxgettext: [/abilities]
#enddef

#define ABILITY_STEPPE_MASTER_SMITH
    [dummy]
        id=steppe_master_smith
        name=_"master smith"
        description=_"Each turn, this unit upgrades a random adjacent ally's armor, increasing their physical resistances by 15%, magical resistances by 10%, and giving the smith 2 experience. Can't upgrade the same unit more than once per battle. Replaces the buffs applied by a lower-level smith." 
    [/dummy]

     # wmlxgettext: [abilities]
[/abilities]
    [event]
    name=side turn
    id=steppe_master_smith
    first_time_only=no
    {SMITH_ACTIONS steppe_master_smith (
    [not]
        ability=steppe_smith_buff2
        [or]
            ability=steppe_smith_buff3
        [/or]
    [/not]
    ) (
    [floating_text]
       x,y=$steppe_smithally[$random].x,$steppe_smithally[$random].y
       text=_"upgraded armor!"
    [/floating_text]

    [if]
    [have_unit]
        id=$steppe_smithally[$random].id
        ability=steppe_smith_buff1
    [/have_unit]
    [then]
#remove the buffs applied by a normal smith, as having the buffs stack would be extremely OP
    [object]
        silent=yes
        duration=scenario
        id=steppe_smithbuff1_removal
        take_only_once=no

        [filter]
            id=$steppe_smithally[$random].id
        [/filter]

        [effect]
            apply_to=resistance
            replace=no
            [resistance]
                blade=10
                pierce=10
                impact=10
            [/resistance]
        [/effect]
        [effect]
            apply_to=remove_ability
            [abilities]
              [dummy]
                 id=steppe_smith_buff1
              [/dummy]
            [/abilities]
        [/effect]   
    [/object]    
    [/then]
    [/if]
    [object]
        silent=yes
        duration=scenario
        id=steppe_smithbuff2
        take_only_once=no

        [filter]
            id=$steppe_smithally[$random].id
        [/filter]

        [effect]
            apply_to=resistance
            replace=no
            [resistance]
                arcane=-10
                fire=-10
                cold=-10
                blade=-15
                pierce=-15
                impact=-15
            [/resistance]
        [/effect]
        [effect]
            apply_to=new_ability
            [abilities]
              [dummy]
                 id=steppe_smith_buff2
                 name=_"upgraded armor"
                 description=_"This unit has +15% physical resistances and +10% magical resistances until the end of the battle."
              [/dummy]
            [/abilities]
        [/effect]   
    [/object]
    [unit_overlay]
        id=$steppe_smithally[$random].id
        image="misc/overlay-smith-buff-2.png"
    [/unit_overlay]

    [modify_unit]
      [filter]
        id=$steppe_smith[$e].id
      [/filter]
      experience="$($steppe_smith[$e].experience| + 2)"
    [/modify_unit]

    )}
    [/event]

[+abilities] # wmlxgettext: [/abilities]
#enddef


#define ABILITY_STEPPE_MYSTICAL_SMITH
    [dummy]
        id=steppe_mystical_smith
        name=_"mystical smith"
        description=_"Each turn, this unit upgrades a random adjacent ally's armor, increasing their physical resistances by 15%, magical resistances by 10%, giving them the 'adaptive armor' ability, and giving the smith 3 experience. Can't upgrade the same unit more than once per battle. Replaces the buffs applied by a lower-level smith." 
    [/dummy]

     # wmlxgettext: [abilities]
[/abilities]
    [event]
    name=side turn
    id=steppe_mystical_smith
    first_time_only=no
    {SMITH_ACTIONS steppe_mystical_smith (
    [not]
        ability=steppe_smith_buff3
    [/not]
    ) (
    [floating_text]
       x,y=$steppe_smithally[$random].x,$steppe_smithally[$random].y
       text=_"upgraded armor!"
    [/floating_text]

    [if]
    [have_unit]
        id=$steppe_smithally[$random].id
        ability=steppe_smith_buff1
    [/have_unit]
    [then]
#remove the buffs applied by a normal smith, as having the buffs stack would be extremely OP
    [object]
        silent=yes
        duration=scenario
        id=steppe_smithbuff1_removal
        take_only_once=no

        [filter]
            id=$steppe_smithally[$random].id
        [/filter]

        [effect]
            apply_to=resistance
            replace=no
            [resistance]
                blade=10
                pierce=10
                impact=10
            [/resistance]
        [/effect]
        [effect]
            apply_to=remove_ability
            [abilities]
              [dummy]
                 id=steppe_smith_buff1
              [/dummy]
            [/abilities]
        [/effect]   
    [/object]    
    [/then]
    [/if]

    [if]
    [have_unit]
        id=$steppe_smithally[$random].id
        ability=steppe_smith_buff2
    [/have_unit]
    [then]
#remove the buffs applied by a master smith, as having the buffs stack would be extremely OP
    [object]
        silent=yes
        duration=scenario
        id=steppe_smithbuff2_removal
        take_only_once=no

        [filter]
            id=$steppe_smithally[$random].id
        [/filter]

        [effect]
            apply_to=resistance
            replace=no
            [resistance]
                arcane=10
                fire=10
                cold=10
                blade=15
                pierce=15
                impact=15
            [/resistance]
        [/effect]
        [effect]
            apply_to=remove_ability
            [abilities]
              [dummy]
                 id=steppe_smith_buff2
              [/dummy]
            [/abilities]
        [/effect]   
    [/object]    
    [/then]
    [/if]

    [object]
        silent=yes
        duration=scenario
        id=steppe_smithbuff3
        take_only_once=no

        [filter]
            id=$steppe_smithally[$random].id
        [/filter]

        [effect]
            apply_to=resistance
            replace=no
            [resistance]
                arcane=-10
                fire=-10
                cold=-10
                blade=-15
                pierce=-15
                impact=-15
            [/resistance]
        [/effect]
        [effect]
            apply_to=new_ability
            [abilities]
              {ABILITY_STEPPE_ADAPTIVE_ARMOR}
              [dummy]
                 id=steppe_smith_buff3
                 name=_"upgraded armor"
                 description=_"This unit has +15% physical resistances and +10% magical resistances until the end of the battle."
              [/dummy]
            [/abilities]
        [/effect]   
    [/object]
    [unit_overlay]
        id=$steppe_smithally[$random].id
        image="misc/overlay-smith-buff-3.png"
    [/unit_overlay]

    [modify_unit]
      [filter]
        id=$steppe_smith[$e].id
      [/filter]
      experience="$($steppe_smith[$e].experience| + 3)"
    [/modify_unit]

    )}
    [/event]

[+abilities] # wmlxgettext: [/abilities]
#enddef

#define IDOL_CLEAR_OVERLAYS ID
    [remove_unit_overlay]
        id={ID}
        image="misc/overlay-idol-buff-1.png"
    [/remove_unit_overlay]
    [remove_unit_overlay]
        id={ID}
        image="misc/overlay-idol-buff-2.png"
    [/remove_unit_overlay]
    [remove_unit_overlay]
        id={ID}
        image="misc/overlay-idol-buff-3.png"
    [/remove_unit_overlay]
#enddef

#define ABILITY_STEPPE_STRENGTHENED VALUE
    #reduces damage of nearby allies
    [leadership]
        id=steppe_strengthened
        value={VALUE}
        cumulative=yes
        name=_"strengthened {VALUE}%"
        description=_"This unit deals "+{VALUE}+"% more damage."
        affect_self=yes
        affect_allies=no
        affect_enemies=no
    [/leadership]
#enddef

#define ABILITY_STEPPE_IDOL VALUE NUMBER
    [idol]
        id=steppe_idol
        name=_"idol {VALUE}%"
        description=_"Each turn, this unit gives a random adjacent ally +{VALUE}% damage for 3 turns, and gives the idol experience. Replaces weaker version of this effect."
        value={VALUE}
        overlay_number={NUMBER}
    [/idol]

     # wmlxgettext: [abilities]
[/abilities]
    [event]
    name=side turn
    id=steppe_idol_event
    first_time_only=no

    [store_unit]
        [filter]
            side=$side_number
            ability=steppe_idol
        [not]
        [filter_wml]
        [status]
            petrified=yes
        [/status]
        [/filter_wml]
        [/not]
        [/filter]
        variable=steppe_idol
        kill=no
    [/store_unit]
    [if]
    [variable]
        name=steppe_idol.length
        greater_than=0
    [/variable]
    [then]
    {FOREACH steppe_idol e}
    [store_unit]
        [filter]
            [filter_adjacent]
                x,y=$steppe_idol[$e].x,$steppe_idol[$e].y
            [/filter_adjacent]
            [filter_side]
                [allied_with]
                    side=$side_number
                [/allied_with]
            [/filter_side]
#            {FILTER_ALLY}
#make the damage buff not applied to units without an attack
            [has_attack]
            [/has_attack]
            [not]
                formula="$($this_unit.abilities.idol_buff.value| + 0 > $steppe_idol[$e].abilities.idol.value - 1)"
            [/not]
        [/filter]
        variable=steppe_idolally
        kill=no
    [/store_unit]

    [if]
    [variable]
        name=steppe_idolally.length
        greater_than=0
    [/variable]
    [then]
    {VARIABLE steppe_idolally_random_limit $steppe_idolally.length}
    {VARIABLE_OP steppe_idolally_random_limit sub 1}
    {RANDOM 0..$steppe_idolally_random_limit}

#since the array number is offset by one from the length (if there are 2 units, the length is 2, but the units are [0] and [1])

    [animate_unit]
        flag=smith
        [filter]
            id=$steppe_idol[$e].id
        [/filter]
        [filter_second]
            id=$steppe_idolally[$random].id
        [/filter_second]
        [facing]
            x,y=$steppe_idolally[$random].x,$steppe_idolally[$random].y
        [/facing]
    [/animate_unit]
#removes existing buff overlays, so new ones can be applied later

    {IDOL_CLEAR_OVERLAYS $steppe_idolally[$random].id}


    [floating_text]
       x,y=$steppe_idolally[$random].x,$steppe_idolally[$random].y
       text=_"+$steppe_idol[$e].abilities.idol.value|% damage!"
    [/floating_text]


    [if]
    {VARIABLE_CONDITIONAL steppe_idolally[$random].abilities.idol_buff.value less_than $steppe_idol[$e].abilities.idol.value}
    [then]

    [object]
        silent=yes
        duration=scenario
        id=steppe_idolbuff
        take_only_once=no

        [filter]
            id=$steppe_idolally[$random].id
        [/filter]

        [effect]
            apply_to=remove_ability
            [abilities]
                [leadership]
                    id=steppe_strengthened
                [/leadership]
                [idol_buff]
                   id=steppe_idol_buff
                [/idol_buff]
            [/abilities]
        [/effect]   
    [/object]

    [/then]
    [/if]

    [object]
        silent=yes
        duration=scenario
        id=steppe_idolbuff
        take_only_once=no

        [filter]
            id=$steppe_idolally[$random].id
        [/filter]

        [effect]
            apply_to=new_ability
            [abilities]
                {ABILITY_STEPPE_STRENGTHENED $steppe_idol[$e].abilities.idol.value}
                [idol_buff]
                   id=steppe_idol_buff
                   value=$steppe_idol[$e].abilities.idol.value
                [/idol_buff]
            [/abilities]
        [/effect]   
    [/object]
    [unit_overlay]
        id=$steppe_idolally[$random].id
        image="misc/overlay-idol-buff-$steppe_idol[$e].abilities.idol.overlay_number|.png"
    [/unit_overlay]

    [store_unit]
        [filter]
            id=$steppe_idolally[$random].id
        [/filter]
        variable=tmp_steppe_idolally
        kill=no
    [/store_unit]

    {VARIABLE tmp_steppe_idolally.variables.idolbuff_turns_left 3}

    [unstore_unit]
        variable=tmp_steppe_idolally
        find_vacant=no
    [/unstore_unit]

    {CLEAR_VARIABLE tmp_steppe_idolally}


    [modify_unit]
      [filter]
        id=$steppe_idol[$e].id
      [/filter]
      experience="$($steppe_idol[$e].experience| + 1)"
    [/modify_unit]

    {CLEAR_VARIABLE steppe_idolally}
    {CLEAR_VARIABLE steppe_idolally_random_limit}

    [/then]
    [/if]
    {NEXT e}
    {CLEAR_VARIABLE steppe_idol}
    [/then]
    [/if]


    [/event]
#TODO: replace this to work with idol buffs:

[event]
    name=side turn end
    id=steppe_idol_buff_event
    first_time_only=no

    [store_unit]
        [filter]
            ability=steppe_idol_buff
            side=$side_number
        [/filter]
        variable=steppe_idolbuffed
        kill=no
    [/store_unit]

    [if]
    [variable]
        name=steppe_idolbuffed.length
        greater_than=0
    [/variable]
    [then]
    {FOREACH steppe_idolbuffed i}

    {VARIABLE_OP steppe_idolbuffed[$i].variables.idolbuff_turns_left sub 1}
#    [chat]
#        message=$steppe_idolbuffed[$i].variables.idolbuff_turns_left
#    [/chat]
    [if]
    {VARIABLE_CONDITIONAL steppe_idolbuffed[$i].variables.idolbuff_turns_left less_than_equal_to 0}
    [then]
    {VARIABLE tmp_remove_duel_buff yes}
    {CLEAR_VARIABLE steppe_idolbuffed[$i].variables.idolbuff_turns_left}
    [/then]
    [/if]
        [unstore_unit]
            variable=steppe_idolbuffed[$i]
            find_vacant=no
        [/unstore_unit]
    [if]
    {VARIABLE_CONDITIONAL tmp_remove_duel_buff equals yes}
    [then]
        [object]
            silent=yes
            duration=scenario
            [filter]
                id=$steppe_idolbuffed[$i].id
            [/filter]
            [effect]
               apply_to=remove_ability
               [abilities]
                   [leadership]
                       id=steppe_strengthened
                   [/leadership]
                   [idol_buff]
                      id=steppe_idol_buff
                   [/idol_buff]
               [/abilities]
            [/effect]
        [/object]
        {IDOL_CLEAR_OVERLAYS $steppe_idolbuffed[$i].id}
    [/then]
    [/if]
    {NEXT i}
    {CLEAR_VARIABLE steppe_idolbuffed}
    {CLEAR_VARIABLE tmp_remove_duel_buff}
    [/then]
    [/if]
[/event]
[event]
    name=victory
    id=steppe_clear_idol_buffs

    [store_unit]
        [filter]
            ability=steppe_idol_buff
            side=$side_number
        [/filter]
        variable=steppe_idolbuffed
        kill=no
    [/store_unit]

    [if]
    [variable]
        name=steppe_idolbuffed.length
        greater_than=0
    [/variable]
    [then]
    {FOREACH steppe_idolbuffed i}

    {CLEAR_VARIABLE steppe_idolbuffed[$i].variables.idolbuff_turns_left}
        [unstore_unit]
            variable=steppe_idolbuffed[$i]
            find_vacant=no
        [/unstore_unit]
    {NEXT i}
    {CLEAR_VARIABLE steppe_idolbuffed}
    [/then]
    [/if]
[/event]
[+abilities] # wmlxgettext: [/abilities]
#enddef


#define WEAPON_SPECIAL_STEPPE_ADAPTIVE_STRIKE VALUE
# wmlindent: start ignoring
# wmlxgettext: [attack]
# wmlxgettext: [specials]

# wmlindent: stop ignoring
    [dummy]
        id=steppe_adaptive_strike_{VALUE}
        name=_"adaptive strike +{VALUE}"
        description=_"This attack deals {VALUE} more damage for each point of adaptive armor currently active on the unit."
    [/dummy]

[/specials]
# wmlindent: start ignoring
[/attack]
# wmlindent: stop ignoring

[event]
    name=steppe_customevent_adaptivearmor
    id=steppe_adaptivestrike_{VALUE}
    first_time_only=no
    [filter]
    [/filter]
    [object]
        silent=yes
        duration=turn end
        [filter]
            id=$unit.id
        [/filter]
        [effect]
            apply_to=attack
            special_id=steppe_adaptive_strike_{VALUE}
            increase_damage={VALUE}
        [/effect]
    [/object]
[/event]

[+attack]
# wmlindent: start ignoring

[+specials]
# wmlxgettext: [/specials]
# wmlxgettext: [/attack]
# wmlindent: stop ignoring
#enddef

#define ABILITY_STEPPE_BRAVADO_unused
    #basically like regular leadership, except only 15% per level
    [leadership]
        id=steppe_bravado
        value="(-15 * (level - other.level + 1))"
        cumulative=yes
        name=_"bravado"
        description=_"Adjacent living enemies deal less damage - -15% if the same level, -30% if one level lower, -45% if two levels lower, etc."
        affect_self=no
        affect_allies=no
        affect_enemies=yes
        [affect_adjacent]
            [filter]
                formula="level < other.level + 1"
                [not]
                    {STEPPE_FEAREXEMPT}
                [/not]
            [/filter]
        [/affect_adjacent]
    [/leadership]
#enddef


#define ABILITY_STEPPE_DUEL
    # Canned definition of the Feeding ability to be included in an
    # [abilities] clause.  Note: this is deliberately unbalanced WML,
    # in order to close the abilities clause then insert the event
    # then reopen the abilities clause.
    [duel]
        id=steppe_duel
        name=_"duel"
        description=_"If this unit kills an enemy while neither unit has their allies next to them, the duelist gains inspiration for 3 turns (the duration stacks). If this unit attacks an enemy who is next to one of its allies, the duelist gains bravado for a turn."
    [/duel]
    # wmlxgettext: [abilities]
[/abilities]
[event]
    id=ability_steppe_duel_die
    name=die
    first_time_only=no

    [filter]
        [not]
#check if there are any of the enemy's allies next to the enemy
            [filter_location]
                [filter]
                [filter_side]
                [allied_with]
                    side=$unit.side
                [/allied_with]
                [/filter_side]
                [not]
                    x,y=$x1,$y1
                    [or]
                    [filter_wml]
                        max_moves=0#stationary units do not count towards duel unit count
                    [/filter_wml]
                    [/or]
                [/not]
                [/filter]
                radius=1
            [/filter_location]
        [/not]
    [/filter]

    [filter_second]
        ability=steppe_duel
        [not]
#check if there are any of the duelist's allies next to the duelist
            [filter_location]
                [filter]
                [filter_side]
                [allied_with]
                    side=$second_unit.side
                [/allied_with]
                [/filter_side]
                [not]
                    x,y=$x2,$y2
                    [or]
                    [filter_wml]
                        max_moves=0#stationary units do not count towards duel unit count
                    [/filter_wml]
                    [/or]
                [/not]
                [/filter]
                radius=1
            [/filter_location]
        [/not]
    [/filter_second]

    {IF_VAR second_unit.variables.duel_turns_left greater_than 0 (
    [then]
    {VARIABLE_OP second_unit.variables.duel_turns_left add 3}
    [/then]
    [else]
    {VARIABLE second_unit.variables.duel_turns_left 3}
    [/else]
    )}

    [unstore_unit]
        variable=second_unit
        text=_"Duel won!"
        find_vacant=no
    [/unstore_unit]

    [object]
        silent=yes
        duration=scenario
        [filter]
            find_in=second_unit
        [/filter]
        [effect]
           apply_to=new_ability
           [abilities]
               {ABILITY_STEPPE_INSPIRE}
               [dummy]
                  id=steppe_duel_buff
               [/dummy]
           [/abilities]
        [/effect]
    [/object]
[/event]



[event]
    id=ability_steppe_duel_attack
    name=attack
    first_time_only=no

    [filter]
        ability=steppe_duel
    [/filter]

    [filter_second]
        #check if the enemy has allies nearby
        [filter_location]
            [filter]
            [filter_side]
            [allied_with]
                side=$second_unit.side
            [/allied_with]
            [/filter_side]
            [not]
                x,y=$x2,$y2
                [or]
                [filter_wml]
                    max_moves=0#stationary units do not count towards duel unit count
                [/filter_wml]
                [/or]
            [/not]
            [/filter]
            radius=1
        [/filter_location]
        [not]
            [filter_wml]
                [status]
                    not_living="yes"
                [/status]
            [/filter_wml]
        [/not]
    [/filter_second]

    [unstore_unit]
        variable=unit
        text=_"Bravado"
        find_vacant=no
        red=255
        green=126
        blue=0
    [/unstore_unit]

    [object]
        silent=yes
        duration=turn end
        [filter]
            id=$unit.id
        [/filter]
        [effect]
           apply_to=new_ability
           [abilities]
               {ABILITY_STEPPE_BRAVADO}
           [/abilities]
        [/effect]
    [/object]

[/event]

[event]
    name=side turn end
    id=steppe_duel_buff_event
    first_time_only=no

    [store_unit]
        [filter]
            ability=steppe_duel_buff
            side=$side_number
        [/filter]
        variable=steppe_duelists
        kill=no
    [/store_unit]

    [if]
    [variable]
        name=steppe_duelists.length
        greater_than=0
    [/variable]
    [then]
    {FOREACH steppe_duelists i}

    {VARIABLE_OP steppe_duelists[$i].variables.duel_turns_left sub 1}
#    [chat]
#        message=$steppe_duelists[$i].variables.duel_turns_left
#    [/chat]
    [if]
    {VARIABLE_CONDITIONAL steppe_duelists[$i].variables.duel_turns_left less_than_equal_to 0}
    [then]
    {VARIABLE tmp_remove_duel_buff yes}
    {CLEAR_VARIABLE steppe_duelists[$i].variables.duel_turns_left}
    [/then]
    [/if]
        [unstore_unit]
            variable=steppe_duelists[$i]
            find_vacant=no
        [/unstore_unit]
    [if]
    {VARIABLE_CONDITIONAL tmp_remove_duel_buff equals yes}
    [then]
        [object]
            silent=yes
            duration=scenario
            [filter]
                id=$steppe_duelists[$i].id
            [/filter]
            [effect]
               apply_to=remove_ability
               [abilities]
               {ABILITY_STEPPE_INSPIRE}
               [dummy]
                  id=steppe_duel_buff
               [/dummy]
               [/abilities]
            [/effect]
        [/object]
    [/then]
    [/if]
    {NEXT i}
    {CLEAR_VARIABLE steppe_duelists}
    {CLEAR_VARIABLE tmp_remove_duel_buff}
    [/then]
    [/if]
[/event]
[event]
    name=victory
    id=steppe_clear_duel_buffs

    [store_unit]
        [filter]
            ability=steppe_duel_buff
            side=$side_number
        [/filter]
        variable=steppe_duelists
        kill=no
    [/store_unit]

    [if]
    [variable]
        name=steppe_duelists.length
        greater_than=0
    [/variable]
    [then]
    {FOREACH steppe_duelists i}

    {CLEAR_VARIABLE steppe_duelists[$i].variables.duel_turns_left}
        [unstore_unit]
            variable=steppe_duelists[$i]
            find_vacant=no
        [/unstore_unit]
    {NEXT i}
    {CLEAR_VARIABLE steppe_duelists}
    [/then]
    [/if]
[/event]

#todo: add a victory event here that clears the duel turns variables of all duelists

[+abilities]
    # wmlxgettext: [/abilities]
#enddef
# wmllint: unbalanced-off

#define WEAPON_SPECIAL_STEPPE_HOLY_LIGHT
# wmlindent: start ignoring
# wmlxgettext: [attack]
# wmlxgettext: [specials]

# wmlindent: stop ignoring
    [damage]
        id=steppe_holy_light
        name=_"holy light"
        description=_"When this attack hits, enemies adjacent to this unit are damaged by 70% (rounded down) of this attack's damage, and adjacent allies are healed by 33% (rounded down) of the attack's damage."
    [/damage]
[/specials]
# wmlindent: start ignoring
[/attack]
# wmlindent: stop ignoring
[event]
    name=attacker_hits
    id=steppe_holy_light
    first_time_only=no
    [filter_attack]
        special_id=steppe_holy_light
    [/filter_attack]

    {VARIABLE tmp_aoedmg $weapon.damage}
    {VARIABLE_OP tmp_aoedmg multiply 0.70}
    {VARIABLE_OP tmp_aoedmg round floor}
    {VARIABLE tmp_aoeheal $weapon.damage}
    {VARIABLE_OP tmp_aoeheal multiply 0.33}
    {VARIABLE_OP tmp_aoeheal round floor}

    [store_unit]
        [filter]
            [filter_adjacent]
                x,y=$x1,$y1
            [/filter_adjacent]
            [filter_side]
                [enemy_of]
                    side=$unit.side
                [/enemy_of]
            [/filter_side]
            [not]
                [filter_wml]
                    [status]
                        petrified=yes
                    [/status]
                [/filter_wml]
                [or]
                    id=$second_unit.id
                [/or]
            [/not]
        [/filter]
        variable=bystander
    [/store_unit]

    {FOREACH bystander i}
                [if]
                    [have_unit]
                        find_in=expfreeze
                        x,y=$bystander[$i].x,$bystander[$i].y
                    [/have_unit]
                    [else]
                    [fire_event]
                        name=attack
                        [primary_unit]
                            id=$unit.id
                        [/primary_unit]
                        [secondary_unit]
                            id=$bystander[$i].id
                        [/secondary_unit]
                    [/fire_event]
                    [store_unit]
                        [filter]
                            x,y=$bystander[$i].x,$bystander[$i].y
                        [/filter]
                        variable=expfreeze
                        mode=append
                    [/store_unit]
                    [/else]
                [/if]
                [harm_unit]
                    [filter]
                        x,y=$bystander[$i].x,$bystander[$i].y
                        [filter_side]
                            [enemy_of]
                                side=$unit.side
                            [/enemy_of]
                        [/filter_side]
                        [not]
                            [filter_wml]
                                [status]
                                    petrified=yes
                                [/status]
                            [/filter_wml]
                        [/not]
                    [/filter]
                    [filter_second]
                        x,y=$x1,$y1
                    [/filter_second]
                    [primary_attack]
                        name=$weapon.name
                        type=$weapon.type
                        range=$weapon.range
                    [/primary_attack]
                    amount=$tmp_aoedmg
                    damage_type=$weapon.type
                    alignment=$unit.alignment
                    fire_event=yes
                    animate=defender
                    delay=0
                    experience=no
                [/harm_unit]
                {VARIABLE damage_inflicted $tmp_aoedmg}
                [fire_event]
                    name=attacker_hits
                    [primary_unit]
                        id=$unit.id
                    [/primary_unit]
                    [secondary_unit]
                        id=$bystander[$i].id
                    [/secondary_unit]
                    [primary_weapon]
                        name=$weapon.name
                        type=$weapon.type
                        damage=$weapon.damage
                        range=$weapon.range
                    [/primary_weapon]
                [/fire_event]
    {NEXT i}
        [heal_unit]
            [filter]
                [filter_adjacent]
                    x,y=$x1,$y1
                [/filter_adjacent]
                [filter_side]
                    [allied_with]
                        side=$unit.side
                    [/allied_with]
                [/filter_side]
            [/filter]
            amount=$tmp_aoeheal
            animate=yes
            restore_statuses=no
        [/heal_unit]
    {CLEAR_VARIABLE tmp_aoedmg}
    {CLEAR_VARIABLE tmp_aoeheal}
[/event]

[event]
    name=defender_hits
    id=steppe_holy_light2
    first_time_only=no
    [filter_second_attack]
        special_id=steppe_holy_light
    [/filter_second_attack]

    {VARIABLE tmp_expfreeze_defense yes}#the expfreeze event checks this variable

    {VARIABLE tmp_aoedmg $second_weapon.damage}
    {VARIABLE_OP tmp_aoedmg multiply 0.70}
    {VARIABLE_OP tmp_aoedmg round floor}
    {VARIABLE tmp_aoeheal $second_weapon.damage}
    {VARIABLE_OP tmp_aoeheal multiply 0.33}
    {VARIABLE_OP tmp_aoeheal round floor}

    [store_unit]
        [filter]
            [filter_adjacent]
                x,y=$x2,$y2
            [/filter_adjacent]
            [filter_side]
                [enemy_of]
                    side=$second_unit.side
                [/enemy_of]
            [/filter_side]
            [not]
                [filter_wml]
                    [status]
                        petrified=yes
                    [/status]
                [/filter_wml]
                [or]
                    id=$unit.id
                [/or]
            [/not]
        [/filter]
        variable=bystander
    [/store_unit]

    {FOREACH bystander i}
                [if]
                    [have_unit]
                        find_in=expfreeze
                        x,y=$bystander[$i].x,$bystander[$i].y
                    [/have_unit]
                    [else]
                    [fire_event]
                        name=attack
                        [primary_unit]
                            id=$second_unit.id
                        [/primary_unit]
                        [secondary_unit]
                            id=$bystander[$i].id
                        [/secondary_unit]
                    [/fire_event]
                    [store_unit]
                        [filter]
                            x,y=$bystander[$i].x,$bystander[$i].y
                        [/filter]
                        variable=expfreeze
                        mode=append
                    [/store_unit]
                    [/else]
                [/if]
                [harm_unit]
                    [filter]
                        x,y=$bystander[$i].x,$bystander[$i].y
                        [filter_side]
                            [enemy_of]
                                side=$second_unit.side
                            [/enemy_of]
                        [/filter_side]
                        [not]
                            [filter_wml]
                                [status]
                                    petrified=yes
                                [/status]
                            [/filter_wml]
                        [/not]
                    [/filter]
                    [filter_second]
                        x,y=$x2,$y2
                    [/filter_second]
                    [primary_attack]
                        name=$second_weapon.name
                        type=$second_weapon.type
                        range=$second_weapon.range
                    [/primary_attack]
                    amount=$tmp_aoedmg
                    damage_type=$second_weapon.type
                    alignment=$second_unit.alignment
                    fire_event=yes
                    animate=defender
                    delay=0
                    experience=no
                [/harm_unit]
                {VARIABLE damage_inflicted $tmp_aoedmg}
                [fire_event]
                    name=defender_hits
                    [primary_unit]
                        id=$bystander[$i].id
                    [/primary_unit]
                    [secondary_unit]
                        id=$unit.id
                    [/secondary_unit]
                    [primary_weapon]
                        name=$second_weapon.name
                        type=$second_weapon.type
                        damage=$second_weapon.damage
                        range=$second_weapon.range
                    [/primary_weapon]
                [/fire_event]
    {NEXT i}
        [heal_unit]
            [filter]
                [filter_adjacent]
                    x,y=$x2,$y2
                [/filter_adjacent]
                [filter_side]
                    [allied_with]
                        side=$second_unit.side
                    [/allied_with]
                [/filter_side]
            [/filter]
            amount=$tmp_aoeheal
            animate=yes
            restore_statuses=no
        [/heal_unit]
    {CLEAR_VARIABLE tmp_aoedmg}
    {CLEAR_VARIABLE tmp_aoeheal}
[/event]

{STEPPE_EXPFREEZE_EVENT}
[+attack]
# wmlindent: start ignoring

[+specials]
# wmlxgettext: [/specials]
# wmlxgettext: [/attack]
# wmlindent: stop ignoring
#enddef

#define ABILITY_OBSERVE RADIUS
    [observe]
        id=steppe_observe
        name=_"observe "+{RADIUS} 
        description=_"Each turn, this unit marks all enemies in a {RADIUS}-tile radius for the rest of the battle. Marked units are visible through fog/shroud and their invisibility abilities do not work."
        radius={RADIUS}
    [/observe]
     # wmlxgettext: [abilities]
[/abilities]
    [event]
    name=side turn
    id=steppe_observe_mark_event
    first_time_only=no
    [store_unit]
        [filter]
            side=$side_number
            ability=steppe_observe
        [not]
        [filter_wml]
        [status]
            petrified=yes
        [/status]
        [/filter_wml]
        [/not]
        [/filter]
        variable=steppe_observer
        kill=no
    [/store_unit]

    [foreach]
        array=steppe_observer
        index_var=i
        [do]

    [store_unit]
        [filter]
            [filter_location]
                [filter]
                    id=$this_item.id
                [/filter]
                radius=$this_item.abilities.observe.radius
            [/filter_location]
            [filter_side]
                [enemy_of]
                    side=$side_number
                [/enemy_of]
            [/filter_side]
            [not]
            [filter_wml]
            [status]
                petrified=yes
            [/status]
            [/filter_wml]
            [/not]
            [not]
                ability=steppe_observe_marked
            [/not]
        [/filter]
        variable=observe_marked_targets
        kill=no
    [/store_unit]

    [foreach]
        array=observe_marked_targets
        index_var=e
        [do]

#TODO: maybe edit the code so it lets several different sides observe a unit at once

    [unit_overlay]
        id=$this_item.id
        image="misc/overlay-observed.png"
    [/unit_overlay]

    [object]
        silent=yes
        duration=scenario
        [filter]
            find_in=this_item
        [/filter]
        [effect]
           apply_to=new_ability
           [abilities]
               [observed]
                   id=steppe_observed
                   observer_side=$side_number
               [/observed]
           [/abilities]
        [/effect]
    [/object]

    [modify_unit]
        [filter]
            find_in=this_item
        [/filter]
        [status]
            uncovered=yes
        [/status]
    [/modify_unit]

        [/do]
    [/foreach]


        [/do]
    [/foreach]
    {CLEAR_VARIABLE steppe_observer}
    {CLEAR_VARIABLE observe_marked_targets}

[/event]

[event]
    name=moveto
    id=steppe_observe_clearfog_event
    first_time_only=no
    [filter]
            ability=steppe_observed
    [/filter]
    [lift_fog]
        x,y=$x1,$y1
        side=$unit.abilities.observed.observer_side
    [/lift_fog]
    [remove_shroud]
        x,y=$x1,$y1
        side=$unit.abilities.observed.observer_side
    [/remove_shroud]

    [modify_unit]
        [filter]
            x,y=$x1,$y1
        [/filter]
        [status]
            uncovered=yes
        [/status]
    [/modify_unit]
    [allow_undo][/allow_undo]
[/event]


[event]
    name=turn refresh
    id=steppe_observe_clearfog2_event
    first_time_only=no
    [store_unit]
        [filter]
            side=$side_number
            ability=steppe_observed
        [/filter]
        variable=steppe_observed
        kill=no
    [/store_unit]

    [foreach]
        array=steppe_observed
        index_var=i
        [do]
        #workaround for fog clearing behavior
        [reset_fog]
            side=$this_item.abilities.observed.observer_side
        [/reset_fog]

    [lift_fog]
        x,y=$this_item.x,$this_item.y
        side=$this_item.abilities.observed.observer_side
    [/lift_fog]
    [remove_shroud]
        x,y=$this_item.x,$this_item.y
        side=$this_item.abilities.observed.observer_side
    [/remove_shroud]

    [modify_unit]
        [filter]
            find_in=this_item
        [/filter]
        [status]
            uncovered=yes
        [/status]
    [/modify_unit]

        [/do]
    [/foreach]
    {CLEAR_VARIABLE steppe_observed}
[/event]

[event]
    name=side turn
    id=steppe_observe_clearfog3_event
    first_time_only=no
    [store_unit]
        [filter]
            ability=steppe_observed
        [/filter]
        variable=steppe_observed
        kill=no
    [/store_unit]

    [foreach]
        array=steppe_observed
        index_var=i
        [do]


        [if]
        {VARIABLE_CONDITIONAL this_item.abilities.observed.observer_side equals $side_number}
        [then]

#        [chat]
#            message="observed unit found"
#        [/chat]


    [lift_fog]
        x,y=$this_item.x,$this_item.y
        side=$side_number
        multiturn=yes#workaround for fog clearing behavior
    [/lift_fog]
    [remove_shroud]
        x,y=$this_item.x,$this_item.y
        side=$side_number
    [/remove_shroud]

    [modify_unit]
        [filter]
            find_in=this_item
        [/filter]
        [status]
            uncovered=yes
        [/status]
    [/modify_unit]

        [/then]
        [/if]

        [/do]
    [/foreach]
    {CLEAR_VARIABLE steppe_observed}
[/event]

[event]
    name=victory
    id=steppe_clear_observe_overlays
    first_time_only=no
    [store_unit]
        [filter]
            ability=steppe_observed
        [/filter]
        variable=steppe_observed
        kill=no
    [/store_unit]
    [if]
    [variable]
        name=steppe_observed.length
        greater_than=0
    [/variable]
    [then]
    {FOREACH steppe_observed i}
    [remove_unit_overlay]
        id=$steppe_observed[$i].id
        image="misc/overlay-observed.png"
    [/remove_unit_overlay]
    {NEXT i}
    {CLEAR_VARIABLE steppe_observed}
    [/then]
    [/if]
[/event]

[+abilities] # wmlxgettext: [/abilities]
#enddef