#textdomain wesnoth-gse

#define ABILITY_KINGDOMFACTION
#using [kingdomfaction] instead of [dummy] for lua code
    [kingdomfaction]
        id=kingdomfaction
    [/kingdomfaction]
#enddef

#define ABILITY_STEPPE_VASSAL
#dummy ability for filtering
    [dummy]
        id=steppe_vassal
    [/dummy]
#enddef

#define STEPPE_PENETRATE_ARMOR VALUE
    [dummy]
        id=penetrate_armor_{VALUE}
        name=_"penetrate armor "+{VALUE}+"%"
        description=_"While attacking with this weapon, the opponent's resistances are reduced by "+{VALUE}+_"% (can't reduce resistances below 0%)."
    [/dummy]
#enddef

#define WEAPON_SPECIAL_PENETRATE_ARMOR VALUE
{STEPPE_PENETRATE_ARMOR {VALUE}}
    [/specials]
[/attack]
    [event]
    name=unit placed,post advance
    first_time_only=no
    id=steppe_addarmorpiercing{VALUE}
    [filter]
        [has_attack]
            special_id=penetrate_armor_{VALUE}
        [/has_attack]    
    [/filter]
    #the condition filter is needed to prevent recursion, as [unit_overlay] triggers the unit placed event
    [filter_condition]
    {VARIABLE_CONDITIONAL tmp_steppe_antiloop not_equals yes}
    [/filter_condition]
    [object]
        silent=yes
        duration=scenario
        [filter]
            find_in=unit
        [/filter]
        [effect]
            apply_to=new_ability
            [abilities]
                {ABILITY_STEPPE_PENETRATE_ARMOR {VALUE}}
            [/abilities]
        [/effect]
    [/object]
    [/event]
[+attack]
[+specials]

    #TODO: maybe make the weapon special automatically give the armor-reducing ability too
#enddef


#NOTE: THIS ABILITY ONLY WORKS PROPERLY ON 1.15 AND ABOVE!!!

#define ABILITY_STEPPE_PENETRATE_ARMOR VALUE
    # Canned definition of the Steadfast ability to be included in an [abilities]
    # clause.
    [resistance]
        id=steppe_penetrate_armor_{VALUE}
        sub={VALUE}
        max_value=100
        # applies to any type if we leave it out
#        apply_to=blade,pierce,impact
        [filter_base_value]
            greater_than=0
            less_than=100
        [/filter_base_value]
#        name="broken armor "+{NUMBER} "сломанная броня "+{NUMBER} }
#        description=_"This unit’s physical resistances are reduced by "+{NUMBER}+_"%. This effect disappears after a turn."+_"%. Этот эффект исчезает через ход."}
        affect_self=no
        affect_allies=no
        affect_enemies=yes
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
        [/affect_adjacent]
        [filter_second_weapon]
            special_id_active=penetrate_armor_{VALUE}
        [/filter_second_weapon]
    [/resistance]
#enddef

#define WEAPON_SPECIAL_STEPPE_KNOCKBACK
    [dummy]
        id=steppe_knockback
        name=_"knockback"
        description=_"On offense, this unit pushes the enemy one tile behind on hit. This does not work if that tile is either occupied or impassable for the enemy."
    [/dummy]
    [/specials]
[/attack]

     [event]
       name=attacker hits
       first_time_only=no
   
       [filter_attack]
           special_id=steppe_knockback
       [/filter_attack]
   
#       [filter_second]
#           [not]
#               [filter_location]
#                   terrain=*^V*
#               [/filter_location]
#           [/not]
#       [/filter_second]
   
               [store_locations]
                   [not]
                       [filter]
                       [/filter]
                       [or]
                       terrain=M*,Q*,X*,Wo*^* #mountains, unwalkable, impassable, and deep water
                       [/or]
                   [/not]
   
                   [filter_adjacent_location]
                       x,y=$x2,$y2
                       adjacent=-$unit.facing
                   [/filter_adjacent_location]
   
                   variable=knockback_target_hex
               [/store_locations]
   
               [if]
                   [variable]
                       name=knockback_target_hex.length
                       greater_than=0
                   [/variable]
   
                   [then]

                               {IF_VAR second_unit.hitpoints less_than_equal_to 0 (
                               [then]
#doesn't knockbackback units that are about to die, as it can cause weird bugs
                               [/then]
                               [else]
                        [teleport]
                            [filter]
                                x,y=$x2,$y2
                            [/filter]
                            animate=no#yes
                            
                            x,y=$knockback_target_hex.x,$knockback_target_hex.y
                           check_passability=yes
                           clear_shroud=yes
                        [/teleport]

                               [/else]
                               )}

                        [redraw]
                        [/redraw]
                       [if]
                           [have_unit]
                               x,y=$knockback_target_hex.x,$knockback_target_hex.y
                               id=$second_unit.id
                           [/have_unit]
   
                           [then]
                               
#                               [store_unit]
#                                   [filter]
#                                       x,y=$knockback_target_hex.x,$knockback_target_hex.y
#                                   [/filter]   
#                                   kill=no
#                                   variable=knockbacked
#                               [/store_unit]
   
#                               [unstore_unit]
#                                   variable=knockbacked
#                                   text= _ "Trample!"
#                                   {COLOR_HARM}
#                               [/unstore_unit]


                               [fire_event]
                                      name=moveto
                                      [primary_unit]
                                           x,y=$knockback_target_hex.x,$knockback_target_hex.y
                                      [/primary_unit]
                               [/fire_event]

#                               {CLEAR_VARIABLE knockbacked}
                           [/then]
                       [/if]
                   [/then]
               [/if]
   
               {CLEAR_VARIABLE knockback_direction,knockback_target_hex}
   [/event]
    [+attack]
    [+specials]
#enddef

#define STEPPE_KINGDOM_ADD_TITLE TITLE_STRING_FRONT TITLE_STRING_BACK TITLE_VAR FILTER

    [store_unit]
        [filter]
            {FILTER}
            [and]
                [filter_wml]
                [not]
                [variables]
                    [titles]
                        {TITLE_VAR}=yes
                    [/titles]
                [/variables]
                [/not]
                [/filter_wml]
            [/and]
        [/filter]
        variable=steppe_title_unit
        kill=no
    [/store_unit]

    [if]
    [have_unit]
        id=$steppe_title_unit.id
    [/have_unit]
    [then]
    {VARIABLE tmp_title_front {TITLE_STRING_FRONT}}
    {VARIABLE tmp_title_back {TITLE_STRING_BACK}}

    [lua]
        code=<<
        wesnoth.require "~add-ons/1The_Great_Steppe_Era/lua/steppe_lua_functions.lua"

        local new_name = wml.variables["tmp_title_front"]..wml.variables["steppe_title_unit.name"]..wml.variables["tmp_title_back"]

        wesnoth.set_variable("tmp_new_name",new_name)

        >>
    [/lua]
        {VARIABLE steppe_title_unit.name $tmp_new_name}
        {VARIABLE steppe_title_unit.variables.titles.{TITLE_VAR} yes}#for filtering

    [unstore_unit]
        variable=steppe_title_unit
        find_vacant=no
    [/unstore_unit]

    [/then]
    [/if]

    {CLEAR_VARIABLE steppe_title_unit}
    {CLEAR_VARIABLE tmp_new_name}
    {CLEAR_VARIABLE tmp_title_front}
    {CLEAR_VARIABLE tmp_title_back}

#enddef

#define EVENTLOADER_EVENTS_KINGDOM

[event]
    name=unit placed
    id=steppe_kingdom_spawn_faith
    first_time_only=no
    [filter]
        ability=kingdomfaction
    [/filter]
    [filter_condition]
    {VARIABLE_CONDITIONAL tmp_steppe_antiloop not_equals yes}
    [/filter_condition]

    {VARIABLE tmp_steppe_antiloop yes}

    [if]
    {VARIABLE_CONDITIONAL unit.variables.faith greater_than 0}
    [or]
    {VARIABLE_CONDITIONAL unit.variables.sermons_left greater_than 0}
    [/or]
    [else]

    {VARIABLE unit.variables.faith 0}

#    {IF_VAR unit.race equals ogre (
#    [or]
#    {VARIABLE_CONDITIONAL unit.race equals human}#peasants can be religious too
#    [/or]
#    [then]
#    {VARIABLE unit.variables.faith 1}
#    [/then]
#    [else]
#    {VARIABLE unit.variables.faith 0}
#    [/else]
#    )}

#    [if]
#    [have_unit]
#        id=$unit.id
#        ability=steppe_mercenary
#        [or]
#        id=$unit.id
#        ability=steppe_mercenary_ringleader
#        [/or]
#    [/have_unit]
#    [then]
#    {VARIABLE unit.variables.faith 0}
#    [/then]
#    [/if]
#
#    [if]
#    [have_unit]
#        id=$unit.id
#        ability=steppe_sermon
#    [/have_unit]
#    [then]
#    {VARIABLE unit.variables.faith 1}
#    [/then]
#    [/if]

    [if]
    [have_unit]
        side=$unit.side
        ability=steppe_loyal_bishop
    [/have_unit]
    [then]
    {VARIABLE_OP unit.variables.faith add 1}
    [/then]
    [/if]

#    [if]
#    [have_unit]
#        side=$unit.side
#        ability=steppe_false_prophet
#    [/have_unit]
#    [then]
#    {VARIABLE_OP unit.variables.faith sub 1}
#    [/then]
#    [/if]
#
#    [if]
#    [have_unit]
#        id=$unit.id
#        ability=steppe_false_prophet
#    [/have_unit]
#    [then]
#    {VARIABLE unit.variables.faith -4}
#    [/then]
#    [/if]

    {VARIABLE unit.variables.sermons_left 4}

    [unstore_unit]
        variable=unit
        find_vacant=no
    [/unstore_unit]

    [fire_event]
        id=steppe_kingdom_apply_faith_buff
        [primary_unit]
            id=$unit.id
        [/primary_unit]
    [/fire_event]
    [/else]
    [/if]

    {CLEAR_VARIABLE tmp_steppe_antiloop}
[/event]

[event]
    name=unit placed,post advance#added post advance as unit placed doesn't trigger on advancement
    id=steppe_kingdom_titles1
    first_time_only=no
    [filter]
        ability=kingdomfaction
    [/filter]
    [filter_condition]
    {VARIABLE_CONDITIONAL tmp_steppe_antiloop not_equals yes}
    [/filter_condition]

    {STEPPE_EXECUTE_IF_SYNCED (

    {VARIABLE tmp_steppe_antiloop yes}

    {RANDOM 1..5}

    {STEPPE_KINGDOM_ADD_TITLE _"Sir " () sir (
        x,y=$x1,$y1
        type_adv_tree=Kingdom_Feudal,Kingdom_Vassal_Noble_Knight
    )}

    [switch]
        variable=random
        [case]
            value=1
            {STEPPE_KINGDOM_ADD_TITLE () _" I" lineage_number (
                x,y=$x1,$y1
                type_adv_tree=Kingdom_Pan,Kingdom_Pope
            )}
        [/case]
        [case]
            value=2
            {STEPPE_KINGDOM_ADD_TITLE () _" II" lineage_number (
                x,y=$x1,$y1
                type_adv_tree=Kingdom_Pan,Kingdom_Pope
            )}
        [/case]
        [case]
            value=3
            {STEPPE_KINGDOM_ADD_TITLE () _" III" lineage_number (
                x,y=$x1,$y1
                type_adv_tree=Kingdom_Pan,Kingdom_Pope
            )}
        [/case]
        [case]
            value=4
            {STEPPE_KINGDOM_ADD_TITLE () _" IV" lineage_number (
                x,y=$x1,$y1
                type_adv_tree=Kingdom_Pan,Kingdom_Pope
            )}
        [/case]
        [case]
            value=5
            {STEPPE_KINGDOM_ADD_TITLE () _" V" lineage_number (
                x,y=$x1,$y1
                type_adv_tree=Kingdom_Pan,Kingdom_Pope
            )}
        [/case]
        [/switch]


    {STEPPE_KINGDOM_ADD_TITLE _"King " () king (
        x,y=$x1,$y1
        type=Kingdom_King
    )}


    {STEPPE_KINGDOM_ADD_TITLE () _" The Great" the_great (
        x,y=$x1,$y1
        type=Kingdom_King
    )}

    {STEPPE_KINGDOM_ADD_TITLE _"Pope " () pope (
        x,y=$x1,$y1
        type=Kingdom_Pope
    )}


    {CLEAR_VARIABLE tmp_steppe_antiloop}

    )}
[/event]

[event]
    name=attacker hits
    id=steppe_kingdom_titles_king_miss1
    first_time_only=no
    [filter]
        type=Kingdom_King
    [/filter]

    {VARIABLE tmp_king_landed_hit yes}
[/event]


[event]
    name=attack end
    id=steppe_kingdom_titles_king_miss2
    first_time_only=no
    [filter]
        type=Kingdom_King
    [/filter]

    {IF_VAR tmp_king_landed_hit not_equals yes (
    [then]

    {STEPPE_KINGDOM_ADD_TITLE () _" The Clumsy" clumsy (
        x,y=$x1,$y1
        type=Kingdom_King
    )}

    [/then]
    )}

    {CLEAR_VARIABLE tmp_king_landed_hit}
[/event]

[event]
    name=capture
    id=steppe_kingdom_titles_king_capture
    first_time_only=no
    [filter]
        type=Kingdom_King
    [/filter]

    {STEPPE_KINGDOM_ADD_TITLE () _" The Taker of Villages" taker_of_villages (
        x,y=$x1,$y1
        type=Kingdom_King
    )}
[/event]

[event]
    name=die
    id=steppe_kingdom_titles_giantslayer
    first_time_only=no
    [filter]
        level=4-999
        [not]
            type=Kingdom_King#killing a king gives a different title
        [/not]
    [/filter]
    [filter_second]
        ability=kingdomfaction
    [/filter_second]

    {STEPPE_KINGDOM_ADD_TITLE () _" The Giantslayer" giantslayer (
        x,y=$x2,$y2
    )}

#    [object]
#        silent=yes
#        duration=scenario
#        [filter]
#            find_in=second_unit
#        [/filter]
#        [effect]
#            apply_to=attack
#            [not]
#                special_id=steppe_giantslayer#this is to prevent the ability being repeatedly stacked
#            [/not]
#            [set_specials]
#                mode=append
#                {WEAPON_SPECIAL_STEPPE_GIANTSLAYER}
#            [/set_specials]
#        [/effect]
#    [/object]
[/event]

[event]
    name=die
    id=steppe_kingdom_titles_crusher
    first_time_only=no
    [filter]
        level=0
    [/filter]
    [filter_second]
        type=Kingdom_King
    [/filter_second]

    {STEPPE_KINGDOM_ADD_TITLE () _" The Crusher of Weaklings" crusher_of_weaklings (
        x,y=$x2,$y2
        type=Kingdom_King
    )}
[/event]

[event]
    name=die
    id=steppe_kingdom_titles_kingslayer
    first_time_only=no
    [filter]
        type=Kingdom_King
    [/filter]
    [filter_second]
        ability=kingdomfaction
    [/filter_second]

    {STEPPE_KINGDOM_ADD_TITLE () _" The Kingslayer" kingslayer (
        x,y=$x2,$y2
    )}
[/event]
[event]
    name=unit placed,post advance
    id=steppe_kingdom_apply_faith_buff
    first_time_only=no
#    [filter]
#        ability=kingdomfaction
#        [or]
#            formula="self.variables.faith > 0"
#        [/or]
#    [/filter]

        [if]
        {VARIABLE_CONDITIONAL unit.variables.faith greater_than_equal_to 1}
        [then]
    [object]
        silent=yes
        duration=scenario
        [filter]
            find_in=unit
            [not]
                ability=steppe_faith_buff_dummy#this is to prevent the ability being repeatedly stacked
            [/not]
#            formula="self.variables.faith > 0"
        [/filter]
#        [effect]
#            apply_to=attack
#            [not]
#                special_id=steppe_faith_buff_dummy#this is to prevent the ability being repeatedly stacked
#            [/not]
#            [set_specials]
#                mode=append
#                {WEAPON_SPECIAL_STEPPE_FAITH_BUFF}
#            [/set_specials]
#        [/effect]
        [effect]
            apply_to=new_ability
            [abilities]
                {ABILITY_STEPPE_FAITH_BUFF}
            [/abilities]
        [/effect]
    [/object]

        [object]
            silent=yes
            duration=scenario
            [filter]
                find_in=unit
                [not]
                [filter_wml]
                    alignment=lawful
                [/filter_wml]
                [/not]
            [/filter]
            [effect]
                apply_to=alignment
                set=lawful
            [/effect]
        [/object]
        [modify_unit]
            [filter]
                id=$unit.id
                [not]
                    trait=fearless
                [/not]
            [/filter]
            {TRAIT_FEARLESS}
        [/modify_unit]
        [object]
            silent=yes
            duration=scenario
            [filter]
                find_in=unit
            [/filter]
            [effect]
                apply_to=new_ability
                [abilities]
                    {ABILITY_STEPPE_PRIDE 15}
                [/abilities]
            [/effect]
        [/object]
        [/then]
        [/if]
        [if]
        {VARIABLE_CONDITIONAL unit.variables.faith greater_than_equal_to 2}
        [then]

        [object]
            silent=yes
            duration=scenario
            [filter]
                find_in=unit
                [not]
                    ability=steppe_dummy_faith_damage_buff
                [/not]
            [/filter]
            [effect]
                apply_to=attack
                increase_damage=1
            [/effect]
            [effect]
                apply_to=new_ability
                [abilities]
                [damage]
                    id=steppe_dummy_faith_damage_buff
                [/damage]
                [/abilities]
            [/effect]
            [effect]
                apply_to=remove_ability
                [abilities]
                    {ABILITY_STEPPE_PRIDE 15}
                [/abilities]
            [/effect]
            [effect]
                apply_to=new_ability
                [abilities]
                    {ABILITY_STEPPE_PRIDE 25}
                [/abilities]
            [/effect]
        [/object]
        [/then]
        [/if]
        [if]
        {VARIABLE_CONDITIONAL unit.variables.faith greater_than_equal_to 3}
        [then]

        [object]
            silent=yes
            duration=scenario
            [filter]
                find_in=unit
            [/filter]
#            [effect]
#                apply_to=remove_ability
#                [abilities]
#                    {ABILITY_STEPPE_PRIDE 15}
#                [/abilities]
#            [/effect]
            [effect]
                apply_to=new_ability
                [abilities]
#                    {ABILITY_STEPPE_PRIDE 25}
                    {ABILITY_STEPPE_SOUL_FLAME}
                [/abilities]
            [/effect]
        [/object]
        [/then]
        [/if]
[/event]
[event]
#    name=side turn 1
    name=unused#vassal stuff is disabled for now, but it has some pretty fancy code I could reuse later
    id=steppe_kingdom_vassal_menu
    first_time_only=no

    {VARIABLE tmp_vassal_choices_left 2}

    [if]
    [have_unit]
        side=$side_number
        ability=kingdomfaction
        canrecruit=yes
        [not]
            level=0-1#to prevent this from triggering in RPG
        [/not]
    [/have_unit]
    [then]

    [if]
    [have_unit]
        ability=steppe_vassal
        side=$side_number
        search_recall_list=yes
    [/have_unit]
    [then]
    [store_unit]
        [filter]
            ability=steppe_vassal
            side=$side_number
        [/filter]
        variable=tmp_current_vassals
        kill=no
    [/store_unit]
    {VARIABLE tmp_vassal_picks_left 2}

    [if]
    [have_unit]
        side=$side_number
        ability=kingdomfaction
        canrecruit=yes
        level=4-999
    [/have_unit]
    [then]
    {VARIABLE_OP tmp_vassal_picks_left add 1}
    [/then]
    [/if]

    {VARIABLE_OP tmp_vassal_picks_left sub $tmp_current_vassals.length}#this is so you can only replace your old vassals in MP campaigns instead of constantly getting new ones

    [if]
    {VARIABLE_CONDITIONAL tmp_vassal_picks_left less_than_equal_to 0}
    [then]

    [message]
        speaker=narrator
        side_for=$side_number
        message=_"You're currently at/above max vassal amount, so you can't pick new ones at the start of battle yet."
        image=portraits/factionhint-kingdom.png
    [/message]

    [/then]
    [else]

    {REPEAT $tmp_vassal_picks_left (
    {STEPPE_VASSAL_OPTION (
        id=$tmp_steppe_leader.id
        message=_"Choose a new vassal(s) to fill your remaining vassal slots (will be added to your recall list, can choose $tmp_vassal_picks_left| vassals)"
    )}
    {VARIABLE_OP tmp_vassal_picks_left sub 1}    
    )}

    [/else]
    [/if]

    {CLEAR_VARIABLE tmp_current_vassals}
    {CLEAR_VARIABLE tmp_vassal_picks_left}
    [/then]
    [else]

    {STEPPE_VASSAL_OPTION (
        id=$tmp_steppe_leader.id
        message=_"Choose your first vassal (will be added to your recall list)"
    )}

    {STEPPE_VASSAL_OPTION (
        id=$tmp_steppe_leader.id
        message=_"Choose your second vassal (will be added to your recall list)"
    )}

    [if]
    [have_unit]
        side=$side_number
        ability=kingdomfaction
        canrecruit=yes
        level=4-999
    [/have_unit]
    [then]

    {STEPPE_VASSAL_OPTION (
        id=$tmp_steppe_leader.id
        message=_"Since your leader is level 4 or above, you can choose a third vassal (will be added to your recall list)"
    )}
    [/then]
    [/if]
    [/else]
    [/if]
    [/then]
    [/if]
[/event]
[event]
    name=recall
    id=steppe_kingdom_vassal_recall_cost_reset_event
    first_time_only=no

    [filter]
        ability=steppe_vassal_recalled
    [/filter]

#resets the recall cost to its normal state
    {MODIFY_UNIT id=$unit.id recall_cost -1}
[/event]
[event]
    name=turn refresh
    id=steppe_bravado_event
    first_time_only=no
    [store_unit]
        [filter]
            side=$side_number
            ability=steppe_bravado
        [not]
        [filter_wml]
        [status]
            petrified=yes
        [/status]
        [/filter_wml]
        [/not]
        [/filter]
        variable=bravado_unit
        kill=no
    [/store_unit]

    [foreach]
        array=bravado_unit
        index_var=i
        [do]

    [store_unit]
        [filter]
            [filter_location]
                x,y=$this_item.x,$this_item.y
                radius=2
            [/filter_location]
            [filter_side]
            [allied_with]
                side=$side_number
            [/allied_with]
            [/filter_side]
        [not]
        [filter_wml]
        [status]
            petrified=yes
        [/status]
        [/filter_wml]
        [/not]
        [/filter]
        variable=bravado_allies
        kill=no
    [/store_unit]

    [foreach]
        array=bravado_allies
        index_var=e
        [do]
        [unstore_unit]
            variable=this_item
            text=_"bravado"
            red=255
            green=255
            blue=255
            find_vacant=no
        [/unstore_unit]            
            [object]
                silent=yes
                duration=turn
                [filter]
                    find_in=this_item
                [/filter]
                [effect]
                    apply_to=attack
                    [set_specials]
                        mode=append
                        {WEAPON_SPECIAL_FIRSTSTRIKE}
                    [/set_specials]
                [/effect]
            [/object]   
        [/do]
    [/foreach]
        [/do]
    [/foreach]
    {CLEAR_VARIABLE bravado_unit}
    {CLEAR_VARIABLE bravado_allies}

[/event]
[event]
    name=turn refresh
    id=steppe_highwayman_event
    first_time_only=no
    [store_unit]
        [filter]
            side=$side_number
            ability=steppe_highwayman
        [not]
        [filter_wml]
        [status]
            petrified=yes
        [/status]
        [/filter_wml]
        [/not]
        [/filter]
        variable=highwayman_unit
        kill=no
    [/store_unit]

    [foreach]
        array=highwayman_unit
        index_var=i
        [do]

    [store_unit]
        [filter]
            [filter_location]
                x,y=$this_item.x,$this_item.y
                radius=1
            [/filter_location]
            [filter_side]
            [allied_with]
                side=$side_number
            [/allied_with]
            [/filter_side]
        [not]
        [filter_wml]
        [status]
            petrified=yes
        [/status]
        [/filter_wml]
        [/not]
        [/filter]
        variable=highwayman_allies
        kill=no
    [/store_unit]

    [foreach]
        array=highwayman_allies
        index_var=e
        [do]

        [if]
        [have_unit]
            id=$this_item.id
            [not]
            [has_attack]
                name=highwayman_torch
            [/has_attack]
            [/not]
        [/have_unit]
        [then]

        [unstore_unit]
            variable=this_item
            text=_"new attack"
            red=255
            green=125
            blue=0
            find_vacant=no
        [/unstore_unit]
            [object]
                silent=yes
                duration=scenario
                [filter]
                    find_in=this_item
                [/filter]
                [effect]
                    apply_to=new_attack
                    name=highwayman_torch
                    description=_"torch"
                    icon=attacks/torch.png    
                    type=fire
                    range=melee
                    damage=4
                    number=2
                [/effect]
                [effect]
                    apply_to=new_animation
                    [attack_anim]
                        [filter_attack]
                            name=highwayman_torch
                        [/filter_attack]
                    
                        start_time=-200
                    
                        [frame]
                        duration=300
                        [/frame]
                    
                        {SOUND:HIT_AND_MISS torch.ogg torch-miss.ogg -100}
                    [/attack_anim]
                [/effect]                
                [effect]
                    apply_to=attack
                    name=highwayman_torch
                    increase_damage=1
                    times=per level
                [/effect]
                [effect]
                    apply_to=attack
                    name=highwayman_torch
                    increase_damage=33%
                    times=per level
                [/effect]
            [/object]   
            [/then]
            [/if]
        [/do]
    [/foreach]
        [/do]
    [/foreach]
    {CLEAR_VARIABLE bravado_unit}
    {CLEAR_VARIABLE bravado_allies}
[/event]
[event]
    name=side turn
    id=steppe_soul_flame
    first_time_only=no
    [store_unit]
        [filter]
            side=$side_number
            ability=steppe_soul_flame
        [not]
        [filter_wml]
        [status]
            petrified=yes
        [/status]
        [/filter_wml]
        [/not]
        [/filter]
        variable=soulflame_unit
        kill=no
    [/store_unit]

    [foreach]
        array=soulflame_unit
        index_var=i
        [do]
        [harm_unit]
            [filter]
                [filter_adjacent]
                    id=$this_item.id
                [/filter_adjacent]
                [not]
                    [filter_wml]
                        [status]
                            petrified=yes
                        [/status]
                    [/filter_wml]
                    [or]
                        formula="self.wml_vars.faith > 1"
                    [/or]
                [/not]
                [not]
                    trait=mechanical
                [/not]
            [/filter]
            [filter_second]
                id=$this_item.id
            [/filter_second]
            amount="$(2 + $this_item.level)"
            damage_type=fire
            kill=no
#            alignment=$unit.alignment
            fire_event=yes
#            animate=defender
            animate=no
            delay=0
            experience=no
        [/harm_unit]
        [/do]
    [/foreach]
    {CLEAR_VARIABLE soulflame_unit}
[/event]
#enddef

#define ABILITY_STEPPE_VASSAL_ICON IMAGE
[vassal_icon]
    id=steppe_vassal_icon
    image={IMAGE}
[/vassal_icon]
#enddef

#define STEPPE_VASSAL_OPTION MESSAGE_PARAMS
#stored in an array

    [store_unit_type]
        type=Kingdom_Vassal_Eldest_Son,Kingdom_Vassal_Loyal_Bishop,Kingdom_Vassal_Mercenary_Ringleader,Kingdom_Vassal_Noble_Knight,Kingdom_Vassal_Bandit,Kingdom_Vassal_Elder_Troll
        variable=steppe_vassal_types
    [/store_unit_type]

    [set_variables]
        name=vassal_options[0]
        mode=replace
        [value]
        [/value]
    [/set_variables]

    [store_unit]
        [filter]
            side=$side_number
            canrecruit=yes
        [/filter]
        variable=tmp_steppe_leader
        kill=no
    [/store_unit]

    [foreach]
        array=steppe_vassal_types
        index_var=i
        [do]
        [if]
        [have_unit]
            side=$side_number
            type=$this_item.id
            search_recall_list=yes
        [/have_unit]
        [else]
        [store_gold]
            variable=actualgold
            side=$side_number
        [/store_gold]
#        {VARIABLE tmp_vassal_cost $actualgold}
#        {VARIABLE_OP tmp_vassal_cost multiply 0.2}
#        {VARIABLE_OP tmp_vassal_cost round ceil}
        {VARIABLE tmp_steppe_vassal_icon "$this_item.abilities.vassal_icon.image|~TC($side_number,magenta)"}
        {IF_VAR tmp_steppe_vassal_icon equals $steppe_emptyvar| (
        [then]
        {VARIABLE tmp_steppe_vassal_icon "$this_item.image|~TC($side_number,magenta)"}
        [/then]
        )}
        [set_variables]
            name=vassal_options
            mode=append
            [value]
                image=$tmp_steppe_vassal_icon
                description=_"$this_item.name| - costs <span color='#cccc33'>$this_item.cost|</span> gold"
                [command]
                    [unit]
                        type=$this_item.id
                        generate_name=yes
                        side=$side_number
                        x,y=recall,recall
#                        x=$tmp_steppe_leader.x
#                        y=$tmp_steppe_leader.y
                        recall_cost=$this_item.cost
                        {IS_LOYAL}                        
                        [modifications]
                            {TRAIT_LOYAL}
                            [object]
                                silent=yes
                                duration=scenario
                                [effect]
                                    apply_to=new_ability
                                    [abilities]
                                      [dummy]
                                         id=steppe_vassal_recalled #for reverting the recall cost back to 20 later on
                                      [/dummy]
                                    [/abilities]
                                [/effect]
                            [/object]
                        [/modifications]
                    [/unit]
                    [sound]
                        name=horn-signals/horn-1.ogg,horn-signals/horn-2.ogg,horn-signals/horn-6.ogg
                    [/sound]
                    [delay]
                        time=500
                    [/delay]
                    [/command]
            [/value]
        [/set_variables]
        [/else]
        [/if]
        [/do]
    [/foreach]
    {CLEAR_VARIABLE vassal_options[0]}#to fix weirdness with append

    [lua]
        code=<<
local result = wesnoth.sync.evaluate_single(
  function()
    return { value = "no" }
  end,
  function()
    -- Called only on the client handling the current side, if it is an AI.
    return { value = "yes" }
  end)
wesnoth.set_variable("steppe_is_ai"..wesnoth.current.side,result.value)
        >>
    [/lua]

    [if]
    {VARIABLE_CONDITIONAL steppe_is_ai$side_number equals yes}
    [then]
        {VARIABLE_OP ai_vassal_index rand 0.."$($vassal_options.length -1)"}#randomly chooses a vassal
#executes the [command] inside the option directly:
        [insert_tag]
            name=command
            variable=vassal_options[$ai_vassal_index]
        [/insert_tag]
    [/then]
    [else]
    [message]
        {MESSAGE_PARAMS}
        side_for=$side_number
        [insert_tag]
            name=option
            variable=vassal_options
        [/insert_tag]
    [/message]
    [/else]
    [/if]

    {CLEAR_VARIABLE vassal_options}
    {CLEAR_VARIABLE tmp_steppe_leader}
#enddef

#define ABILITY_STEPPE_MERCENARY
    [dummy]
        id=steppe_mercenary
        name=_"mercenary"
        description=_"This unit doesn't cost upkeep, but instead takes gold directly. If the unit's side doesn't have enough gold to pay, the mercenary's attacks all become defend-only for one turn. Leaders are unaffected."
    [/dummy]
    # wmlxgettext: [abilities]
[/abilities]
upkeep=0
[event]
    name=turn refresh
    id=steppe_kingdom_mercenary_payment
    first_time_only=no
#check for ringleader first
    [store_unit]
        [filter]
            side=$side_number
            ability=steppe_mercenary_ringleader
            canrecruit=no
            [not]
                x,y=recall,recall
            [/not]
        [/filter]
        variable=steppe_mercenary_ringleader
        kill=no
    [/store_unit]

    [if]
    [have_unit]
        id=$steppe_mercenary_ringleader.id
    [/have_unit]
    [then]

    [store_gold]
        variable=actualgold
        side=$side_number
    [/store_gold]

    [store_side]
        side=$side_number
        variable=tmp_currentside
    [/store_side]

    {VARIABLE tmp_ringleader_upkeep $tmp_currentside.village_gold}
    {VARIABLE_OP tmp_ringleader_upkeep multiply 2}
    {VARIABLE_OP tmp_ringleader_upkeep add 1}

    {CLEAR_VARIABLE tmp_currentside}

    [scroll_to]
        x,y=$steppe_mercenary_ringleader.x,$steppe_mercenary_ringleader.y
        side=$side_number
    [/scroll_to]

    [if]
    [variable]
        name=actualgold
        greater_than_equal_to=$tmp_ringleader_upkeep
    [/variable]
    [then]

    [gold]
        side=$side_number
        amount=-$tmp_ringleader_upkeep
    [/gold]
    [sound]
      name=gold.ogg
    [/sound]
        [unstore_unit]
            variable=steppe_mercenary_ringleader
            text=_"-$tmp_ringleader_upkeep|g"
            red=255
            green=255
            blue=0
            find_vacant=no
        [/unstore_unit]
    {VARIABLE tmp_ringleader_paid yes}
    [delay]
       time=100
    [/delay]
    [/then]
    [else]
        [unstore_unit]
            variable=steppe_mercenary_ringleader
            text=_"Unpaid"
            red=255
            green=0
            blue=0
            find_vacant=no
        [/unstore_unit]
            [object]
                silent=yes
                duration=turn
                [filter]
                    find_in=this_item
                [/filter]
                [effect]
                    apply_to=attack
                    [set_specials]
                        mode=append
                        {WEAPON_SPECIAL_STEPPE_DEFENSE_ONLY2}
                    [/set_specials]
                [/effect]
            [/object]   
    [delay]
       time=100
    [/delay]
    [/else]
    [/if]
    [/then]
    [/if]

    [store_unit]
        [filter]
            side=$side_number
            ability=steppe_mercenary
            canrecruit=no
            [not]
                x,y=recall,recall
            [/not]
        [/filter]
        variable=steppe_mercenary
        kill=no
    [/store_unit]

    [foreach]
        array=steppe_mercenary
        index_var=i
        [do]

    [store_gold]
        variable=actualgold
        side=$side_number
    [/store_gold]

#    [scroll_to]
#        x,y=$this_item.x,$this_item.y
#        side=$side_number
#    [/scroll_to]
    {VARIABLE tmp_mercenary_cost $this_item.level}

    [if]
    {VARIABLE_CONDITIONAL tmp_ringleader_paid equals yes}
    [then]
        [unstore_unit]
            variable=this_item
            text=_"No upkeep"
            red=0
            green=255
            blue=0
            find_vacant=no
        [/unstore_unit]        
    [/then]
    [else]


    [if]
    [variable]
        name=actualgold
        greater_than_equal_to=$tmp_mercenary_cost
    [/variable]
    [then]

    [gold]
        side=$side_number
        amount=-$tmp_mercenary_cost
    [/gold]
    [sound]
      name=gold.ogg
    [/sound]
        [unstore_unit]
            variable=this_item
            text=_"-$tmp_mercenary_cost|g"
            red=255
            green=255
            blue=0
            find_vacant=no
        [/unstore_unit]
    [delay]
       time=100
    [/delay]
    [/then]
    [else]
        [unstore_unit]
            variable=this_item
            text=_"Unpaid"
            red=255
            green=0
            blue=0
            find_vacant=no
        [/unstore_unit]
            [object]
                silent=yes
                duration=turn
                [filter]
                    find_in=this_item
                [/filter]
                [effect]
                    apply_to=attack
                    [set_specials]
                        mode=append
                        {WEAPON_SPECIAL_STEPPE_DEFENSE_ONLY2}
                    [/set_specials]
                [/effect]
            [/object]   
    [delay]
       time=100
    [/delay]
    [/else]
    [/if]
    [/else]
    [/if]
    {CLEAR_VARIABLE tmp_mercenary_cost}
    {CLEAR_VARIABLE actualgold}
        [/do]
    [/foreach]
    {CLEAR_VARIABLE tmp_ringleader_paid}
    {CLEAR_VARIABLE steppe_mercenary_ringleader}

    [/event]
[+abilities]
    # wmlxgettext: [/abilities]
#enddef
# wmllint: unbalanced-off

#define ABILITY_STEPPE_SERMON VALUE
    [sermon]
        id=steppe_sermon
        name=_"sermon"+" {VALUE}"
        description=_"Each turn, this unit increases the faith of adjacent allies (reduces a unit's 'sermon left' value by {VALUE}. When that reaches 0 or below, faith increases by 1). Doesn't work on non-living units. Units can only be preached to once per turn." 
        preach_value={VALUE}
    [/sermon]

     # wmlxgettext: [abilities]
[/abilities]
    [event]
    name=side turn
    id=steppe_sermon
    first_time_only=no
    [store_unit]
        [filter]
            side=$side_number
            ability=steppe_sermon
        [not]
        [filter_wml]
        [status]
            petrified=yes
        [/status]
        [/filter_wml]
        [/not]
        [/filter]
        variable=steppe_preacher
        kill=no
    [/store_unit]
    [foreach]
        array=steppe_preacher
        index_var=i
        [do]

        {VARIABLE tmp_preach_buff $this_item.abilities.sermon.preach_value}

    [store_unit]
        [filter]
            [filter_adjacent]
                x,y=$this_item.x,$this_item.y
            [/filter_adjacent]
            [filter_side]
                [allied_with]
                    side=$side_number
                [/allied_with]
            [/filter_side]
            [not]
            [filter_wml]
            [status]
                petrified=yes
            [/status]
            [or]
            [status]
                not_living=yes
            [/status]
            [/or]
            [or]
            [variables]
                faith=3#preach doesn't further increease the faith of units already at max faith
            [/variables]
            [/or]
            [/filter_wml]
            [/not]
#            [not]
#                ability=steppe_preached_to
#            [/not]
        [/filter]
        variable=sermon_allies
        kill=no
    [/store_unit]

    [if]
    {VARIABLE_CONDITIONAL sermon_allies.length greater_than 0}
    [then]

    [sound]
      name={SOUND_LIST:HOLY_OGRE_MISS}
    [/sound]
    [delay]
        time=200
    [/delay]
    [foreach]
        array=sermon_allies
        index_var=e
        [do]
        {IF_VAR this_item.variables.faith equals "" (
        [then]
            {VARIABLE this_item.variables.faith 0}
        [/then]
        )}

        {IF_VAR this_item.variables.sermons_left equals "" (
        [then]
            {VARIABLE this_item.variables.sermons_left 4}
        [/then]
        )}

        {VARIABLE_OP this_item.variables.sermons_left sub $tmp_preach_buff}

        [if]
        {VARIABLE_CONDITIONAL this_item.variables.sermons_left less_than_equal_to 0}
        [and]
        {VARIABLE_CONDITIONAL this_item.variables.faith less_than 3}
        [/and]
        [then]
            [sound]
              name={SOUND_LIST:HOLY_OGRE}
            [/sound]
            {VARIABLE_OP this_item.variables.faith add 1}
            {VARIABLE this_item.variables.sermons_left 4}
            [unstore_unit]
                variable=this_item
                text=_"faith increased!"
                red=255
                green=255
                blue=255
                find_vacant=no
            [/unstore_unit]
            [delay]
                time=200
            [/delay]
        [/then]
        [else]
            [unstore_unit]
                variable=this_item
                find_vacant=no
            [/unstore_unit]
        [/else]
        [/if]
        [fire_event]
            id=steppe_kingdom_apply_faith_buff
            [primary_unit]
                id=$this_item.id
            [/primary_unit]
        [/fire_event]
#        [object]
#            silent=yes
#            duration=turn
#            [filter]
#                find_in=this_item
#            [/filter]
#            [effect]
#                apply_to=new_ability
#                [abilities]
#                  [dummy]
#                     id=steppe_preached_to
#                  [/dummy]
#                [/abilities]
#            [/effect]
#        [/object]   

        [/do]
    [/foreach]
    {CLEAR_VARIABLE sermon_allies}

    [/then]
    [/if]

        [/do]
    [/foreach]



    {CLEAR_VARIABLE steppe_preacher}

    [/event]

[+abilities] # wmlxgettext: [/abilities]
#enddef

#define STEPPE_FAITH_BUFF FAITH_LEVEL VALUE
    [chance_to_hit]
        id=steppe_faith_buff{FAITH_LEVEL}
        add={VALUE}
        cumulative=yes
#        active_on=offense
        [filter_student]
            [filter_wml]
                [variables]
                    faith={FAITH_LEVEL}
                [/variables]
            [/filter_wml]
        [/filter_student]
        [filter_opponent]
            ability=stepped_cursed_malediction
        [/filter_opponent]
        affect_self=yes
    [/chance_to_hit]
#enddef

##define STEPPE_HERESY_BUFF HERESY_LEVEL PERCENTAGE MULT
#    [damage]
#        id=steppe_heresy_buff{HERESY_LEVEL}
#        multiply={MULT}
#        active_on=offense
#        [filter_self]
#            [filter_wml]
#                [variables]
#                    faith=-{HERESY_LEVEL}
#                [/variables]
#            [/filter_wml]
#        [/filter_self]
#        [filter_opponent]
#            formula="
#                enemy_of(self, flanker) and not flanker.petrified
#            where
#                flanker = unit_at(direction_from(loc, other.facing))
#            "
#        [/filter_opponent]
#    [/damage]
##enddef

#using ability instead of weapon special so it applies to all attacks
#define ABILITY_STEPPE_FAITH_BUFF
    [dummy]
        id=steppe_faith_buff_dummy#for filtering
    [/dummy]
    {STEPPE_FAITH_BUFF 1 5}
    {STEPPE_FAITH_BUFF 2 10}
    {STEPPE_FAITH_BUFF 3 15}
    {STEPPE_FAITH_BUFF 4 20}
#    {STEPPE_HERESY_BUFF 1 25 1.25}
#    {STEPPE_HERESY_BUFF 2 50 1.5}
#    {STEPPE_HERESY_BUFF 3 75 1.75}
#    {STEPPE_HERESY_BUFF 4 100 2}
#    [dummy]
#        id=steppe_heresy_buff_info
#        name=_"heretical blow"
#        description=_"Like backstab, but deals 25% more damage per level of heresy instead of doubling."
#        name_inactive=""
##[filter_self] doesn't seem to affect whether the ability is shown as active or not, neither does filter
#        [filter]
#            race=nonexistantrace#for debugging
##            [filter_wml]
##                [variables]
##                    faith=-1
##                    [or]
##                    faith=-2
##                    [/or]
##                    [or]
##                    faith=-3
##                    [/or]
##                    [or]
##                    faith=-4
##                    [/or]
##                [/variables]
##            [/filter_wml]
#        [/filter]
#    [/dummy]
#enddef

#define ABILITY_STEPPE_CURSED_MALEDICTION
    [dummy]
       id=stepped_cursed_malediction
       name=_"malediction"
       description=_"Enemy units have a higher chance to hit this unit based on their faith level (5% bonus chance to hit per 1 faith)"
    [/dummy]
#enddef


#define WEAPON_SPECIAL_STEPPE_MALEDICTION
# wmlindent: start ignoring
# wmlxgettext: [attack]
# wmlxgettext: [specials]

# wmlindent: stop ignoring
    [dummy]
        id=steppe_malediction
        name=_"malediction"
        description=_"This unit applies the 'malediction' effect to the target enemy for a turn. Allies have a higher chance to hit the enemy based on their own faith level (5% bonus chance to hit per 1 faith)"
    [/dummy]

[/specials]
# wmlindent: start ignoring
[/attack]
# wmlindent: stop ignoring

[event]
    name=attacker hits
    id=steppe_malediction_event1
    first_time_only=no

    [filter_attack]
        special_id=steppe_malediction
    [/filter_attack]

    [filter_second]
        [not]
            ability=stepped_cursed_malediction
        [/not]
    [/filter_second]

    [set_variable]
         name=tmp_cursed_text
         value= _ "malediction"
    [/set_variable]

    [unstore_unit]
        variable=second_unit
        find_vacant=no
        text=$tmp_cursed_text
        red,green,blue=255,255,255
    [/unstore_unit]

    [object]
        silent=yes
        duration=scenario

        [filter]
            id=$second_unit.id
        [/filter]

        [effect]
            apply_to=new_ability
            [abilities]
            {ABILITY_STEPPE_CURSED_MALEDICTION}
            [/abilities]
        [/effect]
    [/object]
    [unit_overlay]
        id=$second_unit.id
        image="misc/overlay-malediction.png"
    [/unit_overlay]

    [clear_variable]
        name=tmp_cursed_text
    [/clear_variable]
[/event]

[event]
    name=defender hits
    id=steppe_malediction_event2
    first_time_only=no

    [filter_second_attack]
        special_id=steppe_malediction
    [/filter_second_attack]

    [filter]
        [not]
            ability=stepped_cursed_malediction
        [/not]
    [/filter]

    [set_variable]
         name=tmp_cursed_text
         value= _ "malediction"
    [/set_variable]

    [unstore_unit]
        variable=unit
        find_vacant=no
        text=$tmp_cursed_text
        red,green,blue=255,255,255
    [/unstore_unit]

    [object]
        silent=yes
        duration=scenario

        [filter]
            id=$unit.id
        [/filter]

        [effect]
            apply_to=new_ability
            [abilities]
            {ABILITY_STEPPE_CURSED_MALEDICTION}
            [/abilities]
        [/effect]
    [/object]
    [unit_overlay]
        id=$unit.id
        image="misc/overlay-malediction.png"
    [/unit_overlay]

    [clear_variable]
        name=tmp_cursed_text
    [/clear_variable]
[/event]

[event]
    name=side turn end
    id=steppe_malediction_event3
    first_time_only=no

    [store_unit]
        [filter]
            side=$side_number
            ability=stepped_cursed_malediction
        [/filter]
        variable=steppe_maledictioned
        kill=no
    [/store_unit]

    {FOREACH steppe_maledictioned i}
    [remove_unit_overlay]
        id=$steppe_maledictioned[$i].id
        image="misc/overlay-malediction.png"
    [/remove_unit_overlay]
    [object]
        silent=yes
        duration=scenario

        [filter]
            id=$steppe_maledictioned[$i].id
        [/filter]

        [effect]
            apply_to=remove_ability
            [abilities]
            {ABILITY_STEPPE_CURSED_MALEDICTION}
            [/abilities]
        [/effect]
    [/object]    
    {NEXT i}

    {CLEAR_VARIABLE steppe_maledictioned}
[/event]

[event]
    name=die,steppe_customevent_changeside
    id=steppe_malediction_event_changeside
    first_time_only=no

    [filter]
        ability=stepped_cursed_malediction
    [/filter]

    [remove_unit_overlay]
        id=$unit.id
        image="misc/overlay-malediction.png"
    [/remove_unit_overlay]
    [object]
        silent=yes
        duration=scenario

        [filter]
            id=$unit.id
        [/filter]

        [effect]
            apply_to=remove_ability
            [abilities]
            {ABILITY_STEPPE_CURSED_MALEDICTION}
            [/abilities]
        [/effect]
    [/object]    
[/event]

[+attack]
# wmlindent: start ignoring

[+specials]
# wmlxgettext: [/specials]
# wmlxgettext: [/attack]
# wmlindent: stop ignoring
#enddef

#define ABILITY_STEPPE_POPE
    #basically like regular leadership, except only 15% per level
    [leadership]
        id=steppe_pope
        value="(student.wml_vars.faith * 15)"
        cumulative=yes#doesn't stack for some reason tho
        name=_"pope"
        description=_"Adjacent allies deal +15% damage per faith level."
        affect_self=no
        affect_allies=yes
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
        [/affect_adjacent]
    [/leadership]
#enddef

#define ABILITY_STEPPE_LOYAL_BISHOP
#event is in faith code
    [dummy]
        id=steppe_loyal_bishop
        name=_"loyal bishop"
        description=_"This unit increases the faith of newly-recruited units by 1."
    [/dummy]
#enddef

##define ABILITY_STEPPE_FALSE_PROPHET
##event is in faith code
#    [dummy]
#        id=steppe_false_prophet
#        name=_"false prophet"
#        description=_"This unit decreases the faith of newly-recruited units by 1, and starts with 4 heresy."
#    [/dummy]
##enddef

#define ABILITY_STEPPE_MERCENARY_RINGLEADER
#event is in mercenary code
    [dummy]
        id=steppe_mercenary_ringleader
#        name=_"mercenary ringleader"
        name=_"condottiere"
        description=_"This unit takes gold per turn equal to the income of 2 villages plus 1, but other mercenaries won't take gold while this unit is paid."
    [/dummy]
#enddef

#define ABILITY_STEPPE_BRAVADO
#event's in eventloader to avoid some weird bugs with base unit
    [dummy]
        id=steppe_bravado
        name=_"bravado"
        description=_"This unit gives firststrike to all allies in a 2-tile radius for one turn each turn."
    [/dummy]
#enddef

#define ABILITY_STEPPE_HIGHWAYMAN
#event's in eventloader to avoid some weird bugs with base unit
    [dummy]
        id=steppe_highwayman
        name=_"highwayman"
        description=_"Each turn, this unit gives all adjacent allies a melee fire attack for the rest of the scenario. The strength of the attack depends on unit level."
    [/dummy]
#enddef

#define STEPPE_FAITH_HEALING FAITH_LEVEL VALUE
    [heals]
        value={VALUE}
#        id=healingsteppe{VALUE}
        id=faith_healing{FAITH_LEVEL}
        affect_allies=yes
#        name=_"heals +{VALUE}" "лечит +{VALUE}"}
#        description=_"This unit heals adjacent units by {VALUE} HP per turn, or stops poison from taking effect for that turn." ЗД за ход, и замедляет яд."}
        affect_self=no
        poison=slowed
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
            [filter]
                [filter_wml]
                    [variables]
                        faith={FAITH_LEVEL}
                    [/variables]
                [/filter_wml]
            [/filter]
        [/affect_adjacent]
    [/heals]
#enddef

#define ABILITY_STEPPE_FAITH_HEALING
    #basically like regular leadership, except only 15% per level
    [heals]
        id=steppe_faith_healing
        value=0
        name=_"faith healing"
        description=_"Heals adjacent allies by 4 HP per point of their faith (up to +12 hp). Does not cure poison."
        affect_allies=yes
        [affect_adjacent]
            adjacent=n,ne,se,s,sw,nw
        [/affect_adjacent]
    [/heals]
    {STEPPE_FAITH_HEALING 1 4}
    {STEPPE_FAITH_HEALING 2 8}
    {STEPPE_FAITH_HEALING 3 12}
#    {STEPPE_FAITH_HEALING 4 16}
#enddef

##define ABILITY_STEPPE_HERETICAL_SPEECH
#    [dummy]
#        id=steppe_heretical_speech
#        name="heretical speech" "еретическая речь"}
#        description=_"Each turn, this unit decreases the faith of adjacent allies (takes 3 turns to decrease faith by 1) and once faith is #below 0 this ability increases heresy. Doesn't work on non-living units. Units can only be preached to once per turn." 
#    [/dummy]
#
#     # wmlxgettext: [abilities]
#[/abilities]
#    [event]
#    name=side turn
#    id=steppe_heretical_speech
#    first_time_only=no
#    [store_unit]
#        [filter]
#            side=$side_number
#            ability=steppe_heretical_speech
#        [not]
#        [filter_wml]
#        [status]
#            petrified=yes
#        [/status]
#        [/filter_wml]
#        [/not]
#        [/filter]
#        variable=steppe_heretic_preacher
#        kill=no
#    [/store_unit]
#    [foreach]
#        array=steppe_heretic_preacher
#        index_var=i
#        [do]
#
#    [store_unit]
#        [filter]
#            [filter_adjacent]
#                x,y=$this_item.x,$this_item.y
#            [/filter_adjacent]
#            [filter_side]
#                [allied_with]
#                    side=$side_number
#                [/allied_with]
#            [/filter_side]
#            [not]
#            [filter_wml]
#            [status]
#                petrified=yes
#            [/status]
#            [or]
#            [status]
#                not_living=yes
#            [/status]
#            [/or]
#            [or]
#            [variables]
#                faith=-4#preach doesn't further increease the heresy of units already at max heresy
#            [/variables]
#            [/or]
#            [/filter_wml]
#            [/not]
#            [not]
#                ability=steppe_preached_to_by_heretic
#            [/not]
#        [/filter]
#        variable=heretical_speech_allies
#        kill=no
#    [/store_unit]
#
#    [if]
#    {VARIABLE_CONDITIONAL heretical_speech_allies.length greater_than 0}
#    [then]
#
#    [sound]
#      name={SOUND_LIST:HOLY_OGRE_MISS}
#    [/sound]
#    [delay]
#        time=200
#    [/delay]
#    [foreach]
#        array=heretical_speech_allies
#        index_var=e
#        [do]
#        {IF_VAR this_item.variables.faith equals "" (
#        [then]
#            {VARIABLE this_item.variables.faith 0}
#        [/then]
#        )}
#
#        {IF_VAR this_item.variables.sermons_left equals "" (
#        [then]
#            {VARIABLE this_item.variables.sermons_left 4}
#        [/then]
#        )}
#
#        {VARIABLE_OP this_item.variables.sermons_left add 1}
#
#        [if]
#        {VARIABLE_CONDITIONAL this_item.variables.sermons_left greater_than_equal_to 3}
#        [and]
#        {VARIABLE_CONDITIONAL this_item.variables.faith greater_than -4}
#        [/and]
#        [then]
#            [sound]
#              name=magic-dark-big.ogg
#            [/sound]
#            {VARIABLE_OP this_item.variables.faith sub 1}
#            {VARIABLE this_item.variables.sermons_left 0}
#            [unstore_unit]
#                variable=this_item
##ifdef OGRE_RUSSIAN
#                text="вера ослаблена!"
##else
#                text="faith decreased!"
##endif
#                red=255
#                green=0
#                blue=60
#                find_vacant=no
#            [/unstore_unit]
#            [delay]
#                time=200
#            [/delay]
#        [if]
#        {VARIABLE_CONDITIONAL this_item.variables.faith less_than_equal_to -3}
#        [then]
#
#        [object]
#            silent=yes
#            duration=forever
#            [filter]
#                find_in=this_item
#                [not]
#                [filter_wml]
#                    alignment=chaotic
#                [/filter_wml]
#                [/not]
#            [/filter]
#            [effect]
#                apply_to=alignment
#                set=chaotic
#            [/effect]
#        [/object] 
#        [/then]
#        [/if]
#        [/then]
#        [else]
#            [unstore_unit]
#                variable=this_item
#                find_vacant=no
#            [/unstore_unit]
#        [/else]
#        [/if]
#        [fire_event]
#            id=steppe_kingdom_apply_faith_buff
#            [primary_unit]
#                id=$this_item.id
#            [/primary_unit]
#        [/fire_event]
#        [object]
#            silent=yes
#            duration=turn
#            [filter]
#                find_in=this_item
#            [/filter]
#            [effect]
#                apply_to=new_ability
#                [abilities]
#                  [dummy]
#                     id=steppe_preached_to_by_heretic
#                  [/dummy]
#                [/abilities]
#            [/effect]
#        [/object]   
#
#        [/do]
#    [/foreach]
#    {CLEAR_VARIABLE heretical_speech_allies}
#
#    [/then]
#    [/if]
#
#        [/do]
#    [/foreach]
#
#
#
#    {CLEAR_VARIABLE steppe_heretic_preacher}
#
#    [/event]
#
#[+abilities] # wmlxgettext: [/abilities]
##enddef

#define ABILITY_STEPPE_PRIDE VALUE
    #reduces damage of nearby allies
    [leadership]
        id=steppe_pride
        value=-{VALUE}
#        cumulative=yes
        cumulative=no#cumulative=yes is no longer needed in 1.16 for this to work
        name=_"pride "+{VALUE}+"%"
        description=_"This unit's pride is so intense that it makes adjacent adjacent ally units' damage reduced by "+{VALUE}+_"%. This has no effect on non-living units or other units with pride."
        affect_self=no
        affect_allies=yes
        affect_enemies=no
        [affect_adjacent]
            [filter]
#                formula="level < other.level"
            [not]
                ability=steppe_pride
                [or]                
                    {STEPPE_FEAREXEMPT}
                [/or]
            [/not]
            [/filter]
        [/affect_adjacent]
    [/leadership]
#enddef

#define ABILITY_STEPPE_SOUL_FLAME
#events in eventloader
    [dummy]
        id=steppe_soul_flame
        name=_"soul flame"
        description=_"Each turn this unit deals 2 plus unit level fire to all adjacent units, even allies. This can't kill. Does not damage units whose faith is 2 or above."
    [/dummy]
#enddef

#define ABILITY_STEPPE_ZEAL
#    #the [resistance] workaround is to show the ability as inactive in defense
#    [resistance]
    [dummy]
        id=steppe_zeal
#        add=0
#        max_value=100
#        affect_self=yes
#        active_on=offense
        name=_"zeal"
        description=_"Adjacent allies deal more damage when attacking - 15% if the same level, 30% if one level lower, 45% if two levels lower, etc. Does not work in defense. "
    [/dummy]
#    [/resistance]
     # wmlxgettext: [abilities]
[/abilities]
    [event]
    name=side turn
    id=steppe_zeal_buff
    first_time_only=no
    [store_unit]
        [filter]
            side=$side_number
            ability=steppe_zeal
        [not]
        [filter_wml]
        [status]
            petrified=yes
        [/status]
        [/filter_wml]
        [/not]
        [/filter]
        variable=steppe_zeal_unit
        kill=no
    [/store_unit]
    [foreach]
        array=steppe_zeal_unit
        index_var=i
        [do]

        [object]
            silent=yes
            duration=turn end
            [filter]
                find_in=this_item
            [/filter]
            [effect]
                apply_to=new_ability
                [abilities]
                [leadership]
                    id=steppe_zeal_buff
                    value="(15 * (level - other.level + 1))"
                    cumulative=no
                    affect_self=no
                    [affect_adjacent]
                        [filter]
                            formula="level < other.level + 1"
                        [/filter]
                    [/affect_adjacent]
                [/leadership]
                [/abilities]
            [/effect]
        [/object]

        [/do]
    [/foreach]

    {CLEAR_VARIABLE steppe_zeal_unit}

    [/event]
    [event]
    name=recruit,recall
    id=steppe_zeal_buff2
    first_time_only=no
    [filter]
        ability=steppe_zeal
    [/filter]
        [object]
            silent=yes
            duration=turn end
            [filter]
                find_in=unit
            [/filter]
            [effect]
                apply_to=new_ability
                [abilities]
                [leadership]
                    id=steppe_zeal_buff
                    value="(15 * (level - other.level + 1))"
                    cumulative=no
                    affect_self=no
                    [affect_adjacent]
                        [filter]
                            formula="level < other.level + 1"
                        [/filter]
                    [/affect_adjacent]
                [/leadership]
                [/abilities]
            [/effect]
        [/object]
    [/event]
[+abilities] # wmlxgettext: [/abilities]
#enddef

#define WEAPON_SPECIAL_STEPPE_PULL
    [dummy]
        id=steppe_pull
        name=_"pull"
        description=_"On offense, this attack moves this unit 1 tile back and pulls the enemy to its current tile. This does not work if there is an unwalkable or impassable tile behind the pulling unit (can pull units into deep water though) or if the enemy is killed by the attack. Cannot pull units with 0 max moves."
    [/dummy]
    [/specials]
[/attack]

     [event]
       name=attacker hits
       first_time_only=no
   
       [filter_attack]
           special_id=steppe_pull
       [/filter_attack]
   
       [filter_second]
           [not]
            [filter_wml]
                max_moves=0
            [/filter_wml]
           [/not]
       [/filter_second]
   
       [if]
       {VARIABLE_CONDITIONAL second_unit.hitpoints less_than_equal_to 0}
        [then]
#doesn't pull units that are about to die, as it can cause weird bugs
        [/then]
        [else]


               [store_locations]
                   [not]
                       [filter]
                       [/filter]
                       [or]
                       terrain=Q*,X*#unwalkable, impassable
                       [/or]
                   [/not]
   
                   [filter_adjacent_location]
                       x,y=$x1,$y1
                       adjacent=$unit.facing
                   [/filter_adjacent_location]
   
                   variable=pull_target_hex
               [/store_locations]
   
               [if]
                   [variable]
                       name=pull_target_hex.length
                       greater_than=0
                   [/variable]
   
                   [then]

                        #move the puller:
                        [teleport]
                            [filter]
                                x,y=$x1,$y1
                            [/filter]
                            animate=no#yes
                            
                            x,y=$pull_target_hex.x,$pull_target_hex.y
                           check_passability=yes
                           clear_shroud=yes
                        [/teleport]

                        [teleport]
                            [filter]
                                x,y=$x2,$y2
                            [/filter]
                            animate=no#yes
                            
                            x,y=$x1,$y1
                           check_passability=no#units can be pulled into unfavorable terrain like deep water
                           clear_shroud=yes
                        [/teleport]

                        [redraw]
                        [/redraw]
                       [if]
                           [have_unit]
                               x,y=$pull_target_hex.x,$pull_target_hex.y
                               id=$unit.id
                           [/have_unit]
                           [then]
                                [fire_event]
                                      name=moveto
                                      [primary_unit]
                                           x,y=$pull_target_hex.x,$pull_target_hex.y
                                      [/primary_unit]
                                [/fire_event]
                           [/then]
                       [/if]

                       [if]
                           [have_unit]
                               x,y=$x1,$y1
                               id=$second_unit.id
                           [/have_unit]
   
                           [then]
                                [fire_event]
                                      name=moveto
                                      [primary_unit]
                                           x,y=$x1,$y1
                                      [/primary_unit]
                                [/fire_event]
                           [/then]
                       [/if]
                   [/then]
               [/if]
   
               {CLEAR_VARIABLE pull_direction,pull_target_hex}
        [/else]
        [/if]
   [/event]
    [+attack]
    [+specials]
#enddef

#define WEAPON_SPECIAL_STEPPE_STORMING
    # Canned definition of the Berserk ability to be included in a
    # [specials] clause.
    [berserk]
        id=steppe_storming
        name=_"storming"
        description= _"Like berserk, but only works if the enemy is standing on castle/village terrain. Only works on offense."
        value=30
        active_on=offense
        [filter_opponent]
            [filter_location]
                terrain=*^V*,C*^*,K*^*
            [/filter_location]
        [/filter_opponent]
    [/berserk]
#enddef

##define ABILITY_STEPPE_LAUNCH_PIGS RANGE
#    [launch_pigs]
#        id=steppe_launch_pigs
#        name=_"launch pigs"+" {RANGE}"
#        description=_"This unit can launch fire pigs onto tiles in a"+" {RANGE}"+_"-tile radius. First rightclick on the unit, then on a tile to launch. This will #launch one of the pigs adjacent to the launching unit."
#        range={RANGE}
#    [/launch_pigs] # wmlxgettext: [abilities]
#[/abilities]
#    [event]
#        name=unit placed,post advance
#        id=steppe_launchpig_event
#        first_time_only=no
#        [filter]
#            ability=steppe_launch_pigs
#        [/filter]
#        [store_side]
#            side=$unit.side
#            variable=steppe_villageside
#        [/store_side]
#
#    [set_menu_item]
#        id=steppe_launch_pig
#        description=_"Launch a pig"
#        image="misc/villageicon.png"
#        [show_if]
#            {VARIABLE_CONDITIONAL gse_aiming_pig not_equals yes}
#        [/show_if]
#
#        [filter_location]
#            [filter]
#                ability=steppe_launch_pigs
#            [/filter]
#            [and]
#                [filter]
#                    side=$side_number
#                    type=Kingdom_Fire_Pig,Kingdom_Fire_Boar,Kingdom_Tsar_Bimba
#                [/filter]
#                radius=1
#            [/and]
#        [/filter_location]
#        [command]
#        {VARIABLE gse_aiming_pig yes}
#        [store_unit]
#            [filter]
#                x,y=$x1,$y1
#            [/filter]
#            variable=gse_piglauncher
#        [/store_unit]
#        [/command]
#    [/set_menu_item]
#    [set_menu_item]
#        id=steppe_launch_pig_here
#        description=_"Launch pig here"
#        image="misc/villageicon.png"
#        [show_if]
#            {VARIABLE_CONDITIONAL gse_aiming_pig equals yes}
#        [/show_if]
#
#        [filter_location]
#            [not]
#            [filter]
#            [/filter]
#            [/not]
#            [and]
#                [filter]
#                    id=$gse_piglauncher.id
#                [/filter]
#                radius=$gse_piglauncher.abilities.launch_pigs.range
#            [/and]
#        [/filter_location]
#        [command]
#            [if]
#            [have_unit]
#                type=Kingdom_Fire_Pig,Kingdom_Fire_Boar,Kingdom_Tsar_Bimba
#                [filter_location]
#                    [filter]
#                        id=$gse_piglauncher.id
#                    [/filter]
#                    radius=1
#                [/filter_location]
#            [/have_unit]
#            [then]
#            [/then]
#            [else]
#            [/else]
#            [/if]
#        {MOVE_UNIT type=Kingdom_Fire_Pig $x1 $y1}
#        {CLEAR_VARIABLE gse_aiming_pig}
#        [/command]
#    [/set_menu_item]
#    [/event]
#    [event]
#        name=side turn
#        id=gse_reset_pig_aim
#        first_time_only=no
#        {CLEAR_VARIABLE gse_aiming_pig}
#    [/event]
#[+abilities] # wmlxgettext: [/abilities]
##enddef

#define CASTLEBREAK_TERRAIN_CASE TERRAIN RUIN_TERRAIN DURABILITY RUIN_THRESHOLD RUBBLE_TERRAIN
[case]
    value={TERRAIN}
    {VARIABLE tmp_durability {DURABILITY}}
    {VARIABLE tmp_ruin_terrain {RUIN_TERRAIN}}
    {VARIABLE tmp_ruin_threshold {RUIN_THRESHOLD}}
    {VARIABLE tmp_rubble_terrain {RUBBLE_TERRAIN}}
[/case]
#enddef

#define CASTLEBREAK_TERRAIN_CASE_ONETERRAIN TERRAIN DURABILITY RUBBLE_TERRAIN
[case]
    value={TERRAIN}
    {VARIABLE tmp_durability {DURABILITY}}
    {VARIABLE tmp_ruin_terrain {TERRAIN}}
    {VARIABLE tmp_ruin_threshold 99}
    {VARIABLE tmp_rubble_terrain {RUBBLE_TERRAIN}}
[/case]
#enddef

#define CASTLEBREAK_SWITCH TERRAIN
{VARIABLE tmp_switch_terrain {TERRAIN}}
[switch]
    variable=tmp_switch_terrain
    #normal castles/keeps, which have normal/ruined versions:
    {CASTLEBREAK_TERRAIN_CASE Ce Cer 2 1 Re^Edt}
    {CASTLEBREAK_TERRAIN_CASE Ke Ker 3 2 Re^Edt}
    {CASTLEBREAK_TERRAIN_CASE Ch Chr 4 2 Rr^Dr}
    {CASTLEBREAK_TERRAIN_CASE Kh Khr 6 3 Rr^Dr}
    {CASTLEBREAK_TERRAIN_CASE Cv Cdr 4 2 Gg^Efm}
    {CASTLEBREAK_TERRAIN_CASE Kv Kdr 6 3 Rp^Dr}
    {CASTLEBREAK_TERRAIN_CASE Cd Cdr 4 2 Rd^Dr}
    {CASTLEBREAK_TERRAIN_CASE Kd Kdr 6 3 Rd^Dr}
    {CASTLEBREAK_TERRAIN_CASE Cf Cdr 5 3 Ur^Dr}
    {CASTLEBREAK_TERRAIN_CASE Kf Kdr 5 3 Ur^Dr}

    #already ruined castles, with lower durability:
    {CASTLEBREAK_TERRAIN_CASE_ONETERRAIN Cer 1 Rr^Dr}
    {CASTLEBREAK_TERRAIN_CASE_ONETERRAIN Ker 2 Rr^Dr}
    {CASTLEBREAK_TERRAIN_CASE_ONETERRAIN Chr 2 Rr^Dr}
    {CASTLEBREAK_TERRAIN_CASE_ONETERRAIN Khr 3 Rr^Dr}
    {CASTLEBREAK_TERRAIN_CASE_ONETERRAIN Cvr 2 Gg^Efm}
    {CASTLEBREAK_TERRAIN_CASE_ONETERRAIN Kvr 3 Rp^Dr}
    {CASTLEBREAK_TERRAIN_CASE_ONETERRAIN Cdr 2 Rd^Dr}
    {CASTLEBREAK_TERRAIN_CASE_ONETERRAIN Kdr 3 Rd^Dr}
    {CASTLEBREAK_TERRAIN_CASE_ONETERRAIN Cfr 2 Ud^Dr}
    {CASTLEBREAK_TERRAIN_CASE_ONETERRAIN Kfr 2 Ud^Dr}
    {CASTLEBREAK_TERRAIN_CASE_ONETERRAIN Chw 2 Ww^Dr}
    {CASTLEBREAK_TERRAIN_CASE_ONETERRAIN Khw 3 Ww^Dr}
    {CASTLEBREAK_TERRAIN_CASE_ONETERRAIN Chs 2 Ss^Dr}
    {CASTLEBREAK_TERRAIN_CASE_ONETERRAIN Khs 3 Ss^Dr}
    #castles without ruined versions:
    {CASTLEBREAK_TERRAIN_CASE_ONETERRAIN Ket 4 Rr^Edt}
    #seems to cause bugs, so commented it out
#    {CASTLEBREAK_TERRAIN_CASE_ONETERRAIN Cud 5 Ud^Dr}
#    {CASTLEBREAK_TERRAIN_CASE_ONETERRAIN Kud 5 Ud^Dr}
    {CASTLEBREAK_TERRAIN_CASE_ONETERRAIN Cm 4 Ww^Dr}
    {CASTLEBREAK_TERRAIN_CASE_ONETERRAIN Cme 3 Ww^Dr}
    {CASTLEBREAK_TERRAIN_CASE_ONETERRAIN Kme 5 Ww^Dr}
    #snow versions:
    {CASTLEBREAK_TERRAIN_CASE_ONETERRAIN Cva 4 Aa^Efm}
    {CASTLEBREAK_TERRAIN_CASE_ONETERRAIN Kva 6 Rra^Dr}
    #snow camps/castles turn to normal ruins, since snow is shaken off by all the destruction:
    {CASTLEBREAK_TERRAIN_CASE Cea Cer 2 1 Re^Edt}
    {CASTLEBREAK_TERRAIN_CASE Kea Ker 3 2 Re^Edt}
    {CASTLEBREAK_TERRAIN_CASE Cha Chr 4 2 Rr^Dr}
    {CASTLEBREAK_TERRAIN_CASE Kha Khr 6 3 Rr^Dr}



    #custom castle terrain gets 4 castle durability and 6 keep durability:
    [else]
    [if]
        [have_location]
            x,y=$tmp_x,$tmp_y
            terrain=K*
        [/have_location]
        [then]            
            {VARIABLE tmp_durability 6}
        [/then]
        [else]
            {VARIABLE tmp_durability 4}
        [/else]
    [/if]
    {VARIABLE tmp_ruin_terrain {TERRAIN}}
    {VARIABLE tmp_ruin_threshold 99}
    {VARIABLE tmp_rubble_terrain Rb^Dr}
    [/else]
[/switch]
{CLEAR_VARIABLE tmp_switch_terrain}
#enddef

#define STEPPE_DAMAGE_CASTLE X Y
    [if]
    [have_location]
        x,y={X},{Y}
        terrain=C*^*,K*^*
        [not]
            [filter]
                ability=walldummy#does not affect wall terrain
            [/filter]
        [/not]
    [/have_location]
    [then]
    {VARIABLE tmp_castle_found no}
    {VARIABLE tmp_x {X}}
    {VARIABLE tmp_y {Y}}
    {VARIABLE tmp_castle_index 0}

#    [chat]
#        message="castlebreak event"
#    [/chat]

    [foreach]
        array=kingdom_castledamage_information
        index_var=i
        [do]
        {IF_VAR this_item.x equals $tmp_x (
        [and]
            {VARIABLE_CONDITIONAL this_item.y equals $tmp_y}
        [/and]
        [then]
            {VARIABLE tmp_castle_found yes}
            {VARIABLE tmp_castle_index $i}
        [/then]
        )}
        [/do]
    [/foreach]

    [store_locations]
        x,y=$tmp_x,$tmp_y
        variable=tmp_castleloc
    [/store_locations]

    [set_variables]
        name=tmp_castle_terrain
        [split]
            list=$tmp_castleloc.terrain
            key=part
            separator=^
        [/split]
    [/set_variables]

    [if]
    {VARIABLE_CONDITIONAL tmp_castle_found equals yes}
    [then]
#        [chat]
#            message="adding damage"
#        [/chat]

        [if]
        [have_location]
            x,y=$tmp_x,$tmp_y
            terrain=Ce*^*,Ke*^*
        [/have_location]
        [then]
        [sound]
            name=wose-die.ogg
        [/sound]
        [/then]
        [else]
        [sound]
            name=castlebreak-stone.ogg
        [/sound]
        [/else]
        [/if]

        {VARIABLE_OP kingdom_castledamage_information[$tmp_castle_index].damage add 1}
        [floating_text]
           x,y=$tmp_x,$tmp_y
           text=_"<span color='#ee9405'>damaged castle: $kingdom_castledamage_information[$tmp_castle_index].damage|/$kingdom_castledamage_information[$tmp_castle_index].durability|</span>"
        [/floating_text]

        {IF_VAR kingdom_castledamage_information[$tmp_castle_index].damage equals $kingdom_castledamage_information[$tmp_castle_index].ruin_threshold (
        [then]
            [terrain]
                x,y=$tmp_x,$tmp_y
                layer=base
#                terrain=$tmp_castle_terrain[0].part|r
                terrain=$kingdom_castledamage_information[$tmp_castle_index].ruin_terrain
            [/terrain]
        [/then]
        )}
        {IF_VAR kingdom_castledamage_information[$tmp_castle_index].damage equals $kingdom_castledamage_information[$tmp_castle_index].durability (
        [then]
            #castlebreaker doesn't damage villages/forests/lightbeams (other overlays such as bridges are destroyed though)
            [if]
            [have_location]
                x,y=$tmp_x,$tmp_y
                terrain=*^V*,*^F*,*^Ii,*^Tf*
            [/have_location]
            [then]
            [terrain]
                x,y=$tmp_x,$tmp_y
                layer=base
                terrain=$kingdom_castledamage_information[$tmp_castle_index].rubble_terrain
            [/terrain]
            [/then]
            [else]
            [terrain]
                x,y=$tmp_x,$tmp_y
                layer=both
                terrain=$kingdom_castledamage_information[$tmp_castle_index].rubble_terrain
            [/terrain]
            [/else]
            [/if]
            {QUAKE explosion.ogg}
            #clear variable when the castle is destroyed
            {CLEAR_VARIABLE kingdom_castledamage_information[$tmp_castle_index]}
        [/then]
        )}
    [/then]
    [else]

    {CASTLEBREAK_SWITCH $tmp_castle_terrain[0].part}

    [if]
    [have_location]
        x,y=$tmp_x,$tmp_y
        terrain=Ce*^*,Ke*^*
    [/have_location]
    [then]
    [sound]
        name=wose-die.ogg
    [/sound]
    [/then]
    [else]
    [sound]
        name=castlebreak-stone.ogg
    [/sound]
    [/else]
    [/if]


    [set_variables]
        name=kingdom_castledamage_information
        mode=append
        [value]
            x=$tmp_x
            y=$tmp_y
            damage=1
            durability=$tmp_durability
            ruin_threshold=$tmp_ruin_threshold
            ruin_terrain=$tmp_ruin_terrain
            rubble_terrain=$tmp_rubble_terrain
        [/value]
    [/set_variables]

    #workaround for fragile castle terrains with ruin threshold of 1
    {IF_VAR tmp_ruin_threshold equals 1 (
    [then]
        [terrain]
            x,y=$tmp_x,$tmp_y
            layer=base
            terrain=$tmp_ruin_terrain
        [/terrain]
    [/then]
    )}

    [floating_text]
       x,y=$tmp_x,$tmp_y
       text=_"<span color='#ee9405'>damaged castle: 1/$tmp_durability|</span>"
    [/floating_text]

    {CLEAR_VARIABLE tmp_durability}
    {CLEAR_VARIABLE tmp_ruin_threshold}
    {CLEAR_VARIABLE tmp_ruin_terrain}
    {CLEAR_VARIABLE tmp_rubble_terrain}

    [/else]
    [/if]

#use tmp_castle_terrain[0].part to get terrain base

#any castle tile not on the list: 3
#any keep tile not on the list: 4

#    [if]
#        [have_location]
#            x,y=$tmp_x,$tmp_y
#            terrain=Ch,Ce,Cv,Cf,Cd,Kh,Ke,Kv,Kf,Kd
#        [/have_location]
#        [then]
#            [terrain]
#                x,y=$tmp_x,$tmp_y
#                layer=base
#                terrain=$tmp_castle_terrain[0].part|r
#            [/terrain]
#        [/then]
#    [/if]

    {CLEAR_VARIABLE tmp_x}
    {CLEAR_VARIABLE tmp_y}
    {CLEAR_VARIABLE tmp_castle_found}
    {CLEAR_VARIABLE tmp_castle_index}
    {CLEAR_VARIABLE tmp_castleloc}
    {CLEAR_VARIABLE tmp_castle_terrain}
    [/then]
    [/if]
#enddef

#define WEAPON_SPECIAL_STEPPE_CASTLE_BREAKER
    [castle_breaker]
        id=steppe_castle_breaker
        name=_"castle breaker"
        description=_"On offense, this attack deals damage to castle tiles (this happens when the attack misses too). This does not affect wall units. Additionally, the attack deals 50% more damage to Northern Knyazdom Triumvirate's wall units."
    [/castle_breaker]
    [damage]
        id=steppe_castle_breaker_damagemult
        multiply=1.5
        apply_to=self
        [filter_opponent]
            ability=walldummy
        [/filter_opponent]
    [/damage]    
    [/specials]
[/attack]
[event]
    name=attacker hits
    id=steppe_castlebreaker_event
    first_time_only=no
   
    [filter_attack]
        special_id=steppe_castle_breaker
    [/filter_attack]
   
#this filter is now part of the damage castle macro
#    [filter_second]
#        [not]
#            ability=walldummy#does not affect wall terrain
#        [/not]
#        [filter_location]
#            terrain=C*,K*
#        [/filter_location]
#    [/filter_second]

    {STEPPE_DAMAGE_CASTLE $x2 $y2}
[/event]
[event]
    name=attacker misses
    id=steppe_castlebreaker_event2
    first_time_only=no
   
    [filter_attack]
        special_id=steppe_castle_breaker
    [/filter_attack]
   
#this filter is now part of the damage castle macro
#    [filter_second]
#        [not]
#            ability=walldummy#does not affect wall terrain
#        [/not]
#        [filter_location]
#            terrain=C*,K*
#        [/filter_location]
#    [/filter_second]

    {STEPPE_DAMAGE_CASTLE $x2 $y2}
[/event]
[event]
    name=side turn,turn end
    id=gse_kingdom_check_castles
    first_time_only=no
    #if there are any castle variable tiles that are no longer castles (for example due to map change), clear them:
    #TODO: use while loop instead of foreach, like in abilities_ogre
    [foreach]
        array=kingdom_castledamage_information
        index_var=i
        [do]
        [/do]
    [/foreach]
[/event]
[+attack]
[+specials]
#enddef

#define WEAPON_SPECIAL_STEPPE_CASTLE_DESTROYER
    [dummy]
        id=steppe_castle_destroyer
        name=_"castle destroyer"
        description=_"On offense, if the enemy is standing on a castle tile, the tile is destroyed on hit. This does not affect wall units. Additionally, the attack deals 50% more damage to Northern Knyazdom Triumvirate's wall units."
    [/dummy]
    [damage]
        id=steppe_castle_breaker_damagemult
        multiply=1.5
        apply_to=self
        [filter_opponent]
            ability=walldummy
        [/filter_opponent]
    [/damage]    
    [/specials]
[/attack]
[event]
    name=attacker hits
    id=steppe_castledestroyer_event
    first_time_only=no
   
    [filter_attack]
        special_id=steppe_castle_destroyer
    [/filter_attack]
   
    [filter_second]
        [not]
            ability=walldummy#does not affect wall terrain
        [/not]
        [filter_location]
            terrain=C*^*,K*^*
        [/filter_location]
    [/filter_second]

    {VARIABLE tmp_castle_found no}
    {VARIABLE tmp_x $x2}
    {VARIABLE tmp_y $y2}
    {VARIABLE tmp_castle_index 0}

#    [chat]
#        message="castlebreak event"
#    [/chat]

    [foreach]
        array=kingdom_castledamage_information
        index_var=i
        [do]
        {IF_VAR this_item.x equals $tmp_x (
        [and]
            {VARIABLE_CONDITIONAL this_item.y equals $tmp_y}
        [/and]
        [then]
            {VARIABLE tmp_castle_found yes}
            {VARIABLE tmp_castle_index $i}
        [/then]
        )}
        [/do]
    [/foreach]

    [store_locations]
        x,y=$tmp_x,$tmp_y
        variable=tmp_castleloc
    [/store_locations]

    [set_variables]
        name=tmp_castle_terrain
        [split]
            list=$tmp_castleloc.terrain
            key=part
            separator=^
        [/split]
    [/set_variables]

    [if]
    {VARIABLE_CONDITIONAL tmp_castle_found equals yes}
    [then]

    [if]
    [have_location]
        x,y=$tmp_x,$tmp_y
        terrain=Ce*^*,Ke*^*
    [/have_location]
    [then]
    [sound]
        name=wose-die.ogg
    [/sound]
    [/then]
    [else]
    [sound]
        name=castlebreak-stone.ogg
    [/sound]
    [/else]
    [/if]

       #castle destroyer doesn't damage lightbeams (destroys villages/forests unlike castle breaker though)
       [if]
       [have_location]
           x,y=$tmp_x,$tmp_y
           terrain=*^Ii
       [/have_location]
       [then]
       [terrain]
           x,y=$tmp_x,$tmp_y
           layer=base
           terrain=$kingdom_castledamage_information[$tmp_castle_index].rubble_terrain
       [/terrain]
       [/then]
       [else]
       [terrain]
           x,y=$tmp_x,$tmp_y
           layer=both
           terrain=$kingdom_castledamage_information[$tmp_castle_index].rubble_terrain
       [/terrain]
       [/else]
       [/if]
       #clear variable when the castle is destroyed
       {CLEAR_VARIABLE kingdom_castledamage_information[$tmp_castle_index]}
    [/then]
    [else]

    {CASTLEBREAK_SWITCH $tmp_castle_terrain[0].part}

    [terrain]
        x,y=$tmp_x,$tmp_y
        layer=both
        terrain=$tmp_rubble_terrain
    [/terrain]
    {CLEAR_VARIABLE tmp_durability}
    {CLEAR_VARIABLE tmp_ruin_threshold}
    {CLEAR_VARIABLE tmp_ruin_terrain}
    {CLEAR_VARIABLE tmp_rubble_terrain}

    [/else]
    [/if]

    {CLEAR_VARIABLE tmp_x}
    {CLEAR_VARIABLE tmp_y}
    {CLEAR_VARIABLE tmp_castle_found}
    {CLEAR_VARIABLE tmp_castle_index}
    {CLEAR_VARIABLE tmp_castleloc}
    {CLEAR_VARIABLE tmp_castle_terrain}
[/event]
[+attack]
[+specials]
#enddef

#define ABILITY_WEALTHY NUMBER 
    [wealthy]
        id=steppe_wealthy
        name=_"wealthy "+{NUMBER}
        description=_"This unit generates"+" {NUMBER} "+_"gold for his side each turn."
        income={NUMBER}
    [/wealthy]
     # wmlxgettext: [abilities]
[/abilities]
    [event]
    name=side turn
    first_time_only=no
    [store_unit]
        [filter]
            side=$side_number
            ability=steppe_wealthy
            [not]
            [filter_wml]
            [status]
                petrified=yes
            [/status]
            [/filter_wml]
            [/not]
        [/filter]
        variable=steppe_wealthy
        kill=no
    [/store_unit]

    [foreach]
        array=steppe_wealthy
        index_var=i
        [do]
    [scroll_to]
        x,y=$this_item.x,$this_item.y
        side=$side_number
    [/scroll_to]
    [gold]
        side=$side_number
        amount=$this_item.abilities.wealthy.income
    [/gold]
    [sound]
      name=gold.ogg
    [/sound]
        [unstore_unit]
            variable=this_item
            text=_"$this_item.abilities.wealthy.income|g"
            red=255
            green=255
            blue=0
            find_vacant=no
        [/unstore_unit]
    [delay]
       time=100
    [/delay]
        [/do]
    [/foreach]

    [/event]

[+abilities] # wmlxgettext: [/abilities]
#enddef