#textdomain wesnoth-gse

#define ABILITY_OGREFACTION
	[dummy]
		id=ogrefaction
	[/dummy]
#enddef

#define ABILITY_STEPPE_CATTLE
#dummy ability to show the unit has no upkeep, but also a proper ability that makes the unit not capture villages
	[dummy]
		id=steppe_cattle
		name=_"cattle"
		description=_"This unit costs no upkeep, but is unable to capture villages."
	[/dummy]
	 # wmlxgettext: [abilities]
[/abilities]
#cattle can't capture villages
[event]
	name=capture
	first_time_only=no
	[filter]
			ability=steppe_cattle
	[/filter]
	[allow_undo] [/allow_undo]
	[capture_village]
		## reset ownership to prior Side
		x,y=$x1,$y1
		side=$owner_side
		fire_event=no
	[/capture_village]
	[/event]
[+abilities] # wmlxgettext: [/abilities]
#enddef



#define EVENTLOADER_EVENTS_OGRE
	[event]
	# is used to show icon in status bar
		 name=preload
		 first_time_only=no
		 id=show_imprisoned
		 [lua]
			 code=<<
				 local _ = wesnoth.textdomain "wesnoth-gse"
				 local old_unit_status = wesnoth.theme_items.unit_status
				 function wesnoth.theme_items.unit_status()
					 local u = wesnoth.get_displayed_unit()
					 if not u then return {} end
					 local s = old_unit_status()
					 if u.status.captured then
						 table.insert(s, { "element", {
							 image = "items/cage.png~SCALE(20,20)",
							 tooltip = _"Captured: This unit is captured. It cannot move, or attack, has no ZoC, and it's defense on all mainline types of terrain is reduced by 10%, but the unit can still retaliate, and doesn't cost any upkeep to his side. After several turns pass without the unit being freed, the unit is automatically sold into slavery."
						 } })
					 end
					 return s
				 end
			 >>
		 [/lua]
	[/event]
#currently disabled, might be used for another faction later on:
[event]
id=ogre_rushevent
name=recruit,recall
first_time_only=no
[filter]
ability=ogrefaction_unused#currently unused
#[not]
#    canrecruit=yes
#[/not]
[/filter]
[if]
{VARIABLE_CONDITIONAL ogreera_disablerush not_equals yes}
[then]
{VARIABLE unit.moves "$($unit.moves| + ($unit.max_moves| / 2) )"}
[unstore_unit]
variable=unit
text= _ "Charge!"
red=0
green=255
blue=0
[/unstore_unit] 
{CLEAR_VARIABLE raidermoves}
[/then]
[/if]
[/event]
#free all prisoners on leader death:
[event]
	name=die
	id=steppe_ogre_leaderdeath_freeprisoners
	first_time_only=no
	[filter]
			canrecruit=yes
	[/filter]

#    [chat]
#        message="leaderdeath slavefree event triggered"
#    [/chat]

	[if]
	[not]
	[have_unit]
	canrecruit=yes
	side=$unit.side
	[/have_unit]
	[/not]
	[then]

#    [chat]
#        message="lack of leader filter passed"
#    [/chat]

	[store_unit]
		[filter]
		   ability=steppe_captured
		[/filter]
		variable=steppe_captured_units
		kill=no
	[/store_unit]

	[foreach]
		array=steppe_captured_units
		index_var=a
		[do]

		[foreach]
			array=capture_unit_information
			index_var=c
			[do]
			[if]
				[variable]
					name=this_item.seller_side
					equals=$unit.side
				[/variable]
				[then]

				{VARIABLE tmp_correct_capturer_side yes}
	
#                [chat]
#                    message="side filter passed"
#                [/chat]
				[/then]
			[/if]
			[/do]
		[/foreach]


		[if]
			[variable]
				name=tmp_correct_capturer_side
				equals=yes
			[/variable]
			[then]

#            [chat]
#                message="freeing unit"
#            [/chat]
			{STEPPE_FREEUNIT $this_item.x $this_item.y}
			[/then]
		[/if]
		{CLEAR_VARIABLE tmp_correct_capturer_side}        
		[/do]
	[/foreach]

	{CLEAR_VARIABLE steppe_captured_units}
	[/then]
	[/if]
[/event]
[event]
	name=pre advance
	id=steppe_ogre_scale_cage_image_event1
	first_time_only=no
	[filter]
	  ability=steppe_captured
	[/filter]

	[remove_unit_overlay]
		id=$unit.id
		image="items/cage.png~SCALE($unit.variables.cage_image_size_width|,$unit.variables.cage_image_size_height|)"
	[/remove_unit_overlay]
[/event]

[event]
	name=post advance
	id=steppe_ogre_scale_cage_image_event2
	first_time_only=no
	[filter]
	  ability=steppe_captured
	[/filter]

	{STEPPE_LUA_CALCULATE_UNIT_SPRITE_SIZE unit steppe_cagesize_calc_width steppe_cagesize_calc_height}

	{VARIABLE unit.variables.cage_image_size_width $steppe_cagesize_calc_width}
	{VARIABLE unit.variables.cage_image_size_height $steppe_cagesize_calc_height}

	[unstore_unit]
		variable=unit
		find_vacant=no
	[/unstore_unit]

	[unit_overlay]
		id=$unit.id
		image="items/cage.png~SCALE($unit.variables.cage_image_size_width|,$unit.variables.cage_image_size_height|)"
	[/unit_overlay]
[/event]

[event]
	name=start
	id=steppe_cagecalculator_menu
	first_time_only=no

#clear the burning tile and destroyed village variables, for multiplayer campaign. This isn't exactly airtight (it won't work if the mad changes mid-battle, but otherwise should be good enough for campaigns)
	{CLEAR_VARIABLE burning_tile_information}
	{CLEAR_VARIABLE destroyed_village_information}

	[set_menu_item]
		id=steppe_cagecalculator
		description=_"Calculate whether this unit can freed"
		image=items/book2.png~CROP(21,23,27,24)~SCALE(20,20)
		#DO NOT SET SYNCED TO NO FOR ANY MENUS THAT ACTUALLY AFFECT THE GAME!!!
		synced=yes
		[show_if]
		{VARIABLE_CONDITIONAL steppe_disable_calculator_menu not_equals yes}
		[/show_if]

		[filter_location]
			[filter]
				ability=steppe_captured
			[/filter]
		[/filter_location]
		[command]
	[allow_undo] [/allow_undo]

	[store_unit]
		[filter]
			x,y=$x1,$y1
		[/filter]

		variable=steppe_cagecalc_unit
		kill=no
	[/store_unit]

	{VARIABLE freer_points 0}
	{VARIABLE capturer_points 0}

	[if]
	[have_unit]
			id=$steppe_cagecalc_unit.id
			[filter_side]
			[allied_with]
				side=$side_number
			[/allied_with]
			[/filter_side]
	[/have_unit]
	[then]
	{VARIABLE steppe_cagecalc_freer_color 00ff00}
	{VARIABLE steppe_cagecalc_capturer_color ff0000}
	[/then]
	[else]
	{VARIABLE steppe_cagecalc_freer_color ff0000}
	{VARIABLE steppe_cagecalc_capturer_color 00ff00}
	[/else]
	[/if]

#macro from below
	{STEPPE_CAGE_LEVELCALC steppe_cagecalc_unit $x1 $y1}

	[if]
	{VARIABLE_CONDITIONAL freer_points greater_than $capturer_points}
	[then]

	{VARIABLE steppe_cagecalc_canfree _"Yes"}

	{VARIABLE steppe_cagecalc_canfree_color $steppe_cagecalc_freer_color}

	[/then]
	[else]

	{VARIABLE steppe_cagecalc_canfree _"No"}

	{VARIABLE steppe_cagecalc_canfree_color $steppe_cagecalc_capturer_color}

	[/else]
	[/if]
 
		[message]
			speaker=narrator
			side_for=$side_number
			caption=_"Cage freeing calculator"
			message=_"Total capturer levels: <span color='#$steppe_cagecalc_capturer_color|'>$capturer_points|</span>

Total level of freers: <span color='#$steppe_cagecalc_freer_color|'>$freer_points|</span>

Can the unit be freed: <span color='#$steppe_cagecalc_canfree_color|'>$steppe_cagecalc_canfree|</span>

(note: this menu only calculates only the <b>current</b> total levels, which can easily change during an enemy's turn)"
			image=portraits/factionhint-ogre.png
		[/message]

	{CLEAR_VARIABLE freer_points}
	{CLEAR_VARIABLE capturer_points}
	{CLEAR_VARIABLE capturer_points1}
	{CLEAR_VARIABLE capturer_points2}
	{CLEAR_VARIABLE steppe_cagecalc_unit}
	{CLEAR_VARIABLE steppe_cagecalc_canfree}
	{CLEAR_VARIABLE steppe_cagecalc_oversight}
	{CLEAR_VARIABLE steppe_cagecalc_oversight_true}
	{CLEAR_VARIABLE steppe_cagecalc_capturer_color}
	{CLEAR_VARIABLE steppe_cagecalc_freer_color}
	{CLEAR_VARIABLE steppe_cagecalc_canfree_color}

		[/command]
	[/set_menu_item]
[/event]
#enddef

#define STEPPE_DESTROYVILLAGE ARSONVAR TERRAIN
	[store_locations]
		x,y=$x1,$y1
		variable=tmp_steppe_village_location
	[/store_locations]
	[set_variables]
		name=destroyed_village_information
		mode=append
		[value]
			x=${ARSONVAR}.x
			y=${ARSONVAR}.y
			terrain=$tmp_steppe_village_location.terrain
		[/value]
	[/set_variables]
	{CLEAR_VARIABLE tmp_steppe_village_location}
[terrain]
terrain={TERRAIN}
x,y=${ARSONVAR}.x,${ARSONVAR}.y
layer=overlay
[/terrain]
	[if]
	[have_unit]
		id=${ARSONVAR}.id
		ability=steppe_arsontype_trample
	[/have_unit]
	[then]
	[item]
		x=${ARSONVAR}.x
		y=${ARSONVAR}.y
		name=steppe_rubble
		image=scenery/rubble.png
	[/item]
	[/then]
	[else]
	{RANDOM 1..4}
	[item]
		x=${ARSONVAR}.x
		y=${ARSONVAR}.y
		name=steppe_burnedvillage
		image=scenery/village-human-burned$random|.png
	[/item]
#fixed tarbynns creating fire when destroying villages
	[if]
	[have_unit]
		id=${ARSONVAR}.id
		ability=steppe_arsontype_tarbynn
	[/have_unit]
	[else]
	[item]
		x=${ARSONVAR}.x
		y=${ARSONVAR}.y
		name=steppe_flames
		halo=scenery/flames[01~15].png:50
	[/item]
	[sound_source]
		id=steppe_flames_${ARSONVAR}.x|_${ARSONVAR}.y|
		sounds=ambient/campfire.ogg
		delay=9000
		chance=100
		check_fogged=no
		check_shrouded=yes
		x,y=${ARSONVAR}.x,${ARSONVAR}.y
		full_range=5
		fade_range=3
		loop=-1
	[/sound_source]
	[set_variables]
		name=burning_tile_information
		mode=append
		[value]
			x=${ARSONVAR}.x
			y=${ARSONVAR}.y
			turn_of_extinguish=$"($turn_number| + 3)"
			turn_of_true_extinguish=$"($turn_number| + 6)"
		[/value]
	[/set_variables]
	[/else]
	[/if]
	[/else]
	[/if]
	[store_side]
		side=${ARSONVAR}.side
		variable=arsonistside
	[/store_side]
#    {VARIABLE arsongold "$($arsonistside.village_gold| * (2 + ${ARSONVAR}.level|))"}
	{VARIABLE arsongold "$($arsonistside.village_gold| * 2 + 1)"}
		{MODIFY_UNIT x,y=${ARSONVAR}.x,${ARSONVAR}.y attacks_left 0}
#    [scroll_to]
#        x,y=${ARSONVAR}.x,${ARSONVAR}.y
#    [/scroll_to]
	[gold]
		side=$side_number
		amount=$arsongold
	[/gold]
	[sound]
	  name=gold.ogg
	[/sound]
	#give experience for burning down villages:
	{VARIABLE_OP {ARSONVAR}.experience add 3}
		[unstore_unit]
			variable={ARSONVAR}
			text=_"$arsongold|g"
			red=255
			green=255
			blue=0
			find_vacant=no
		[/unstore_unit]
	[fire_event]
		name=post pillage
		[primary_unit]
			x,y=$x1,$y1
		[/primary_unit]
	[/fire_event]    
#enddef

#define ARSONEVENT ARSONVAR
{IF_VAR steppe_disable_pillage_scrolling not_equals yes (
[then]
	[scroll_to]
		x,y=${ARSONVAR}.x,${ARSONVAR}.y
	[/scroll_to]
[/then]
)}

	[if]
	[have_unit]
		id=${ARSONVAR}.id
		ability=steppe_arsontype_tarbynn
	[/have_unit]
	[then]
	[sound]
		name=magic-dark-big.ogg
	[/sound]
	[delay]
		time=120
	[/delay]
	[sound]
		name=wose-die.ogg
	[/sound]
	[delay]
		time=180
	[/delay]
	{STEPPE_DESTROYVILLAGE {ARSONVAR} ^}
	[/then]
	[else]

	[if]
	[have_unit]
		id=${ARSONVAR}.id
		ability=steppe_arsontype_trample
	[/have_unit]
	[then]
	[sound]
		name=horse-canter.wav
	[/sound]
	[delay]
		time=120
	[/delay]
	[sound]
		name=mace.ogg
	[/sound]
	[delay]
		time=220
	[/delay]
	[sound]
		name=wose-die.ogg
	[/sound]
	[delay]
		time=180
	[/delay]

#    {STEPPE_DESTROYVILLAGE {ARSONVAR} ^Es}
	{STEPPE_DESTROYVILLAGE {ARSONVAR} ^}
	[/then]
	[else]
	[sound]
#        name=melee-fire.ogg
		name=fire.wav
	[/sound]
	[delay]
		time=120
	[/delay]
	[sound]
		name=fire.wav
	[/sound]
	[delay]
		time=220
	[/delay]
	[sound]
		name=wose-die.ogg
	[/sound]
	[delay]
		time=180
	[/delay]
	[sound]
		name=torch-miss.ogg
	[/sound]
	{STEPPE_DESTROYVILLAGE {ARSONVAR} ^Ecf}
	[/else]
	[/if]
	[/else]
	[/if]

#        {MODIFY_UNIT x,y=${ARSONVAR}.x,${ARSONVAR}.y moves $(${ARSONVAR}.max_moves / 3|)}
		{MODIFY_UNIT x,y=${ARSONVAR}.x,${ARSONVAR}.y moves 0}
	[delay]
	   time=200
	[/delay]

		[modify_unit]
			[filter]
				id=${ARSONVAR}.id
			[/filter]
			[status]
				poisoned=no
			[/status]
		[/modify_unit]
		[heal_unit]
			[filter]
				id=${ARSONVAR}.id
			[/filter]
			amount=8
			animate=yes
			restore_statuses=no
		[/heal_unit]

		{CLEAR_VARIABLE arsonmoves}
		{CLEAR_VARIABLE arsongold}
		{CLEAR_VARIABLE arsonist}
		{CLEAR_VARIABLE arsonistside}
#enddef

#define ABILITY_PILLAGE TYPE
	# Canned definition of the Pillage ability to be included in an
	# [abilities] clause.  Note: this is deliberately unbalanced WML,
	# in order to close the abilities clause then insert the event
	# then reopen the abilities clause.
	[dummy]
		id=steppe_pillage
		name=_"pillage"
#so the ability is invisible when inactive:
		name_inactive=""
		female_name_inactive=""
		description=_"Whener this unit kills an enemy, they earn their side an amount of gold equal to 75% (rounded up) of the killed enemy's gold cost.

		When moving onto a village, this unit automatically destroys it, giving the arsonist's side some gold (equal to 2+1 times the side's village gold setting), giving the unit 3 experience, healing the unit by 8 HP and removing poison. This ability does not work while enslaved. If a unit with pillage is leader (except in RPG), the side gains a bit of extra income to compensate for the faction usually not being able to hold villages."
		[filter]
		[not]
			ability=steppe_slave
		[/not]
		[/filter]
	[/dummy]
	[dummy]
		id=steppe_arsontype_{TYPE}
	[/dummy]
	# wmlxgettext: [abilities]
[/abilities]
[event]
	name=moveto
	id=steppe_arson_event
	first_time_only=no
	[filter]
			ability=steppe_pillage
	[filter_location]
			terrain=*^V*
	[/filter_location]
		[not]
			ability=steppe_slave
		[/not]
	[/filter]
	[store_unit]
		[filter]
		   x,y=$x1,$y1
		[/filter]
		variable=arsonist
		kill=no
	[/store_unit]
	{ARSONEVENT arsonist}
[/event]
[event]
	id=steppe_pillaging_event
	name=die
	first_time_only=no

	[filter]
	[not]
		ability=steppe_notrigger_onkill_abilities
	[/not]
	[/filter]

	[filter_second]
		ability=steppe_pillage
		[not]
			ability=steppe_slave
			[or]
			ability=steppe_notrigger_onkill_abilities
			[/or]
		[/not]
	[/filter_second]

		[store_unit]
			[filter]
				 x,y=$x1,$y1
			[/filter]
			variable=lootedunit
		[/store_unit]
		{VARIABLE lootgold "$($lootedunit.cost| * 0.75)"}
		{VARIABLE_OP lootgold round ceil}
	[gold]
		side=$second_unit.side
		amount=$lootgold
	[/gold]
	[sound]
	  name=gold.ogg
	[/sound]
		[unstore_unit]
			variable=second_unit
			text=_"$lootgold|g"
			red=255
			green=255
			blue=0
			find_vacant=no
		[/unstore_unit]
		{CLEAR_VARIABLE lootedunit}
		{CLEAR_VARIABLE lootedunittype}
		{CLEAR_VARIABLE lootgold}
[/event]
[event]
	name=side turn
	id=steppe_fireextinguish_event
	first_time_only=no
#    [chat]
#        message=_"fire extinguish event triggered"
#    [/chat]

	[foreach]
		array=burning_tile_information
		index_var=i
		[do]
		[if]
			[variable]
				name=this_item.turn_of_extinguish
				less_than_equal_to=$turn_number
			[/variable]

			[then]
#                [chat]
#                    message=_"fire extinguish event succeeded x: $this_item.x, y: $this_item.y"
#                [/chat]

				[remove_item]
					x=$this_item.x
					y=$this_item.y
					image=steppe_flames
				[/remove_item]

 
#                [clear_variable]
#                    name=this_item
#                [/clear_variable]
			[/then]
		[/if]

		[if]
			[variable]
				name=this_item.turn_of_true_extinguish
				less_than_equal_to=$turn_number
			[/variable]

			[then]
#                [chat]
#                    message=_"fire true extinguish event succeeded x: $this_item.x, y: $this_item.y"
#                [/chat]

				[terrain]
				terrain=^
				x,y=$this_item.x,$this_item.y
				layer=overlay
				[/terrain]
 
				[remove_sound_source]
					id=steppe_flames_$this_item.x|_$this_item.y|
				[/remove_sound_source]

				[clear_variable]
					name=this_item
				[/clear_variable]
			[/then]
		[/if]
		[/do]
	[/foreach]
[/event]
[event]
	name=side turn 1
	id=steppe_ogre_income_bonus
	first_time_only=no

	[store_unit]
		[filter]
			side=$side_number
			canrecruit=yes
			ability=steppe_pillage
		[/filter]
		variable=tmp_pillage_leader
		kill=no
	[/store_unit]

	[store_side]
		side=$side_number
		variable=steppe_incomebonus_side
	[/store_side]

	[if]
	[have_unit]
		id=$tmp_pillage_leader.id
	[/have_unit]
	[and]
		{VARIABLE_CONDITIONAL steppe_incomebonus_side.recruit not_equals ""}#prevents the bonus for triggering in RPG
	[/and]
	[then]

#        [chat]
#            message=$steppe_incomebonus_side.income
#        [/chat]

		{VARIABLE tmp_newincome $steppe_incomebonus_side.income}
		{VARIABLE tmp_incomebonus $steppe_incomebonus_side.village_gold}
		{VARIABLE_OP tmp_incomebonus multiply 1.5}
		{VARIABLE_OP tmp_incomebonus round ceil}
		{VARIABLE_OP tmp_newincome add $tmp_incomebonus}

		[modify_side]
			side=$side_number
			income=$tmp_incomebonus
		[/modify_side]

		[unstore_unit]
			variable=tmp_pillage_leader
			text=_"+$tmp_incomebonus| income"
			red=255
			green=255
			blue=0
			find_vacant=no
		[/unstore_unit]
	[/then]
	[/if]

	{CLEAR_VARIABLE tmp_pillage_leader}
	{CLEAR_VARIABLE steppe_incomebonus_side}
	{CLEAR_VARIABLE tmp_newincome}
	{CLEAR_VARIABLE tmp_incomebonus}
[/event]
[+abilities]
	# wmlxgettext: [/abilities]
#enddef
# wmllint: unbalanced-off

#for the slavers' capture ability:

#define STEPPE_DEFENSE_CHANGE VALUE
					[effect]
						apply_to=defense
			replace=no
			  [defense]
			deep_water={VALUE}
				shallow_water={VALUE}
				swamp_water={VALUE}
				reef={VALUE}
				flat={VALUE}
				sand={VALUE}
				forest={VALUE}
				hills={VALUE}
				mountains={VALUE}
				village={VALUE}
				castle={VALUE}
				cave={VALUE}
				frozen={VALUE}
#               unwalkable={VALUE}
				fungus={VALUE}
			  [/defense]
					[/effect]
#enddef
#define STEPPE_DEFENSE_MPCOST_CHANGE VALUE MPCOST
					[effect]
						apply_to=defense
			replace=no
			  [defense]
			deep_water={VALUE}
				shallow_water={VALUE}
				swamp_water={VALUE}
				reef={VALUE}
				flat={VALUE}
				sand={VALUE}
				forest={VALUE}
				hills={VALUE}
				mountains={VALUE}
				village={VALUE}
				castle={VALUE}
				cave={VALUE}
				frozen={VALUE}
#               unwalkable={VALUE}
				fungus={VALUE}
			  [/defense]
					[/effect]
					[effect]
						apply_to=movement_costs
			replace=no
			  [movement_costs]
			deep_water={MPCOST}
				shallow_water={MPCOST}
				swamp_water={MPCOST}
				reef={MPCOST}
				flat={MPCOST}
				sand={MPCOST}
				forest={MPCOST}
				hills={MPCOST}
				mountains={MPCOST}
				village={MPCOST}
				castle={MPCOST}
				cave={MPCOST}
				frozen={MPCOST}
				unwalkable={MPCOST}
				fungus={MPCOST}
			  [/movement_costs]
					[/effect]
#enddef

#define STEPPE_FREEUNIT X Y
[if]
[have_unit]
	x,y={X},{Y}
	ability=steppe_captured
[/have_unit]
[then]
			[modify_unit]
			  [filter]
				 x,y={X},{Y}
			  [/filter]
			  upkeep=full
			[/modify_unit]
			[object]
				silent=yes
#                duration=scenario
				[filter]
					x,y={X},{Y}
				[/filter]
			[effect]
				apply_to=attack
				remove_specials=steppe_defense_only2
			[/effect]
			[effect]
				apply_to=remove_ability
				[abilities]
				  [dummy]
					 id=steppe_captured
				  [/dummy]
				[/abilities]
			[/effect]   
#            {STEPPE_DEFENSE_MPCOST_CHANGE -20 -90}
			{STEPPE_DEFENSE_MPCOST_CHANGE -10 -90}
			[/object]
		[store_unit]
			[filter]
				x,y={X},{Y}
			[/filter]
			variable=steppe_captured
			kill=no
		[/store_unit]
		[capture_village]
			side=$steppe_captured.side
			x,y={X},{Y}
		[/capture_village]
	{IF_VAR steppe_captured.level greater_than 0 (
	[then]
		  {VARIABLE steppe_captured.zoc yes}
	[/then])}
		{VARIABLE steppe_captured_halfmp $steppe_captured.moves}
		{VARIABLE_OP steppe_captured_halfmp divide 2}
		{VARIABLE_OP steppe_captured_halfmp round floor}
		{VARIABLE steppe_captured.moves $steppe_captured_halfmp}
	{CLEAR_VARIABLE steppe_captured_halfmp}

#remove the unit from the list of captured units


#TODO: try to fix this buggy mess (check inspect when they are more than 2 captured units and one is freed)
#    [foreach]
#        array=capture_unit_information
#        index_var=c
#        [do]
#        [chat]
#            message="currently viewing capture information index:"$c
#        [/chat]
#        {IF_VAR this_item.id equals $steppe_captured.id (
#            [then]
#            [chat]
#                message="deleted capture information index:"$c|$this_item.id|
#            [/chat]
#                {CLEAR_VARIABLE this_item}
#                {VARIABLE_OP c sub 1}#this is to fix weirdness when something in an array is deleted
#            [/then]
#        )}
#        [/do]
#    [/foreach]
 
#using a while loop (original deprcated FOREACH implementation) instead of foreach as it's better for deleting array elements

{VARIABLE c 0}
[while]
	[variable]
	name=c
	less_than=$capture_unit_information.length
	[/variable]
	[do]
		{IF_VAR capture_unit_information[$c].id equals $steppe_captured.id (
			[then]
#            [chat]
#                message="deleted capture information index:"$c|$capture_unit_information[$c].id|
#            [/chat]
				{CLEAR_VARIABLE capture_unit_information[$c]}
				{VARIABLE_OP c sub 1}#this is to fix weirdness when something in an array is deleted
			[/then]
		)}
	[set_variable]
	name=c
	add=1
	[/set_variable]
	[/do]
[/while]
{CLEAR_VARIABLE c}

	[sound]
	  name={SOUND_LIST:HOLY}
	[/sound]
		[unstore_unit]
			variable=steppe_captured
		text=_"Freedom!"
		{COLOR_HEAL}
		find_vacant=no
		[/unstore_unit]
#        [chat]
#            message="$steppe_captured.id| $steppe_captured.variables.cage_image_size_width|,$steppe_captured.variables.cage_image_size_height|"
#        [/chat]
		[remove_unit_overlay]
			id=$steppe_captured.id
			image="items/cage.png~SCALE($steppe_captured.variables.cage_image_size_width|,$steppe_captured.variables.cage_image_size_height|)"
		[/remove_unit_overlay]
[/then]
[/if]
{CLEAR_VARIABLE steppe_captured}
#enddef

#define STEPPE_CAGE_LEVELCALC UNITVAR X Y
	{TOTAL_LEVEL_CALC (
	[filter_side]
	[allied_with]
		side=${UNITVAR}.side
	[/allied_with]
	[/filter_side]
	[not]
			ability=steppe_captured
			[or]
			  level=0
			[/or]
			[or]
				[filter_wml]
				[status]
					petrified=yes
				[/status]
				[/filter_wml]
			[/or]
	[/not]
	[filter_location]
		x,y={X},{Y}
		radius=2
	[/filter_location]
	) freer_points a}

	{TOTAL_LEVEL_CALC (
	[filter_side]
	[enemy_of]
		side=${UNITVAR}.side
	[/enemy_of]
	[/filter_side]
	[not]
			ability=steppe_captured
			[or]
			  level=0
			[/or]
			[or]
				[filter_wml]
				[status]
					petrified=yes
				[/status]
				[/filter_wml]
			[/or]
	[/not]
	[filter_location]
		x,y={X},{Y}
		radius=2
	[/filter_location]
	) capturer_points a}
#enddef


#define WEAPON_SPECIAL_STEPPE_CAPTURE
	[dummy]
		id=steppe_capture
		name=_"capture"
		description=_"Instead of a killing units, this attack captures them instead. Captured units are put in a cage, moved behind the capturer, and, if not freed within 1 turn, are automatically sold into slavery, and the capturer side gains gold equal to 125% of the unit cost, and if the capturer unit still exists, they gain the same exp that they would get if they killed the unit. 

		While in a cage, the unit can't move/attack and their defense on all terrain is reduced by 10%, but they can still retaliate. If a unit that is on (or allied with) the side of of a captured unit moves next to them, and the total level of nearby allies (in a 2-tile radius from the unit) is higher than that of the nearby enemies (in a 2-tile radius from the unit), the captured unit is freed. The captured unit isn't sold if there are more freers than capturers adjacent to the cage (regardless of level difference).

		Does not work on buildings or enemies that are already captured."
	[/dummy]
	[/specials]
[/attack]
[event]
	name=last breath
	id=steppe_capture_event
	first_time_only=no
	[filter]
	[not]
		ability=steppe_captured
	[or]
		ability=steppe_building
	[/or]
	[/not]
	[/filter]
   
	[filter_second_attack]
		special_id=steppe_capture
	[/filter_second_attack]

			   [store_locations]
				   [not]
					   [filter]
					   [/filter]
					   [or]
					   terrain=M*,Q*,X*,Wo*^* #mountains, unwalkable, impassable, and deep water
					   [/or]
				   [/not]
   
				   [filter_adjacent_location]
					   x,y=$x2,$y2
					   adjacent=-$unit.facing
				   [/filter_adjacent_location]
   
				   variable=knockback_target_hex
			   [/store_locations]

#reduces the capturer's exp, so that no exp is gained from capturing (to prevent exp exploits)
	{EXP_VALUE_CALC $unit.id steppe_captured_exp}
	[store_unit]
		[filter]
			id=$second_unit.id
		[/filter]
		variable=capturer_exp
		kill=no
	[/store_unit]
	{VARIABLE_OP capturer_exp.experience sub $steppe_captured_exp}
	{VARIABLE_OP capturer_exp.experience add $unit.level}#add exp equal to having attacked the unit normally
	[unstore_unit]
		variable=capturer_exp
		find_vacant=no
	[/unstore_unit]
	{CLEAR_VARIABLE capturer_exp}
	{CLEAR_VARIABLE steppe_captured_exp}

	{VARIABLE unit.hitpoints $unit.max_hitpoints}
	{VARIABLE_OP unit.hitpoints multiply 0.33}
	{VARIABLE_OP unit.hitpoints round ceil}
#    {VARIABLE unit.status.captured yes}
	[sound]
	  name=slowed.wav
	[/sound]

	{STEPPE_LUA_CALCULATE_UNIT_SPRITE_SIZE unit steppe_cagesize_calc_width steppe_cagesize_calc_height}

	{VARIABLE unit.variables.cage_image_size_width $steppe_cagesize_calc_width}
	{VARIABLE unit.variables.cage_image_size_height $steppe_cagesize_calc_height}

	[unstore_unit]
		variable=unit
		text=_"Captured!"
		red=255
		green=126
		blue=0
		find_vacant=no
	[/unstore_unit]

	[unit_overlay]
		x,y=$x1,$y1
		image="items/cage.png~SCALE($unit.variables.cage_image_size_width|,$unit.variables.cage_image_size_height|)"
	[/unit_overlay]
	[object]
		silent=yes
#        duration=scenario
		[filter]
			find_in=unit
		[/filter]
		[effect]
			apply_to=attack
			[set_specials]
				mode=append
				{WEAPON_SPECIAL_STEPPE_DEFENSE_ONLY2}
			[/set_specials]
		[/effect]
		[effect]
			apply_to=zoc
			value=no
		[/effect]
		[effect]
			apply_to=new_ability
			[abilities]
			  [dummy]
				 id=steppe_captured
			  [/dummy]
			[/abilities]
		[/effect]   
#        {STEPPE_DEFENSE_MPCOST_CHANGE 20 90}
		{STEPPE_DEFENSE_MPCOST_CHANGE 10 90}
	[/object]
	[set_variables]
		name=capture_unit_information
		mode=append
		[value]
			id=$unit.id
#            side=$unit.side
#            turn_of_selling=$"($turn_number| + 3)"
#            turn_of_selling=$"($turn_number| + 2)"
			turn_of_selling=$"($turn_number| + 1)"
			seller_side=$second_unit.side
			seller_id=$second_unit.id
		[/value]
	[/set_variables]
			   [if]
				   [variable]
					   name=knockback_target_hex.length
					   greater_than=0
				   [/variable]
   
				   [then]
						[teleport]
							[filter]
								x,y=$x1,$y1
							[/filter]
							animate=no#yes
							
							x,y=$knockback_target_hex.x,$knockback_target_hex.y
						   check_passability=yes
						   clear_shroud=yes
						[/teleport]
						[redraw]
						[/redraw]
#                       [if]
#                           [have_unit]
#                               x,y=$knockback_target_hex.x,$knockback_target_hex.y
#                           [/have_unit]
#   
#                           [then]
#                               [fire_event]
#                                      name=moveto
#                                      [primary_unit]
#                                           x,y=$knockback_target_hex.x,$knockback_target_hex.y
#                                      [/primary_unit]
#                               [/fire_event]
#                           [/then]
#                       [/if]
				   [/then]
			   [/if]
   
			   {CLEAR_VARIABLE knockback_direction,knockback_target_hex}
[/event]
[event]
	name=moveto
	id=steppe_freeunit_event
	first_time_only=no
	[filter]
	[filter_location]
			[filter]
			ability=steppe_captured
			[filter_side]
			[allied_with]
				side=$unit.side
			[/allied_with]
			[/filter_side]
			[/filter]
			radius=1
	[/filter_location]
	[/filter]
	[store_unit]
		[filter]
			ability=steppe_captured
			[filter_side]
			[allied_with]
				side=$unit.side
			[/allied_with]
			[/filter_side]
		[filter_location]
			x,y=$x1,$y1
			radius=1
		[/filter_location]
		[/filter]
		variable=steppe_freedunit
		kill=no
	[/store_unit]
	[if]
	[variable]
		name=steppe_freedunit.length
		greater_than=0
	[/variable]
	[then]

	[foreach]
		array=steppe_freedunit
		index_var=i
		[do]
	{VARIABLE freer_points 0}
	{VARIABLE capturer_points 0}

	{STEPPE_CAGE_LEVELCALC this_item $this_item.x $this_item.y}

	{IF_VAR freer_points greater_than $capturer_points (
	[then]

	{VARIABLE prisoner_tofree yes}
	{STEPPE_FREEUNIT $this_item.x $this_item.y}
	[/then]
	[else]
#this is so even lvl0s can free units when there are no enemies nearby
	{IF_VAR capturer_points less_than 1 (
	[then]

	{VARIABLE prisoner_tofree yes}
	{STEPPE_FREEUNIT $this_item.x $this_item.y}
	[/then]
	[else]
	{VARIABLE prisoner_tofree no}
	[/else]
	)}

	[/else]
	)}
	
	[if]
	{VARIABLE_CONDITIONAL prisoner_tofree not_equals yes}
	[then]
	[sound]
	  name=mace-miss.ogg
	[/sound]
	[unstore_unit]
		variable=this_item
		text=_"Not enough units
		 to free!"
		red=255
		green=128
		blue=0        
		find_vacant=no
	[/unstore_unit]
	[/then]
	[/if]

#    [chat]
#       speaker=_"Debug"
#       message= _ "Freer points: $freer_points|. Slaver points: $capturer_points|. Prisoner free: $prisoner_tofree|"
#    [/chat]
	{CLEAR_VARIABLE freer_points}
	{CLEAR_VARIABLE capturer_points}
	{CLEAR_VARIABLE prisoner_tofree}
	[delay]
	   time=100
	[/delay]
		[/do]
	[/foreach]

	{CLEAR_VARIABLE steppe_freedunit}
	[/then]
	[/if]
[/event]
[event]
	name=side turn
	id=steppe_capture_autosell_event
	first_time_only=no

{VARIABLE autosell_index 0}
[while]
	[variable]
	name=autosell_index
	less_than=$capture_unit_information.length
	[/variable]
	[do]

#        [chat]
#            message="currently viewing capture information index:"$i
#        [/chat]

		[if]
			[variable]
				name=capture_unit_information[$autosell_index].turn_of_selling
				less_than_equal_to=$turn_number
			[/variable]
			[and]
				[variable]
					name=capture_unit_information[$autosell_index].seller_side
					equals=$side_number
				[/variable]
			[/and]
			[then]
				#check if there are more freers than sellers next to the cage when trying to sell
				[store_unit]
					[filter]
					[filter_side]
					[allied_with]
						side=$capture_unit_information[$autosell_index].seller_side
					[/allied_with]
					[/filter_side]
					[filter_location]
					[filter]
						id=$capture_unit_information[$autosell_index].id
					[/filter]
					radius=1
					[/filter_location]
					[not]
						ability=steppe_captured
						[or]
							[filter_wml]
							[status]
								petrified=yes
							[/status]
							[/filter_wml]
						[/or]
					[/not]
					[/filter]
					variable=tmp_steppe_sellers
					kill=no
				[/store_unit]
				[store_unit]
					[filter]
					[filter_side]
					[enemy_of]
						side=$capture_unit_information[$autosell_index].seller_side
					[/enemy_of]
					[/filter_side]
					[filter_location]
					[filter]
						id=$capture_unit_information[$autosell_index].id
					[/filter]
					radius=1
					[/filter_location]
					[not]
						ability=steppe_captured
						[or]
							[filter_wml]
							[status]
								petrified=yes
							[/status]
							[/filter_wml]
						[/or]
					[/not]
					[/filter]
					variable=tmp_steppe_freers
					kill=no
				[/store_unit]
			
				[if]
				{VARIABLE_CONDITIONAL tmp_steppe_sellers.length greater_than $tmp_steppe_freers.length}
				[or]
				{VARIABLE_CONDITIONAL tmp_steppe_freers.length less_than 1} #second check just in case there are no sellers or freers nearby
				[/or]
				[else]
			
				[store_unit]
					[filter]
						id=$capture_unit_information[$autosell_index].id
					[/filter]
					variable=steppe_soldunit
					kill=no
				[/store_unit]
					[unstore_unit]
						variable=steppe_soldunit
						text=_"Too many enemies next
						to the cage to sell!"
						red=255
						green=128
						blue=0        
						find_vacant=no
					[/unstore_unit]
					{CLEAR_VARIABLE steppe_soldunit}
				[/else]
				[then]
			
					[if]
						[have_unit]
							id=$capture_unit_information[$autosell_index].id
							ability=steppe_captured
						[/have_unit]
						[then]
						[/then]
						[else]
						#if the unit is freed, remove the variables
						{CLEAR_VARIABLE capture_unit_information[$autosell_index]}
						{VARIABLE_OP autosell_index sub 1}#this is to fix weirdness when something in an array is deleted
						[/else]
					[/if]

							[store_unit]
								[filter]
									id=$capture_unit_information[$autosell_index].id
								[/filter]
								variable=steppe_soldunit
								kill=no
							[/store_unit]
						#        {VARIABLE capturegold "$($captureunittype.cost| * 1.33)"}
								{VARIABLE capturegold "$($steppe_soldunit.cost| * 1.25)"}
								{VARIABLE_OP capturegold round ceil}
						
							[if]
							#check if any units from the capturer's side still exist
								[have_unit]
									side=$capture_unit_information[$autosell_index].seller_side
								[/have_unit]
								[then]
							[gold]
								side=$capture_unit_information[$autosell_index].seller_side
								amount=$capturegold
							[/gold]
							[sound]
							  name=gold.ogg
							[/sound]
						
								[unstore_unit]
									variable=steppe_soldunit                        
									text=_"$capturegold|g"
									red=255
									green=255
									blue=0
									find_vacant=no
								[/unstore_unit]
			
					[/then]
					[else]
					[/else]
				[/if]
			
			[if]
			#check if the capturer still exists
				[have_unit]
					id=$capture_unit_information[$autosell_index].seller_id
				[/have_unit]
				[then]
			#give the capturer exp
				{EXP_VALUE_CALC $capture_unit_information[$autosell_index].id steppe_captured_exp}
				[store_unit]
					[filter]
						id=$capture_unit_information[$autosell_index].seller_id
					[/filter]
					variable=capturer_exp
					kill=no
				[/store_unit]
				{VARIABLE_OP capturer_exp.experience add $steppe_captured_exp}
				[unstore_unit]
					variable=capturer_exp
					find_vacant=no
					advance=yes
					fire_event=yes#fires any advance/post advance events
				[/unstore_unit]
				{CLEAR_VARIABLE capturer_exp}
				{CLEAR_VARIABLE steppe_captured_exp}
				[/then]
			[/if]
			
				[object]
					silent=yes
					duration=scenario
					[filter]
						id=$capture_unit_information[$autosell_index].id
					[/filter]
					[effect]
						apply_to=new_ability
						[abilities]
						  [dummy]
							 id=steppe_notrigger_onkill_abilities #dummy ability used for disabling on
						  [/dummy]
						[/abilities]
					[/effect]   
				[/object]
			
			[if]
			#check if the capturer still exists
				[have_unit]
					id=$capture_unit_information[$autosell_index].seller_id
				[/have_unit]
				[then]
					[kill]
						id=$capture_unit_information[$autosell_index].id
						animate=no
						fire_event=yes
					[secondary_unit]
						id=$capture_unit_information[$autosell_index].seller_id
					[/secondary_unit]
					[/kill]
				[/then]
				[else]
				[if]
				#check if any units from the capturer's side still exist
					[have_unit]
						side=$capture_unit_information[$autosell_index].seller_side
					[/have_unit]
					[then]
					[kill]
						id=$capture_unit_information[$autosell_index].id
						animate=no
						fire_event=yes
					[secondary_unit]
						side=$capture_unit_information[$autosell_index].seller_side
					[/secondary_unit]
					[/kill]
					[/then]
					[else]
					{STEPPE_FREEUNIT $steppe_soldunit.x $steppe_soldunit.y}
					[/else]
				[/if]
				[/else]
			[/if]
			#        {CLEAR_VARIABLE capturedunittype}
			#        {CLEAR_VARIABLE capturedgold}
					{CLEAR_VARIABLE steppe_soldunit}
			
			
			#                {MODIFY_UNIT id=$capture_unit_information[$autosell_index].id status.slowed yes}
	
#            [chat]
#                message="deleted capture information index:"$i|$capture_unit_information[$autosell_index].id|
#            [/chat]

	
					[clear_variable]
						name=capture_unit_information[$autosell_index]
					[/clear_variable]

					{VARIABLE_OP autosell_index sub 1}#this is to fix weirdness when something in an array is deleted    
				[/then]
			[/if]

			[/then]
		[/if]
	{CLEAR_VARIABLE tmp_steppe_sellers}
	{CLEAR_VARIABLE tmp_steppe_freers}
	[set_variable]
	name=autosell_index
	add=1
	[/set_variable]
	[/do]
[/while]
{CLEAR_VARIABLE autosell_index}

[/event]

[event]
	name=victory
	id=steppe_capture_victory_event
	first_time_only=no

	{CLEAR_VARIABLE capture_unit_information}
[/event]
	[+attack]
	[+specials]
#enddef

#define ABILITY_OGRE_BODYGUARD
	#used by the Ogre Bodyguard unit
	[resistance]
		id=steppe_ogre_bodyguard
		add=10
		max_value=30
		apply_to=blade,pierce,impact,fire,cold,arcane
		name=_"bodyguard"
		description=_"If standing next to either a Ogre Mancatcher, Ogre Slaver Apprentice or Ogre Slaver, this unit deals 20% more damage, and the other units(s) gain a 10% bonus to all resistances (up to 30%."
		affect_self=no
		affect_allies=yes
		[affect_adjacent]
			adjacent=n,ne,se,s,sw,nw
		[filter]
			ability=steppe_ogre_bodyguarded
		[/filter]
		[/affect_adjacent]
		[filter_base_value]
			less_than=30
		[/filter_base_value]
	[/resistance]
#enddef

#define ABILITY_OGRE_BODYGUARDED
	#used by the mancatcher/slaver apprentice/slaver
	#invisible ability used both as a filter, and as a 20% damage buff to the bodyguard (as I couldn't code an adjacent filter properly)
	[leadership]
		id=steppe_ogre_bodyguarded
		value=20
		cumulative=no
		affect_self=no
		affect_allies=yes
		[affect_adjacent]
			[filter]
				ability=steppe_ogre_bodyguard
			[/filter]
		[/affect_adjacent]
	[/leadership]
#enddef

#define ABILITY_DEPLETING NUMBER
	[dummy]
		id=depleting{NUMBER}
		name=_"depleting"+" -{NUMBER}"
		description=_"This unit loses "+{NUMBER}+_" hp each turn. Like poison, this ability cannot kill the unit."
	[/dummy]

	 # wmlxgettext: [abilities]
[/abilities]
	[event]
	name=side turn
	id=steppe_depleting{NUMBER}_event
	first_time_only=no
	[store_unit]
		[filter]
			side=$side_number
			ability=depleting{NUMBER}
		[not]
		[filter_wml]
		[status]
			petrified=yes
		[/status]
		[/filter_wml]
		[/not]
		[/filter]
		variable=depleting
		kill=no
	[/store_unit]
	[if]
	[variable]
		name=depleting.length
		greater_than=0
	[/variable]
	[then]
	{FOREACH depleting i}


		[harm_unit]
			[filter]
				id=$depleting[$i].id
			[/filter]
			amount={NUMBER}
			experience=no
			fire_event=yes
			animate=no
			kill=no
		[/harm_unit] 
	[delay]
	   time=100
	[/delay]
	{NEXT i}
	{CLEAR_VARIABLE depleting}
	[/then]
	[/if]
	[/event]

[+abilities] # wmlxgettext: [/abilities]
#enddef

#define ABILITY_THUNDERSTRIKE NUMBER
	[dummy]
		id=thunderstrike{NUMBER}
		name=_"thunderstrike "+{NUMBER}
		description=_"Each turn, this unit attacks a random adjacent enemy with lightning, dealing "+{NUMBER}+_" fire damage."
	[/dummy]

	 # wmlxgettext: [abilities]
[/abilities]
	[event]
	name=side turn
	id=steppe_thunderstrike{NUMBER}
	first_time_only=no
	[store_unit]
		[filter]
			side=$side_number
			ability=thunderstrike{NUMBER}
		[not]
		[filter_wml]
		[status]
			petrified=yes
		[/status]
		[/filter_wml]
		[/not]
		[/filter]
		variable=thundershaman
		kill=no
	[/store_unit]
	[if]
	[variable]
		name=thundershaman.length
		greater_than=0
	[/variable]
	[then]
	{FOREACH thundershaman e}
	[store_unit]
		[filter]
			[filter_adjacent]
				x,y=$thundershaman[$e].x,$thundershaman[$e].y
			[/filter_adjacent]
			[filter_side]
				[enemy_of]
					side=$side_number
				[/enemy_of]
			[/filter_side]
			[not]
			[filter_wml]
			[status]
				petrified=yes
			[/status]
			[/filter_wml]
			[/not]
		[/filter]
		variable=thundertarget
		kill=no
	[/store_unit]
	[if]
	[variable]
		name=thundertarget.length
		greater_than=0
	[/variable]
	[then]
	{VARIABLE thundertarget_random_limit $thundertarget.length}
	{VARIABLE_OP thundertarget_random_limit sub 1}
	{RANDOM 0..$thundertarget_random_limit}

#since the array number is offset by one from the length (if there are 2 units, the length is 2, but the units are [0] and [1])

	[animate_unit]
		flag=attack
		[filter]
			id=$thundershaman[$e].id
		[/filter]
		[filter_second]
			id=$thundertarget[$random].id
		[/filter_second]
		[primary_attack]
			name=lightning
		[/primary_attack]
		[facing]
			x,y=$thundertarget[$random].x,$thundertarget[$random].y
		[/facing]
		hits=yes
	[/animate_unit]
#    [chat]
#        message=_"target: $thundertarget[$random].id, facing: $thundershaman[$e].facing, random $random, length: $thundertarget.length"
#    [/chat]
	[harm_unit]
		[filter]
			id=$thundertarget[$random].id
		[/filter]
		[filter_second]
			id=$thundershaman[$e].id
		[/filter_second]
		amount={NUMBER}
#        alignment=$thundershaman[$e].alignment
		damage_type=fire
		experience=yes
		fire_event=yes
		animate=yes
	[/harm_unit] 
	[/then]
	[/if]
	{NEXT e}
	{CLEAR_VARIABLE thundershaman}
	{CLEAR_VARIABLE thundertarget}
	{CLEAR_VARIABLE thundertarget_random_limit}
	[/then]
	[/if]
	[/event]

[+abilities] # wmlxgettext: [/abilities]
#enddef


#define ABILITY_LIFESTEAL_AURA NUMBER
	[dummy]
		id=lifesteal_aura{NUMBER}
		name=_"lifesteal aura "+{NUMBER}
		description=_"Each turn, this unit deals "+{NUMBER}+" damage to adjacent living enemies, and heals self by "+{NUMBER}+_" HP for each enemy damaged. Like poison, this can't kill."
	[/dummy]

	 # wmlxgettext: [abilities]
[/abilities]
	[event]
	name=side turn
	id=steppe_lifesteal_aura{NUMBER}
	first_time_only=no
	[store_unit]
		[filter]
			side=$side_number
			ability=lifesteal_aura{NUMBER}
		[not]
		[filter_wml]
		[status]
			petrified=yes
		[/status]
		[/filter_wml]
		[/not]
		[/filter]
		variable=lifestealer
		kill=no
	[/store_unit]
	[if]
	[variable]
		name=lifestealer.length
		greater_than=0
	[/variable]
	[then]
	{FOREACH lifestealer e}
	[store_unit]
		[filter]
			[filter_adjacent]
				x,y=$lifestealer[$e].x,$lifestealer[$e].y
			[/filter_adjacent]
			[filter_side]
				[enemy_of]
					side=$side_number
				[/enemy_of]
			[/filter_side]
			[not]
			[filter_wml]
			[status]
				petrified=yes
			[/status]
			[or]
			[status]
				undrainable=yes
			[/status]
			[/or]
			[/filter_wml]
			[/not]
		[/filter]
		variable=lifesteal_target
		kill=no
	[/store_unit]

	{VARIABLE tmp_lifesteal_heal 0}

	[if]
	[variable]
		name=lifesteal_target.length
		greater_than=0
	[/variable]
	[then]
	{FOREACH lifesteal_target l}

#since the array number is offset by one from the length (if there are 2 units, the length is 2, but the units are [0] and [1])

	[animate_unit]
		flag=drain_anim
		[filter]
			id=$lifestealer[$e].id
		[/filter]
		[facing]
			x,y=$lifesteal_target[$l].x,$lifesteal_target[$l].y
		[/facing]
		hits=yes
	[/animate_unit]
#    [chat]
#        message=_"target: $lifesteal_target[$random].id, facing: $lifestealer[$e].facing, random $random, length: $lifesteal_target.length"
#    [/chat]
	[harm_unit]
		[filter]
			id=$lifesteal_target[$l].id
		[/filter]
		[filter_second]
			id=$lifestealer[$e].id
		[/filter_second]
		amount={NUMBER}
#        alignment=$lifestealer[$e].alignment
#        damage_type=fire
		experience=yes
		fire_event=yes
		animate=yes
		experience=no
		kill=no
	[/harm_unit]
	{VARIABLE_OP tmp_lifesteal_heal add {NUMBER}}

	{NEXT l}
	[/then]
	[/if]

		[heal_unit]
			[filter]
				id=$lifestealer[$e].id
			[/filter]
			amount=$tmp_lifesteal_heal
			animate=yes
			restore_statuses=no
		[/heal_unit]

	{NEXT e}
	{CLEAR_VARIABLE lifestealer}
	{CLEAR_VARIABLE lifesteal_target}
	{CLEAR_VARIABLE tmp_lifesteal_heal}
	[/then]
	[/if]
	[/event]

[+abilities] # wmlxgettext: [/abilities]
#enddef
